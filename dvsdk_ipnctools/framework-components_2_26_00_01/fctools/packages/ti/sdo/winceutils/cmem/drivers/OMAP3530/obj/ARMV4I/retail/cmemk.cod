; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	I:\library\trees\winceutils\winceutils-b01x\src\ti\sdo\winceutils\cmem\drivers\cmemk.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.data|, DATA
	 COMMON	|gdwPageSize|, 0x4

	 COMMON	|CMKDevice|, 0x8

	 COMMON	|p_objs|, 0x1c00


  00000			 AREA	 |.bss|, NOINIT
|real_block_virtp| % 0x8
|real_block_start| % 0x8
|block_virtp| %	0x8
|block_virtoff| % 0x8
|block_virtend| % 0x8
|block_start| %	0x8
|block_end| %	0x8
|block_avail_size| % 0x8
|total_num_buffers| % 0x8
|mem_alloc_type| % 0x8
|reference_count| % 0x4
|numBlocks| %	0x4
|phys_start| %	0x4
|phys_end| %	0x4
|npools| %	0x8
|pools|	%	0x200
|phys_start_1| % 0x4
|phys_end_1| %	0x4
|pools_1| %	0x200
|allowOverlap| % 0x4
|useHeapIfPoolUnavailable| % 0x4
|cmem_mutex| %	0x4
|heap_size| %	0x8
|heap_virtp| %	0x8
|heap_head| %	0x10

  00000			 AREA	 |.data|, DATA
|version| DCD	0x2200000
|heap_pool| DCD	0xffffffff
	DCD	0xffffffff
	EXPORT	|GetCurrentProcessId|
	IMPORT	|__GetUserKData|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41071| DCD	|$LN5@GetCurrent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentProcessId| PROC

; 373  : _inline DWORD GetCurrentProcessId(void) {

  00000		 |$LN5@GetCurrent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41068|

; 374  :     return __GetUserKData (SYSHANDLE_OFFSET + (SH_CURPROC * sizeof(HANDLE)));

  00004	e3a0000c	 mov         r0, #0xC
  00008	eb000000	 bl          __GetUserKData

; 375  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M41069|

			 ENDP  ; |GetCurrentProcessId|

	EXPORT	|HeapMem_alloc|
; File i:\library\trees\winceutils\winceutils-b01x\src\ti\sdo\winceutils\cmem\drivers\cmemk.c

  00000			 AREA	 |.pdata|, PDATA
|$T41097| DCD	|$LN20@HeapMem_al|
	DCD	0x40003a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HeapMem_alloc| PROC

; 305  : {

  00000		 |$LN20@HeapMem_al|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M41094|
  00004	e1a07003	 mov         r7, r3
  00008	e1a06002	 mov         r6, r2
  0000c	e1a05001	 mov         r5, r1

; 306  :     HeapMem_Header *prevHeader, *newHeader, *curHeader;
; 307  :     char *allocAddr;
; 308  :     size_t curSize, adjSize;
; 309  :     size_t remainSize; /* free memory after allocated memory      */
; 310  :     size_t adjAlign, offset;
; 311  : //    long key;
; 312  : 
; 313  : #if 0
; 314  :     /* Assert that requested align is a power of 2 */
; 315  :     Assert_isTrue(((reqAlign & (reqAlign - 1)) == 0), HeapMem_A_align);
; 316  : 
; 317  :     /* Assert that requested block size is non-zero */
; 318  :     Assert_isTrue((reqSize != 0), HeapMem_A_zeroBlock);
; 319  : #endif
; 320  : 
; 321  :     adjSize = reqSize;
; 322  : 
; 323  :     /* Make size requested a multiple of HEAP_ALIGN */
; 324  :     if ((offset = (adjSize & (HEAP_ALIGN - 1))) != 0) {

  00010	e59fe0cc	 ldr         lr, [pc, #0xCC]

; 325  :         adjSize = adjSize + (HEAP_ALIGN - offset);
; 326  :     }
; 327  : 
; 328  :     /*
; 329  :      *  Make sure the alignment is at least as large as HEAP_ALIGN.
; 330  :      *  Note: adjAlign must be a power of 2 (by function constraint) and
; 331  :      *  HEAP_ALIGN is also a power of 2,
; 332  :      */
; 333  :     adjAlign = reqAlign;
; 334  :     if (adjAlign & (HEAP_ALIGN - 1)) {
; 335  :         /* adjAlign is less than HEAP_ALIGN */
; 336  :         adjAlign = HEAP_ALIGN;
; 337  :     }
; 338  : 
; 339  :     /*
; 340  :      *  NOTE: We don't need a "gate" here since this function is called
; 341  :      *  after acquiring a mutex.
; 342  :      */
; 343  : 
; 344  :     /*
; 345  :      *  The block will be allocated from curHeader. Maintain a pointer to
; 346  :      *  prevHeader so prevHeader->next can be updated after the alloc.
; 347  :      */
; 348  :     prevHeader  = &heap_head[bi];

  00014	e59f40c4	 ldr         r4, [pc, #0xC4]
  00018	e59e2000	 ldr         r2, [lr]

; 349  :     curHeader = prevHeader->next;

  0001c	e7b43180	 ldr         r3, [r4, +r0, lsl #3]!
  00020	e2421001	 sub         r1, r2, #1
  00024	e011e005	 ands        lr, r1, r5
  00028	1042e00e	 subne       lr, r2, lr
  0002c	108e5005	 addne       r5, lr, r5
  00030	e1110006	 tst         r1, r6
  00034	11a06002	 movne       r6, r2
  00038	e1b00003	 movs        r0, r3

; 350  : 
; 351  :     /* Loop over the free list. */
; 352  :     while (curHeader != NULL) {

  0003c	0a00000a	 beq         |$LN10@HeapMem_al|
  00040	e2461001	 sub         r1, r6, #1
  00044		 |$LL11@HeapMem_al|

; 353  : 
; 354  :         curSize = curHeader->size;
; 355  : 
; 356  :         /*
; 357  :          *  Determine the offset from the beginning to make sure
; 358  :          *  the alignment request is honored.
; 359  :          */
; 360  :         offset = (unsigned long)curHeader & (adjAlign - 1);

  00044	e0112000	 ands        r2, r1, r0
  00048	e590e004	 ldr         lr, [r0, #4]

; 361  :         if (offset) {
; 362  :             offset = adjAlign - offset;

  0004c	10462002	 subne       r2, r6, r2

; 363  :         }
; 364  : 
; 365  : #if 0
; 366  :         /* Internal Assert that offset is a multiple of HEAP_ALIGN */
; 367  :         Assert_isTrue(((offset & (HEAP_ALIGN - 1)) == 0), NULL);
; 368  : #endif
; 369  : 
; 370  :         /* big enough? */
; 371  :         if (curSize >= (adjSize + offset)) {

  00050	e0823005	 add         r3, r2, r5
  00054	e15e0003	 cmp         lr, r3
  00058	2a000007	 bcs         |$LN17@HeapMem_al|

; 439  :         }
; 440  :         else {
; 441  :             prevHeader = curHeader;
; 442  :             curHeader = curHeader->next;

  0005c	e5903000	 ldr         r3, [r0]
  00060	e1a04000	 mov         r4, r0
  00064	e1b00003	 movs        r0, r3
  00068	1afffff5	 bne         |$LL11@HeapMem_al|
  0006c		 |$LN10@HeapMem_al|

; 443  :         }
; 444  :     }
; 445  : 
; 446  :     return (NULL);

  0006c	e3a01000	 mov         r1, #0
  00070		 |$LN14@HeapMem_al|

; 447  : }

  00070	e1a00001	 mov         r0, r1
  00074	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$LN17@HeapMem_al|

; 372  : 
; 373  :             /* Set the pointer that will be returned. Alloc from front */
; 374  :             allocAddr = (char *)((unsigned long)curHeader + offset);

  0007c	e0801002	 add         r1, r0, r2

; 375  : 
; 376  :             if (dryrun) {

  00080	e3570000	 cmp         r7, #0

; 377  :                 return ((void *)allocAddr);

  00084	1afffff9	 bne         |$LN14@HeapMem_al|

; 378  :             }
; 379  : 
; 380  :             /*
; 381  :              *  Determine the remaining memory after the allocated block.
; 382  :              *  Note: this cannot be negative because of above comparison.
; 383  :              */
; 384  :             remainSize = curSize - adjSize - offset;

  00088	e04e3002	 sub         r3, lr, r2
  0008c	e043e005	 sub         lr, r3, r5

; 385  : 
; 386  : #if 0
; 387  :             /* Internal Assert that remainSize is a multiple of HEAP_ALIGN */
; 388  :             Assert_isTrue(((remainSize & (HEAP_ALIGN - 1)) == 0), NULL);
; 389  : #endif
; 390  : 
; 391  :             /*
; 392  :              *  If there is memory at the beginning (due to alignment
; 393  :              *  requirements), maintain it in the list.
; 394  :              *
; 395  :              *  offset and remainSize must be multiples of
; 396  :              *  HEAP_ALIGN. Therefore the address of the newHeader
; 397  :              *  below must be a multiple of the HEAP_ALIGN, thus
; 398  :              *  maintaining the requirement.
; 399  :              */
; 400  :             if (offset) {

  00090	e3520000	 cmp         r2, #0
  00094	0a000008	 beq         |$LN6@HeapMem_al|

; 401  : 
; 402  :                 /* Adjust the curHeader size accordingly */
; 403  :                 curHeader->size = offset;

  00098	e5802004	 str         r2, [r0, #4]

; 404  : 
; 405  :                 /*
; 406  :                  *  If there is remaining memory, add into the free list.
; 407  :                  *  Note: no need to coalesce and we have HeapMem locked so
; 408  :                  *        it is safe.
; 409  :                  */
; 410  :                 if (remainSize) {

  0009c	e35e0000	 cmp         lr, #0
  000a0	0afffff2	 beq         |$LN14@HeapMem_al|

; 411  :                     newHeader = (HeapMem_Header *)
; 412  :                         ((unsigned long)allocAddr + adjSize);
; 413  :                     newHeader->next = curHeader->next;

  000a4	e5903000	 ldr         r3, [r0]
  000a8	e1a02001	 mov         r2, r1
  000ac	e7a23005	 str         r3, [r2, +r5]!

; 414  :                     newHeader->size = remainSize;

  000b0	e582e004	 str         lr, [r2, #4]

; 415  :                     curHeader->next = newHeader;

  000b4	e5802000	 str         r2, [r0]

; 416  :                 }
; 417  :             }
; 418  :             else {

  000b8	eaffffec	 b           |$LN14@HeapMem_al|
  000bc		 |$LN6@HeapMem_al|

; 419  :                 /*
; 420  :                  *  If there is any remaining, link it in,
; 421  :                  *  else point to the next free block.
; 422  :                  *  Note: no need to coalesce and we have HeapMem locked so
; 423  :                  *        it is safe.
; 424  :                  */
; 425  :                 if (remainSize) {
; 426  :                     newHeader = (HeapMem_Header *)
; 427  :                         ((unsigned long)allocAddr + adjSize);
; 428  :                     newHeader->next  = curHeader->next;

  000bc	e5903000	 ldr         r3, [r0]
  000c0	e35e0000	 cmp         lr, #0
  000c4	11a02001	 movne       r2, r1
  000c8	17a23005	 strne       r3, [r2, +r5]!

; 429  :                     newHeader->size  = remainSize;

  000cc	1582e004	 strne       lr, [r2, #4]

; 430  :                     prevHeader->next = newHeader;

  000d0	15842000	 strne       r2, [r4]
  000d4	1affffe5	 bne         |$LN14@HeapMem_al|

; 431  :                 }
; 432  :                 else {
; 433  :                     prevHeader->next = curHeader->next;

  000d8	e5843000	 str         r3, [r4]

; 434  :                 }
; 435  :             }
; 436  : 
; 437  :             /* Success, return the allocated memory */
; 438  :             return ((void *)allocAddr);

  000dc	eaffffe3	 b           |$LN14@HeapMem_al|
  000e0		 |$LN21@HeapMem_al|
  000e0		 |$LN22@HeapMem_al|
  000e0	00000000	 DCD         |heap_head|
  000e4		 |$LN23@HeapMem_al|
  000e4	00000000	 DCD         |gdwPageSize|
  000e8		 |$M41095|

			 ENDP  ; |HeapMem_alloc|

	EXPORT	|HeapMem_free|

  00000			 AREA	 |.pdata|, PDATA
|$T41117| DCD	|$LN14@HeapMem_fr|
	DCD	0x40002d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HeapMem_free| PROC

; 453  : {

  00000		 |$LN14@HeapMem_fr|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M41114|

; 454  : //    long key;
; 455  :     HeapMem_Header *curHeader, *newHeader, *nextHeader;
; 456  :     size_t offset;
; 457  : 
; 458  :     /* obj->head never changes, doesn't need Gate protection. */
; 459  :     curHeader = &heap_head[bi];
; 460  : 
; 461  :     /* Restore size to actual allocated size */
; 462  :     if ((offset = size & (HEAP_ALIGN - 1)) != 0) {

  00004	e59f30a4	 ldr         r3, [pc, #0xA4]
  00008	e59fe09c	 ldr         lr, [pc, #0x9C]
  0000c	e5935000	 ldr         r5, [r3]
  00010	e08e4180	 add         r4, lr, r0, lsl #3
  00014	e1a0e004	 mov         lr, r4
  00018	e2453001	 sub         r3, r5, #1
  0001c	e0133002	 ands        r3, r3, r2

; 463  :         size += HEAP_ALIGN - offset;

  00020	10453003	 subne       r3, r5, r3
  00024	10822003	 addne       r2, r2, r3

; 464  :     }
; 465  : 
; 466  : /*
; 467  :  * We don't need to enter the "gate" since this function is called
; 468  :  * with it held already.
; 469  :  */
; 470  : //    key = Gate_enterModule();
; 471  : 
; 472  :     newHeader = (HeapMem_Header *)addr;
; 473  :     nextHeader = curHeader->next;

  00028	e5943000	 ldr         r3, [r4]
  0002c	ea000003	 b           |$LN11@HeapMem_fr|
  00030		 |$LL4@HeapMem_fr|

; 474  : 
; 475  :     /* Go down freelist and find right place for buf */
; 476  :     while (nextHeader != NULL && nextHeader < newHeader) {

  00030	e1500001	 cmp         r0, r1
  00034	2a000003	 bcs         |$LN10@HeapMem_fr|

; 477  :         curHeader = nextHeader;
; 478  :         nextHeader = nextHeader->next;

  00038	e5903000	 ldr         r3, [r0]
  0003c	e1a0e000	 mov         lr, r0
  00040		 |$LN11@HeapMem_fr|
  00040	e1b00003	 movs        r0, r3
  00044	1afffff9	 bne         |$LL4@HeapMem_fr|
  00048		 |$LN10@HeapMem_fr|

; 479  :     }
; 480  : 
; 481  :     newHeader->next = nextHeader;

  00048	e5810000	 str         r0, [r1]

; 482  :     newHeader->size = size;

  0004c	e5812004	 str         r2, [r1, #4]

; 483  :     curHeader->next = newHeader;

  00050	e58e1000	 str         r1, [lr]

; 484  : 
; 485  :     /* Join contiguous free blocks */
; 486  :     /* Join with upper block */
; 487  :     if ((nextHeader != NULL) &&
; 488  :             (((unsigned long)newHeader + size) == (unsigned long)nextHeader)) {

  00054	e3500000	 cmp         r0, #0
  00058	0a000007	 beq         |$LN2@HeapMem_fr|
  0005c	e0813002	 add         r3, r1, r2
  00060	e1530000	 cmp         r3, r0

; 489  :         newHeader->next = nextHeader->next;

  00064	05903000	 ldreq       r3, [r0]

; 490  :         newHeader->size += nextHeader->size;

  00068	05912004	 ldreq       r2, [r1, #4]
  0006c	05813000	 streq       r3, [r1]
  00070	05903004	 ldreq       r3, [r0, #4]
  00074	00833002	 addeq       r3, r3, r2
  00078	05813004	 streq       r3, [r1, #4]
  0007c		 |$LN2@HeapMem_fr|

; 491  :     }
; 492  : 
; 493  :     /*
; 494  :      *  Join with lower block. Make sure to check to see if not the
; 495  :      *  first block.
; 496  :      */
; 497  :     if ((curHeader != &heap_head[bi]) &&
; 498  :             (((unsigned long)curHeader + curHeader->size) ==
; 499  :                     (unsigned long)newHeader)) {

  0007c	e15e0004	 cmp         lr, r4
  00080	0a000007	 beq         |$LN1@HeapMem_fr|
  00084	e59e2004	 ldr         r2, [lr, #4]
  00088	e082300e	 add         r3, r2, lr
  0008c	e1530001	 cmp         r3, r1

; 500  :         curHeader->next = newHeader->next;

  00090	05913000	 ldreq       r3, [r1]
  00094	058e3000	 streq       r3, [lr]

; 501  :         curHeader->size += newHeader->size;

  00098	05913004	 ldreq       r3, [r1, #4]
  0009c	00833002	 addeq       r3, r3, r2
  000a0	058e3004	 streq       r3, [lr, #4]
  000a4		 |$LN1@HeapMem_fr|

; 502  :     }
; 503  : 
; 504  : /*
; 505  :  * See above comment on Gate_enterModule for an explanation of why we
; 506  :  * don't use the "gate".
; 507  :  */
; 508  : //    Gate_leaveModule(key);
; 509  : 
; 510  : }

  000a4	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$LN15@HeapMem_fr|
  000ac		 |$LN16@HeapMem_fr|
  000ac	00000000	 DCD         |heap_head|
  000b0		 |$LN17@HeapMem_fr|
  000b0	00000000	 DCD         |gdwPageSize|
  000b4		 |$M41115|

			 ENDP  ; |HeapMem_free|

	EXPORT	|??_C@_1GE@COLDEHO@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAg?$AAe?$AAt?$AA_?$AAp?$AAh?$AAy?$AAs?$AA?$CI?$AA?$CJ?$AA?3?$AA?5?$AAL?$AAo?$AAc?$AAk?$AAP?$AAa?$AAg@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|
	IMPORT	|LockPages|
	IMPORT	|__imp___rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T41139| DCD	|$LN15@get_phys|
	DCD	0x40003402

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GE@COLDEHO@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAg?$AAe?$AAt?$AA_?$AAp?$AAh?$AAy?$AAs?$AA?$CI?$AA?$CJ?$AA?3?$AA?5?$AAL?$AAo?$AAc?$AAk?$AAP?$AAa?$AAg@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "g", 0x0, "e", 0x0, "t", 0x0, "_", 0x0, "p", 0x0, "h"
	DCB	0x0, "y", 0x0, "s", 0x0, "(", 0x0, ")", 0x0, ":", 0x0, " "
	DCB	0x0, "L", 0x0, "o", 0x0, "c", 0x0, "k", 0x0, "P", 0x0, "a"
	DCB	0x0, "g", 0x0, "e", 0x0, "s", 0x0, "(", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "x", 0x0, ")", 0x0, " ", 0x0, "f", 0x0, "a"
	DCB	0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, "!", 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |get_phys| PROC

; 521  : {

  00000		 |$LN15@get_phys|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M41136|
  00008	e1a06000	 mov         r6, r0

; 522  :     unsigned long bufStart;
; 523  :     unsigned long offset;
; 524  :     unsigned long physp = 0;
; 525  :     DWORD         dwPFN[2];
; 526  :     int           bi;
; 527  :     BOOL          fRet;
; 528  : 
; 529  :     /* For CMEM block kernel addresses */
; 530  :     for (bi = 0; bi < NBLOCKS; bi++) {

  0000c	e59f10b8	 ldr         r1, [pc, #0xB8]
  00010	e3a05000	 mov         r5, #0
  00014	e3a02000	 mov         r2, #0
  00018	e2810010	 add         r0, r1, #0x10
  0001c		 |$LL6@get_phys|

; 531  :         if (virtp >= block_virtp[bi] && virtp < block_virtend[bi]) {

  0001c	e7913102	 ldr         r3, [r1, +r2, lsl #2]
  00020	e1560003	 cmp         r6, r3
  00024	3a000002	 bcc         |$LN5@get_phys|
  00028	e7903102	 ldr         r3, [r0, +r2, lsl #2]
  0002c	e1560003	 cmp         r6, r3
  00030	3a000019	 bcc         |$LN10@get_phys|
  00034		 |$LN5@get_phys|

; 522  :     unsigned long bufStart;
; 523  :     unsigned long offset;
; 524  :     unsigned long physp = 0;
; 525  :     DWORD         dwPFN[2];
; 526  :     int           bi;
; 527  :     BOOL          fRet;
; 528  : 
; 529  :     /* For CMEM block kernel addresses */
; 530  :     for (bi = 0; bi < NBLOCKS; bi++) {

  00034	e2822001	 add         r2, r2, #1
  00038	e3520002	 cmp         r2, #2
  0003c	bafffff6	 blt         |$LL6@get_phys|

; 536  :         }
; 537  :     }
; 538  : 
; 539  :     __D("get_phys(): Requested a VA to PA mapping for an address that CMEM did not allocate!\r\n");
; 540  :     __D(" Perhaps it's in the list of busy entries?\r\n");
; 541  : 
; 542  :     offset = virtp % PAGE_SIZE; /* Offset from the beginning of a page */

  00040	e59f3080	 ldr         r3, [pc, #0x80]
  00044	e3e02b0d	 mvn         r2, #0xD, 22
  00048	e22240fb	 eor         r4, r2, #0xFB
  0004c	e5940000	 ldr         r0, [r4]
  00050	e5933000	 ldr         r3, [r3]
  00054	e1a01006	 mov         r1, r6
  00058	e1a0e00f	 mov         lr, pc
  0005c	e12fff13	 bx          r3
  00060	e1a07001	 mov         r7, r1

; 543  :     bufStart = virtp - offset;
; 544  : 
; 545  :     /*
; 546  :      *  We will only query for one page, since we don't know the size of the
; 547  :      *  buffer we're doing the get_phys() for.
; 548  :      */
; 549  :     fRet = LockPages((LPVOID)bufStart, PAGE_SIZE, dwPFN, LOCKFLAG_QUERY_ONLY);

  00064	e5941000	 ldr         r1, [r4]
  00068	e1a0e000	 mov         lr, r0
  0006c	e3a03002	 mov         r3, #2
  00070	e28d2000	 add         r2, sp, #0
  00074	e0460007	 sub         r0, r6, r7
  00078	eb000000	 bl          LockPages
  0007c	e3500000	 cmp         r0, #0

; 550  :     if (fRet) {

  00080	0a000009	 beq         |$LN2@get_phys|
  00084	e3e03b0d	 mvn         r3, #0xD, 22

; 551  :         physp = (dwPFN[0] << UserKInfo[KINX_PFN_SHIFT]) + offset;

  00088	e22330f7	 eor         r3, r3, #0xF7
  0008c	e5932000	 ldr         r2, [r3]
  00090	e59d3000	 ldr         r3, [sp]
  00094	e0875213	 add         r5, r7, r3, lsl r2

; 552  : 
; 553  :         /* Don't call UnlockPages() since we only did a query */
; 554  :     }
; 555  :     else {

  00098	ea000005	 b           |$LN1@get_phys|
  0009c		 |$LN10@get_phys|

; 532  :             physp = virtp - block_virtoff[bi];
; 533  :             __D("get_phys: block_virtoff[%d] translated kernel %#lx to %#lx\n",
; 534  :                     bi, virtp, physp);
; 535  :             return (physp);

  0009c	e2813008	 add         r3, r1, #8
  000a0	e7933102	 ldr         r3, [r3, +r2, lsl #2]
  000a4	e0465003	 sub         r5, r6, r3
  000a8	ea000001	 b           |$LN1@get_phys|
  000ac		 |$LN2@get_phys|

; 556  :         __E("get_phys(): LockPages(0x%x) failed!\n");

  000ac	e59f0010	 ldr         r0, [pc, #0x10]
  000b0	eb000000	 bl          NKDbgPrintfW
  000b4		 |$LN1@get_phys|

; 557  :     }
; 558  : 
; 559  :     return (physp);
; 560  : }

  000b4	e1a00005	 mov         r0, r5
  000b8	e28dd008	 add         sp, sp, #8
  000bc	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$LN16@get_phys|
  000c4		 |$LN17@get_phys|
  000c4	00000000	 DCD         |??_C@_1GE@COLDEHO@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAg?$AAe?$AAt?$AA_?$AAp?$AAh?$AAy?$AAs?$AA?$CI?$AA?$CJ?$AA?3?$AA?5?$AAL?$AAo?$AAc?$AAk?$AAP?$AAa?$AAg@|
  000c8		 |$LN18@get_phys|
  000c8	00000000	 DCD         |__imp___rt_udiv|
  000cc		 |$LN19@get_phys|
  000cc	00000000	 DCD         |block_virtp|
  000d0		 |$M41137|

			 ENDP  ; |get_phys|

	EXPORT	|??_C@_1GK@INLGMAOE@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAf?$AAi?$AAn?$AAd?$AA?5?$AAa?$AA?5?$AAb?$AAi@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T41154| DCD	|$LN6@alloc_pool|
	DCD	0x40001301

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GK@INLGMAOE@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAf?$AAi?$AAn?$AAd?$AA?5?$AAa?$AA?5?$AAb?$AAi@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "f", 0x0, "i"
	DCB	0x0, "n", 0x0, "d", 0x0, " ", 0x0, "a", 0x0, " ", 0x0, "b"
	DCB	0x0, "i", 0x0, "g", 0x0, " ", 0x0, "e", 0x0, "n", 0x0, "o"
	DCB	0x0, "u", 0x0, "g", 0x0, "h", 0x0, " ", 0x0, "f", 0x0, "r"
	DCB	0x0, "e", 0x0, "e", 0x0, " ", 0x0, "b", 0x0, "l", 0x0, "o"
	DCB	0x0, "c", 0x0, "k", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |alloc_pool_buffer| PROC

; 564  : {

  00000		 |$LN6@alloc_pool|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41151|

; 565  :     unsigned long virtp;
; 566  : 
; 567  :     __D("alloc_pool_buffer: Called for size %u\n", size);
; 568  : 
; 569  :     if (size <= block_avail_size[bi]) {

  00004	e59f203c	 ldr         r2, [pc, #0x3C]
  00008	e1a0e100	 mov         lr, r0, lsl #2
  0000c	e2823028	 add         r3, r2, #0x28
  00010	e7be3003	 ldr         r3, [lr, +r3]!
  00014	e1510003	 cmp         r1, r3

; 570  :         __D("alloc_pool_buffer: Fits req %u < avail: %u\n",
; 571  :                 size, block_avail_size[bi]);
; 572  : 
; 573  :         block_avail_size[bi] -= size;
; 574  :         virtp = block_virtp[bi] + block_avail_size[bi];

  00018	97922100	 ldrls       r2, [r2, +r0, lsl #2]
  0001c	90433001	 subls       r3, r3, r1
  00020	958e3000	 strls       r3, [lr]
  00024	90820003	 addls       r0, r2, r3

; 586  : }

  00028	949de004	 ldrls       lr, [sp], #4
  0002c	912fff1e	 bxls        lr

; 575  : 
; 576  :         __D("alloc_pool_buffer: new available block size is %d\n",
; 577  :                 block_avail_size[bi]);
; 578  :         __D("alloc_pool_buffer: returning allocated buffer at %#lx\n", virtp);
; 579  : 
; 580  :         return virtp;
; 581  :     }
; 582  : 
; 583  :     __E("Failed to find a big enough free block\n");

  00030	e59f000c	 ldr         r0, [pc, #0xC]
  00034	eb000000	 bl          NKDbgPrintfW

; 584  : 
; 585  :     return 0;

  00038	e3a00000	 mov         r0, #0

; 586  : }

  0003c	e49de004	 ldr         lr, [sp], #4
  00040	e12fff1e	 bx          lr
  00044		 |$LN7@alloc_pool|
  00044		 |$LN8@alloc_pool|
  00044	00000000	 DCD         |??_C@_1GK@INLGMAOE@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAf?$AAi?$AAn?$AAd?$AA?5?$AAa?$AA?5?$AAb?$AAi@|
  00048		 |$LN9@alloc_pool|
  00048	00000000	 DCD         |block_virtp|
  0004c		 |$M41152|

			 ENDP  ; |alloc_pool_buffer|


  00000			 AREA	 |.pdata|, PDATA
|$T41186| DCD	|$LN30@find_busy_|
	DCD	0x40003701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |find_busy_entry| PROC

; 638  : {

  00000		 |$LN30@find_busy_|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M41183|
  00004	e1a06003	 mov         r6, r3
  00008	e1a07002	 mov         r7, r2
  0000c	e1a09001	 mov         r9, r1
  00010	e1a08000	 mov         r8, r0

; 639  :     LIST_ENTRY *busylistp;
; 640  :     LIST_ENTRY *e;
; 641  :     struct pool_buffer *entry;
; 642  :     unsigned long physAddr;
; 643  :     int num_pools;
; 644  :     int i;
; 645  :     int bi;
; 646  : 
; 647  : 
; 648  :     /* Convert virtual address to physical address */
; 649  :     physAddr = (bSearchByVA) ? get_phys(addr) : addr;

  00014	e59d0024	 ldr         r0, [sp, #0x24]
  00018	e3500000	 cmp         r0, #0
  0001c	0a000002	 beq         |$LN17@find_busy_|
  00020	e1a00008	 mov         r0, r8
  00024	eb000000	 bl          get_phys
  00028	e1a08000	 mov         r8, r0
  0002c		 |$LN17@find_busy_|

; 650  : 
; 651  :     for (bi = 0; bi < NBLOCKS; bi++) {

  0002c	e59f30a4	 ldr         r3, [pc, #0xA4]
  00030	e59fa09c	 ldr         r10, [pc, #0x9C]
  00034	e59fb094	 ldr         r11, [pc, #0x94]
  00038	e2835008	 add         r5, r3, #8
  0003c	e3a02000	 mov         r2, #0
  00040		 |$LL14@find_busy_|

; 652  :         num_pools = npools[bi];
; 653  :         if (heap_pool[bi] != -1) {

  00040	e79a3102	 ldr         r3, [r10, +r2, lsl #2]
  00044	e79b1102	 ldr         r1, [r11, +r2, lsl #2]

; 654  :             num_pools++;
; 655  :         }
; 656  : 
; 657  :         for (i = 0; i < num_pools; i++) {

  00048	e3a0e000	 mov         lr, #0
  0004c	e3730001	 cmn         r3, #1
  00050	12811001	 addne       r1, r1, #1
  00054	e3510000	 cmp         r1, #0
  00058	da00000c	 ble         |$LN13@find_busy_|
  0005c	e1a04005	 mov         r4, r5
  00060		 |$LL10@find_busy_|

; 658  :             busylistp = &p_objs[bi][i].busylist;
; 659  : 
; 660  :             for (e = busylistp->Flink; e != busylistp; e = e->Flink) {

  00060	e5940000	 ldr         r0, [r4]
  00064	ea000003	 b           |$LN27@find_busy_|
  00068		 |$LL7@find_busy_|

; 661  :                 entry = CONTAINING_RECORD(e, struct pool_buffer, element);
; 662  : 
; 663  :                 if (entry->physp == physAddr) {

  00068	e590300c	 ldr         r3, [r0, #0xC]
  0006c	e1530008	 cmp         r3, r8
  00070	0a00000d	 beq         |$LN22@find_busy_|
  00074	e5900000	 ldr         r0, [r0]
  00078		 |$LN27@find_busy_|
  00078	e1500004	 cmp         r0, r4
  0007c	1afffff9	 bne         |$LL7@find_busy_|
  00080	e28ee001	 add         lr, lr, #1
  00084	e15e0001	 cmp         lr, r1
  00088	e284401c	 add         r4, r4, #0x1C
  0008c	bafffff3	 blt         |$LL10@find_busy_|
  00090		 |$LN13@find_busy_|

; 650  : 
; 651  :     for (bi = 0; bi < NBLOCKS; bi++) {

  00090	e2822001	 add         r2, r2, #1
  00094	e3520002	 cmp         r2, #2
  00098	e2855c0e	 add         r5, r5, #0xE, 24
  0009c	baffffe7	 blt         |$LL14@find_busy_|

; 672  :                     }
; 673  : 
; 674  :                     return (entry);
; 675  :                 }
; 676  :             }
; 677  :         }
; 678  :     }
; 679  : 
; 680  :     return (NULL);

  000a0	e3a00000	 mov         r0, #0
  000a4		 |$LN15@find_busy_|

; 681  : }

  000a4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$LN22@find_busy_|

; 664  :                     if (poolp) {

  000ac	e3590000	 cmp         r9, #0

; 665  :                         *poolp = i;

  000b0	1589e000	 strne       lr, [r9]

; 666  :                     }
; 667  :                     if (ep) {

  000b4	e3570000	 cmp         r7, #0

; 668  :                         *ep = e;

  000b8	15870000	 strne       r0, [r7]

; 669  :                     }
; 670  :                     if (bip) {

  000bc	e3560000	 cmp         r6, #0
  000c0	0afffff7	 beq         |$LN15@find_busy_|

; 671  :                         *bip = bi;

  000c4	e5862000	 str         r2, [r6]

; 681  : }

  000c8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000cc	e12fff1e	 bx          lr
  000d0		 |$LN31@find_busy_|
  000d0		 |$LN32@find_busy_|
  000d0	00000000	 DCD         |npools|
  000d4		 |$LN33@find_busy_|
  000d4	00000000	 DCD         |heap_pool|
  000d8		 |$LN34@find_busy_|
  000d8	00000000	 DCD         |p_objs|
  000dc		 |$M41184|

			 ENDP  ; |find_busy_entry|

	EXPORT	|??_C@_1IE@GIHALDF@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AA_?$AAp?$AAo?$AAo?$AAl?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HI@PBFJDIDF@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AA_?$AAp?$AAo?$AAo?$AAl?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt@| [ DATA ] ; `string'
	IMPORT	|malloc|

  00000			 AREA	 |.pdata|, PDATA
|$T41222| DCD	|$LN22@alloc_pool@2|
	DCD	0x40005502

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IE@GIHALDF@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AA_?$AAp?$AAo?$AAo?$AAl?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "a", 0x0, "l", 0x0, "l", 0x0, "o", 0x0, "c", 0x0, "_"
	DCB	0x0, "p", 0x0, "o", 0x0, "o", 0x0, "l", 0x0, " ", 0x0, "f"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "g", 0x0, "e", 0x0, "t"
	DCB	0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n", 0x0, "t", 0x0, "i"
	DCB	0x0, "g", 0x0, "u", 0x0, "o", 0x0, "u", 0x0, "s", 0x0, " "
	DCB	0x0, "a", 0x0, "r", 0x0, "e", 0x0, "a", 0x0, " ", 0x0, "o"
	DCB	0x0, "f", 0x0, " ", 0x0, "s", 0x0, "i", 0x0, "z", 0x0, "e"
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HI@PBFJDIDF@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AA_?$AAp?$AAo?$AAo?$AAl?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "a", 0x0, "l", 0x0, "l", 0x0, "o", 0x0, "c", 0x0, "_"
	DCB	0x0, "p", 0x0, "o", 0x0, "o", 0x0, "l", 0x0, " ", 0x0, "f"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "m", 0x0, "a", 0x0, "l"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, " ", 0x0, "p", 0x0, "o"
	DCB	0x0, "o", 0x0, "l", 0x0, "_", 0x0, "b", 0x0, "u", 0x0, "f"
	DCB	0x0, "f", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "s", 0x0, "t"
	DCB	0x0, "r", 0x0, "u", 0x0, "c", 0x0, "t", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |alloc_pool| PROC

; 693  : {

  00000		 |$LN22@alloc_pool@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M41219|
  00008	e1a0a002	 mov         r10, r2
  0000c	e1a02000	 mov         r2, r0
  00010	e58d2000	 str         r2, [sp]
  00014	e58da004	 str         r10, [sp, #4]

; 694  :     struct pool_buffer *entry;
; 695  :     LIST_ENTRY *freelistp = &p_objs[bi][idx].freelist;
; 696  :     LIST_ENTRY *busylistp = &p_objs[bi][idx].busylist;
; 697  :     int size = PAGE_ALIGN(reqsize);

  00018	e59fe130	 ldr         lr, [pc, #0x130]
  0001c	e0811382	 add         r1, r1, r2, lsl #7
  00020	e59f6124	 ldr         r6, [pc, #0x124]
  00024	e59ee000	 ldr         lr, [lr]
  00028	e0615181	 rsb         r5, r1, r1, lsl #3
  0002c	e2864008	 add         r4, r6, #8
  00030	e08e1003	 add         r1, lr, r3
  00034	e2411001	 sub         r1, r1, #1
  00038	e24ee001	 sub         lr, lr, #1
  0003c	e1c1800e	 bic         r8, r1, lr

; 698  :     unsigned long virtp;
; 699  :     int i;
; 700  : 
; 701  :     __D("Allocating %d buffers of size %d (requested %d)\n",
; 702  :             num, size, reqsize);
; 703  : 
; 704  :     p_objs[bi][idx].reqsize = reqsize;

  00040	e0861105	 add         r1, r6, r5, lsl #2
  00044	e0869105	 add         r9, r6, r5, lsl #2

; 705  :     p_objs[bi][idx].numbufs = num;
; 706  :     p_objs[bi][idx].size = size;

  00048	e5818014	 str         r8, [r1, #0x14]
  0004c	e5813018	 str         r3, [r1, #0x18]
  00050	e581a010	 str         r10, [r1, #0x10]
  00054	e084e105	 add         lr, r4, r5, lsl #2

; 707  : 
; 708  :     InitializeListHead(freelistp);

  00058	e5899004	 str         r9, [r9, #4]
  0005c	e5899000	 str         r9, [r9]

; 709  :     InitializeListHead(busylistp);

  00060	e58ee004	 str         lr, [lr, #4]
  00064	e58ee000	 str         lr, [lr]

; 710  : 
; 711  :     for (i=0; i < num; i++) {

  00068	e3a07000	 mov         r7, #0
  0006c	e35a0000	 cmp         r10, #0
  00070	da000024	 ble         |$LN7@alloc_pool@2|
  00074	e59fa0cc	 ldr         r10, [pc, #0xCC]
  00078	e59d602c	 ldr         r6, [sp, #0x2C]
  0007c	e28ab028	 add         r11, r10, #0x28
  00080		 |$LL9@alloc_pool@2|

; 712  :         entry = (pool_buffer*)malloc(sizeof(struct pool_buffer));

  00080	e3a00024	 mov         r0, #0x24
  00084	eb000000	 bl          malloc
  00088	e1b04000	 movs        r4, r0

; 713  : 
; 714  :         if (!entry) {

  0008c	0a000026	 beq         |$LN16@alloc_pool@2|

; 718  :         }
; 719  : 
; 720  :         virtp = alloc_pool_buffer(bi, size);

  00090	e59d2000	 ldr         r2, [sp]
  00094	e1a01102	 mov         r1, r2, lsl #2
  00098	e7b1300b	 ldr         r3, [r1, +r11]!
  0009c	e1580003	 cmp         r8, r3
  000a0	979a2102	 ldrls       r2, [r10, +r2, lsl #2]
  000a4	90433008	 subls       r3, r3, r8
  000a8	95813000	 strls       r3, [r1]
  000ac	90825003	 addls       r5, r2, r3
  000b0	9a000002	 bls         |$LN13@alloc_pool@2|
  000b4	e59f0088	 ldr         r0, [pc, #0x88]
  000b8	eb000000	 bl          NKDbgPrintfW
  000bc	e3a05000	 mov         r5, #0
  000c0		 |$LN13@alloc_pool@2|

; 721  : 
; 722  :         if (virtp == 0) {

  000c0	e3550000	 cmp         r5, #0
  000c4	0a000013	 beq         |$LN17@alloc_pool@2|

; 724  :             //return -ENOMEM;
; 725  :             return -1;
; 726  :         }
; 727  : 
; 728  :         entry->id = i;
; 729  :         entry->physp = get_phys(virtp);

  000c8	e1a00005	 mov         r0, r5
  000cc	e5847008	 str         r7, [r4, #8]
  000d0	eb000000	 bl          get_phys

; 730  :         entry->kvirtp = virtp;
; 731  : 
; 732  :         if (virtpRet) {

  000d4	e3560000	 cmp         r6, #0
  000d8	e584000c	 str         r0, [r4, #0xC]
  000dc	e5845014	 str         r5, [r4, #0x14]

; 733  :             *virtpRet++ = virtp;

  000e0	14865004	 strne       r5, [r6], #4

; 734  :         }
; 735  : 
; 736  :         __D("Allocated buffer %d, virtual %#lx and physical %#lx and size %d\n",
; 737  :                 entry->id, virtp, entry->physp, size);
; 738  : 
; 739  :         //list_add_tail(&entry->element, freelistp);
; 740  :         InsertTailList(freelistp, &entry->element);

  000e4	e5993004	 ldr         r3, [r9, #4]
  000e8	e5849000	 str         r9, [r4]
  000ec	e2877001	 add         r7, r7, #1
  000f0	e5843004	 str         r3, [r4, #4]
  000f4	e5834000	 str         r4, [r3]
  000f8	e59d3004	 ldr         r3, [sp, #4]
  000fc	e5894004	 str         r4, [r9, #4]
  00100	e1570003	 cmp         r7, r3
  00104	baffffdd	 blt         |$LL9@alloc_pool@2|
  00108		 |$LN7@alloc_pool@2|

; 741  :     }
; 742  : 
; 743  : #ifdef __DEBUG
; 744  :     dump_lists(bi, idx);
; 745  : #endif
; 746  : 
; 747  :     return 0;

  00108	e3a00000	 mov         r0, #0
  0010c		 |$LN10@alloc_pool@2|

; 748  : }

  0010c	e28dd008	 add         sp, sp, #8
  00110	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00114	e12fff1e	 bx          lr
  00118		 |$LN17@alloc_pool@2|

; 723  :             __E("alloc_pool failed to get contiguous area of size %d\n", size);

  00118	e59f0020	 ldr         r0, [pc, #0x20]
  0011c	e1a01008	 mov         r1, r8
  00120	eb000000	 bl          NKDbgPrintfW
  00124	e3e00000	 mvn         r0, #0
  00128	eafffff7	 b           |$LN10@alloc_pool@2|
  0012c		 |$LN16@alloc_pool@2|

; 715  :             __E("alloc_pool failed to malloc pool_buffer struct");

  0012c	e59f0008	 ldr         r0, [pc, #8]
  00130	eb000000	 bl          NKDbgPrintfW

; 716  :             //return -ENOMEM;
; 717  :             return -1;

  00134	e3e00000	 mvn         r0, #0
  00138	eafffff3	 b           |$LN10@alloc_pool@2|
  0013c		 |$LN23@alloc_pool@2|
  0013c		 |$LN24@alloc_pool@2|
  0013c	00000000	 DCD         |??_C@_1HI@PBFJDIDF@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AA_?$AAp?$AAo?$AAo?$AAl?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt@|
  00140		 |$LN25@alloc_pool@2|
  00140	00000000	 DCD         |??_C@_1IE@GIHALDF@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AA_?$AAp?$AAo?$AAo?$AAl?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt@|
  00144		 |$LN26@alloc_pool@2|
  00144	00000000	 DCD         |??_C@_1GK@INLGMAOE@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAf?$AAi?$AAn?$AAd?$AA?5?$AAa?$AA?5?$AAb?$AAi@|
  00148		 |$LN27@alloc_pool@2|
  00148	00000000	 DCD         |block_virtp|
  0014c		 |$LN28@alloc_pool@2|
  0014c	00000000	 DCD         |p_objs|
  00150		 |$LN29@alloc_pool@2|
  00150	00000000	 DCD         |gdwPageSize|
  00154		 |$M41220|

			 ENDP  ; |alloc_pool|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|CMK_Init|
	EXPORT	|??_C@_1GA@EHIEFMCN@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AAh?$AAe?$AAa@| [ DATA ] ; `string'
	EXPORT	|??_C@_1IO@JOGLBBIA@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AAp?$AAo?$AAo@| [ DATA ] ; `string'
	EXPORT	|??_C@_1JI@POFHIEIK@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HK@PBGLKGFP@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CJ?$AA?3?$AA?5?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AAC?$AAc?$AAh?$AAP?$AAr@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BM@GDPAOOKP@?$AAP?$AAo?$AAo?$AAl?$AAS?$AAi?$AAz?$AAe?$AA_?$AAP?$AAo?$AAo?$AAl?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HO@CDBIOCIL@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CJ?$AA?3?$AA?5?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AAC?$AAc?$AAh?$AAP?$AAr@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CA@JCJOGNFE@?$AAN?$AAu?$AAm?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAs?$AA_?$AAP?$AAo?$AAo?$AAl?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1M@PICFELOA@?$AAB?$AAl?$AAo?$AAc?$AAk?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@DMMEGEFO@?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA_?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@DJKHEDFH@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA_?$AAM?$AAU?$AAT?$AAE?$AAX?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1JI@FJFCHAIK@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AAs?$AAp?$AAe?$AAc@| [ DATA ] ; `string'
	EXPORT	|??_C@_1JI@CGJLOLBJ@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AAs?$AAp?$AAe?$AAc@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DC@KFACKDPH@?$AAU?$AAs?$AAe?$AAH?$AAe?$AAa?$AAp?$AAI?$AAf?$AAP?$AAo?$AAo?$AAl?$AAU?$AAn?$AAa?$AAv?$AAa?$AAi?$AAl?$AAa?$AAb?$AAl?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@NOPHIHDE@?$AAN?$AAu?$AAm?$AAP?$AAo?$AAo?$AAl?$AAs?$AA1?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@GGELOAFB@?$AAN?$AAu?$AAm?$AAP?$AAo?$AAo?$AAl?$AAs?$AA0?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@EEHBOAGL@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAE?$AAn?$AAd?$AA1?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@PMMNIHAO@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAE?$AAn?$AAd?$AA0?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BO@ODBAMBIC@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAS?$AAt?$AAa?$AAr?$AAt?$AA1?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GG@BKOAGPDI@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?3?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BO@FLKMKGOH@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAS?$AAt?$AAa?$AAr?$AAt?$AA0?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FO@GGDGBKHC@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?3?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CM@BOKDKMGI@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|FreePhysMem|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|RegCloseKey|
	IMPORT	|StringCchPrintfW|
	IMPORT	|AllocPhysMem|
	IMPORT	|MmMapIoSpace|
	IMPORT	|GetSystemInfo|
	IMPORT	|CreateMutexW|
	IMPORT	|RegQueryValueExW|
	IMPORT	|RegOpenKeyExW|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|memset|
	IMPORT	|__security_check_cookie|

  0049c			 AREA	 |.bss|, NOINIT
|mappedBufferList| % 0x8
|mappedBufferList| % 0x8

  00000			 AREA	 |.pdata|, PDATA
|$T41271| DCD	|$LN62@CMK_Init|
	DCD	0xc001c602

  00000			 AREA	 |.xdata|, DATA
|$T41267| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GA@EHIEFMCN@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AAh?$AAe?$AAa@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "a", 0x0, "l"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, " ", 0x0, "h", 0x0, "e"
	DCB	0x0, "a", 0x0, "p", 0x0, " ", 0x0, "o", 0x0, "f", 0x0, " "
	DCB	0x0, "s", 0x0, "i", 0x0, "z", 0x0, "e", 0x0, " ", 0x0, "%"
	DCB	0x0, "#", 0x0, "l", 0x0, "x", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IO@JOGLBBIA@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AAp?$AAo?$AAo@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "a", 0x0, "l"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, " ", 0x0, "p", 0x0, "o"
	DCB	0x0, "o", 0x0, "l", 0x0, " ", 0x0, "o", 0x0, "f", 0x0, " "
	DCB	0x0, "s", 0x0, "i", 0x0, "z", 0x0, "e", 0x0, " ", 0x0, "%"
	DCB	0x0, "d", 0x0, " ", 0x0, "a", 0x0, "n", 0x0, "d", 0x0, " "
	DCB	0x0, "n", 0x0, "u", 0x0, "m", 0x0, "b", 0x0, "e", 0x0, "r"
	DCB	0x0, " ", 0x0, "o", 0x0, "f", 0x0, " ", 0x0, "b", 0x0, "u"
	DCB	0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, "s", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JI@POFHIEIK@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?5@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "a", 0x0, "l"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, "a", 0x0, "t", 0x0, "e"
	DCB	0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n", 0x0, "t", 0x0, "i"
	DCB	0x0, "g", 0x0, "u", 0x0, "o", 0x0, "u", 0x0, "s", 0x0, " "
	DCB	0x0, "m", 0x0, "e", 0x0, "m", 0x0, "o", 0x0, "r", 0x0, "y"
	DCB	0x0, " ", 0x0, "(", 0x0, "n", 0x0, "o", 0x0, "n", 0x0, "-"
	DCB	0x0, "c", 0x0, "a", 0x0, "c", 0x0, "h", 0x0, "e", 0x0, "d"
	DCB	0x0, ")", 0x0, " ", 0x0, "(", 0x0, "%", 0x0, "#", 0x0, "l"
	DCB	0x0, "x", 0x0, ",", 0x0, " ", 0x0, "%", 0x0, "l", 0x0, "d"
	DCB	0x0, ")", 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HK@PBGLKGFP@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CJ?$AA?3?$AA?5?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AAC?$AAc?$AAh?$AAP?$AAr@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "C", 0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " "
	DCB	0x0, "i", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "(", 0x0, ")"
	DCB	0x0, ":", 0x0, " ", 0x0, "S", 0x0, "t", 0x0, "r", 0x0, "i"
	DCB	0x0, "n", 0x0, "g", 0x0, "C", 0x0, "c", 0x0, "h", 0x0, "P"
	DCB	0x0, "r", 0x0, "i", 0x0, "n", 0x0, "t", 0x0, "f", 0x0, " "
	DCB	0x0, "(", 0x0, "P", 0x0, "O", 0x0, "O", 0x0, "L", 0x0, "_"
	DCB	0x0, "S", 0x0, "I", 0x0, "Z", 0x0, "E", 0x0, ")", 0x0, " "
	DCB	0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, "!", 0x0, "!", 0x0, "!", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@GDPAOOKP@?$AAP?$AAo?$AAo?$AAl?$AAS?$AAi?$AAz?$AAe?$AA_?$AAP?$AAo?$AAo?$AAl?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "o", 0x0, "l", 0x0, "S", 0x0, "i", 0x0, "z"
	DCB	0x0, "e", 0x0, "_", 0x0, "P", 0x0, "o", 0x0, "o", 0x0, "l"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HO@CDBIOCIL@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CJ?$AA?3?$AA?5?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AAC?$AAc?$AAh?$AAP?$AAr@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "C", 0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " "
	DCB	0x0, "i", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "(", 0x0, ")"
	DCB	0x0, ":", 0x0, " ", 0x0, "S", 0x0, "t", 0x0, "r", 0x0, "i"
	DCB	0x0, "n", 0x0, "g", 0x0, "C", 0x0, "c", 0x0, "h", 0x0, "P"
	DCB	0x0, "r", 0x0, "i", 0x0, "n", 0x0, "t", 0x0, "f", 0x0, " "
	DCB	0x0, "(", 0x0, "N", 0x0, "U", 0x0, "M", 0x0, "_", 0x0, "B"
	DCB	0x0, "U", 0x0, "F", 0x0, "F", 0x0, "E", 0x0, "R", 0x0, "S"
	DCB	0x0, ")", 0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l"
	DCB	0x0, "e", 0x0, "d", 0x0, "!", 0x0, "!", 0x0, "!", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@JCJOGNFE@?$AAN?$AAu?$AAm?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAs?$AA_?$AAP?$AAo?$AAo?$AAl?$AA?$AA@| DCB "N"
	DCB	0x0, "u", 0x0, "m", 0x0, "B", 0x0, "u", 0x0, "f", 0x0, "f"
	DCB	0x0, "e", 0x0, "r", 0x0, "s", 0x0, "_", 0x0, "P", 0x0, "o"
	DCB	0x0, "o", 0x0, "l", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1M@PICFELOA@?$AAB?$AAl?$AAo?$AAc?$AAk?$AA?$AA@| DCB "B", 0x0, "l", 0x0
	DCB	"o", 0x0, "c", 0x0, "k", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@DMMEGEFO@?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA_?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@| DCB "%"
	DCB	0x0, "s", 0x0, "%", 0x0, "d", 0x0, "_", 0x0, "%", 0x0, "s"
	DCB	0x0, "%", 0x0, "d", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@DJKHEDFH@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA_?$AAM?$AAU?$AAT?$AAE?$AAX?$AA?$AA@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, "_", 0x0, "M"
	DCB	0x0, "U", 0x0, "T", 0x0, "E", 0x0, "X", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JI@FJFCHAIK@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AAs?$AAp?$AAe?$AAc@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "T", 0x0, "o", 0x0, "o", 0x0, " ", 0x0, "m", 0x0, "a"
	DCB	0x0, "n", 0x0, "y", 0x0, " ", 0x0, "p", 0x0, "o", 0x0, "o"
	DCB	0x0, "l", 0x0, "s", 0x0, " ", 0x0, "s", 0x0, "p", 0x0, "e"
	DCB	0x0, "c", 0x0, "i", 0x0, "f", 0x0, "i", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "(", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, " "
	DCB	0x0, "f", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "B", 0x0, "l"
	DCB	0x0, "o", 0x0, "c", 0x0, "k", 0x0, " ", 0x0, "1", 0x0, ","
	DCB	0x0, " ", 0x0, "o", 0x0, "n", 0x0, "l", 0x0, "y", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, " ", 0x0, "s", 0x0, "u", 0x0, "p"
	DCB	0x0, "p", 0x0, "o", 0x0, "r", 0x0, "t", 0x0, "e", 0x0, "d"
	DCB	0x0, ".", 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JI@CGJLOLBJ@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AAs?$AAp?$AAe?$AAc@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "T", 0x0, "o", 0x0, "o", 0x0, " ", 0x0, "m", 0x0, "a"
	DCB	0x0, "n", 0x0, "y", 0x0, " ", 0x0, "p", 0x0, "o", 0x0, "o"
	DCB	0x0, "l", 0x0, "s", 0x0, " ", 0x0, "s", 0x0, "p", 0x0, "e"
	DCB	0x0, "c", 0x0, "i", 0x0, "f", 0x0, "i", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "(", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, " "
	DCB	0x0, "f", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "B", 0x0, "l"
	DCB	0x0, "o", 0x0, "c", 0x0, "k", 0x0, " ", 0x0, "0", 0x0, ","
	DCB	0x0, " ", 0x0, "o", 0x0, "n", 0x0, "l", 0x0, "y", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, " ", 0x0, "s", 0x0, "u", 0x0, "p"
	DCB	0x0, "p", 0x0, "o", 0x0, "r", 0x0, "t", 0x0, "e", 0x0, "d"
	DCB	0x0, ".", 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@KFACKDPH@?$AAU?$AAs?$AAe?$AAH?$AAe?$AAa?$AAp?$AAI?$AAf?$AAP?$AAo?$AAo?$AAl?$AAU?$AAn?$AAa?$AAv?$AAa?$AAi?$AAl?$AAa?$AAb?$AAl?$AAe?$AA?$AA@| DCB "U"
	DCB	0x0, "s", 0x0, "e", 0x0, "H", 0x0, "e", 0x0, "a", 0x0, "p"
	DCB	0x0, "I", 0x0, "f", 0x0, "P", 0x0, "o", 0x0, "o", 0x0, "l"
	DCB	0x0, "U", 0x0, "n", 0x0, "a", 0x0, "v", 0x0, "a", 0x0, "i"
	DCB	0x0, "l", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@NOPHIHDE@?$AAN?$AAu?$AAm?$AAP?$AAo?$AAo?$AAl?$AAs?$AA1?$AA?$AA@| DCB "N"
	DCB	0x0, "u", 0x0, "m", 0x0, "P", 0x0, "o", 0x0, "o", 0x0, "l"
	DCB	0x0, "s", 0x0, "1", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@GGELOAFB@?$AAN?$AAu?$AAm?$AAP?$AAo?$AAo?$AAl?$AAs?$AA0?$AA?$AA@| DCB "N"
	DCB	0x0, "u", 0x0, "m", 0x0, "P", 0x0, "o", 0x0, "o", 0x0, "l"
	DCB	0x0, "s", 0x0, "0", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@EEHBOAGL@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAE?$AAn?$AAd?$AA1?$AA?$AA@| DCB "P"
	DCB	0x0, "h", 0x0, "y", 0x0, "s", 0x0, "i", 0x0, "c", 0x0, "a"
	DCB	0x0, "l", 0x0, "E", 0x0, "n", 0x0, "d", 0x0, "1", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@PMMNIHAO@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAE?$AAn?$AAd?$AA0?$AA?$AA@| DCB "P"
	DCB	0x0, "h", 0x0, "y", 0x0, "s", 0x0, "i", 0x0, "c", 0x0, "a"
	DCB	0x0, "l", 0x0, "E", 0x0, "n", 0x0, "d", 0x0, "0", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BO@ODBAMBIC@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAS?$AAt?$AAa?$AAr?$AAt?$AA1?$AA?$AA@| DCB "P"
	DCB	0x0, "h", 0x0, "y", 0x0, "s", 0x0, "i", 0x0, "c", 0x0, "a"
	DCB	0x0, "l", 0x0, "S", 0x0, "t", 0x0, "a", 0x0, "r", 0x0, "t"
	DCB	0x0, "1", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GG@BKOAGPDI@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?3?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "C", 0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, ":"
	DCB	0x0, " ", 0x0, "c", 0x0, "a", 0x0, "n", 0x0, "n", 0x0, "o"
	DCB	0x0, "t", 0x0, " ", 0x0, "o", 0x0, "p", 0x0, "e", 0x0, "n"
	DCB	0x0, " ", 0x0, "r", 0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s"
	DCB	0x0, "t", 0x0, "r", 0x0, "y", 0x0, " ", 0x0, "k", 0x0, "e"
	DCB	0x0, "y", 0x0, ":", 0x0, " ", 0x0, "%", 0x0, "s", 0x0, "!"
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BO@FLKMKGOH@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAS?$AAt?$AAa?$AAr?$AAt?$AA0?$AA?$AA@| DCB "P"
	DCB	0x0, "h", 0x0, "y", 0x0, "s", 0x0, "i", 0x0, "c", 0x0, "a"
	DCB	0x0, "l", 0x0, "S", 0x0, "t", 0x0, "a", 0x0, "r", 0x0, "t"
	DCB	0x0, "0", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FO@GGDGBKHC@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?3?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "C", 0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, ":"
	DCB	0x0, " ", 0x0, "c", 0x0, "a", 0x0, "n", 0x0, "n", 0x0, "o"
	DCB	0x0, "t", 0x0, " ", 0x0, "o", 0x0, "p", 0x0, "e", 0x0, "n"
	DCB	0x0, " ", 0x0, "r", 0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s"
	DCB	0x0, "t", 0x0, "r", 0x0, "y", 0x0, " ", 0x0, "k", 0x0, "e"
	DCB	0x0, "y", 0x0, "!", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CM@BOKDKMGI@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?$AA@| DCB "D"
	DCB	0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, "s"
	DCB	0x0, "\\", 0x0, "B", 0x0, "u", 0x0, "i", 0x0, "l", 0x0, "t"
	DCB	0x0, "I", 0x0, "n", 0x0, "\\", 0x0, "C", 0x0, "M", 0x0, "E"
	DCB	0x0, "M", 0x0, "K", 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T41267|

  00008		 |CMK_Init| PROC

; 763  : {

  00008		 |$LN62@CMK_Init|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24ddf92	 sub         sp, sp, #0x92, 30
  00010		 |$M41268|
  00010	e59f3704	 ldr         r3, [pc, #0x704]
  00014	e5933000	 ldr         r3, [r3]
  00018	e58d3244	 str         r3, [sp, #0x244]

; 764  :     int bi;
; 765  :     int i;
; 766  :     int err;
; 767  :     int pool_size;
; 768  :     int pool_num_buffers;
; 769  :     unsigned long length;
; 770  :     HeapMem_Header *header;
; 771  :     SYSTEM_INFO systemInfo;
; 772  :     HKEY hKey;
; 773  :     DWORD dwDataSize;
; 774  : 
; 775  : //    __D("** CMEM kernel module built: " __DATE__ " " __TIME__ "\n" );
; 776  : //    DebugBreak();
; 777  : 
; 778  :     if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, CMEMK_REG_KEY, 0, 0, &hKey) !=
; 779  :             ERROR_SUCCESS) {

  0001c	e59f16f4	 ldr         r1, [pc, #0x6F4]
  00020	e28de010	 add         lr, sp, #0x10
  00024	e3a03000	 mov         r3, #0
  00028	e3a02000	 mov         r2, #0
  0002c	e3a0010a	 mov         r0, #0xA, 2
  00030	e58de000	 str         lr, [sp]
  00034	eb000000	 bl          RegOpenKeyExW
  00038	e3500000	 cmp         r0, #0
  0003c	0a000002	 beq         |$LN37@CMK_Init|

; 780  :         __E("CMEMK: cannot open registry key!\n");

  00040	e59f06cc	 ldr         r0, [pc, #0x6CC]
  00044	eb000000	 bl          NKDbgPrintfW

; 781  :         return 0;

  00048	ea00018e	 b           |$LN55@CMK_Init|
  0004c		 |$LN37@CMK_Init|

; 782  :     }
; 783  : 
; 784  :     dwDataSize = sizeof(block_start[0]);
; 785  :     if (RegQueryValueEx(hKey, CMEMK_REG_KEY_PHYSICAL_START_0, NULL, NULL,
; 786  :                 (LPBYTE)&block_start[0], &dwDataSize) != ERROR_SUCCESS) {

  0004c	e59f56bc	 ldr         r5, [pc, #0x6BC]
  00050	e59d0010	 ldr         r0, [sp, #0x10]
  00054	e59f16b0	 ldr         r1, [pc, #0x6B0]
  00058	e2853030	 add         r3, r5, #0x30
  0005c	e58d3000	 str         r3, [sp]
  00060	e3a04004	 mov         r4, #4
  00064	e28de00c	 add         lr, sp, #0xC
  00068	e3a03000	 mov         r3, #0
  0006c	e3a02000	 mov         r2, #0
  00070	e58d400c	 str         r4, [sp, #0xC]
  00074	e58de004	 str         lr, [sp, #4]
  00078	eb000000	 bl          RegQueryValueExW
  0007c	e3500000	 cmp         r0, #0
  00080	0a000004	 beq         |$LN36@CMK_Init|

; 787  :         __E("CMEMK: cannot open registry key: %s!\n",
; 788  :                 CMEMK_REG_KEY_PHYSICAL_START_0);

  00084	e59f1680	 ldr         r1, [pc, #0x680]
  00088	e59f0634	 ldr         r0, [pc, #0x634]
  0008c	eb000000	 bl          NKDbgPrintfW

; 789  :         block_start[0] = 0;

  00090	e3a03000	 mov         r3, #0
  00094	e5853030	 str         r3, [r5, #0x30]
  00098		 |$LN36@CMK_Init|

; 790  :     }
; 791  : 
; 792  :     dwDataSize = sizeof(block_start[1]);
; 793  :     if (RegQueryValueEx(hKey, CMEMK_REG_KEY_PHYSICAL_START_1, NULL, NULL,
; 794  :                 (LPBYTE)&block_start[1], &dwDataSize) != ERROR_SUCCESS) {

  00098	e59d0010	 ldr         r0, [sp, #0x10]
  0009c	e59f1664	 ldr         r1, [pc, #0x664]
  000a0	e2853030	 add         r3, r5, #0x30
  000a4	e2834004	 add         r4, r3, #4
  000a8	e3a06004	 mov         r6, #4
  000ac	e28de00c	 add         lr, sp, #0xC
  000b0	e3a03000	 mov         r3, #0
  000b4	e3a02000	 mov         r2, #0
  000b8	e58d4000	 str         r4, [sp]
  000bc	e58d600c	 str         r6, [sp, #0xC]
  000c0	e58de004	 str         lr, [sp, #4]
  000c4	eb000000	 bl          RegQueryValueExW
  000c8	e3500000	 cmp         r0, #0
  000cc	0a000004	 beq         |$LN35@CMK_Init|

; 795  :         __E("CMEMK: cannot open registry key: %s!\n",
; 796  :                 CMEMK_REG_KEY_PHYSICAL_START_1);

  000d0	e59f1630	 ldr         r1, [pc, #0x630]
  000d4	e59f05e8	 ldr         r0, [pc, #0x5E8]
  000d8	eb000000	 bl          NKDbgPrintfW

; 797  :         block_start[1] = 0;

  000dc	e3a03000	 mov         r3, #0
  000e0	e5853034	 str         r3, [r5, #0x34]
  000e4		 |$LN35@CMK_Init|

; 798  :     }
; 799  : 
; 800  :     dwDataSize = sizeof(block_end[0]);
; 801  :     if (RegQueryValueEx(hKey, CMEMK_REG_KEY_PHYSICAL_END_0, NULL, NULL,
; 802  :                 (LPBYTE)&block_end[0], &dwDataSize) != ERROR_SUCCESS) {

  000e4	e59d0010	 ldr         r0, [sp, #0x10]
  000e8	e59f1614	 ldr         r1, [pc, #0x614]
  000ec	e3a06004	 mov         r6, #4
  000f0	e28de00c	 add         lr, sp, #0xC
  000f4	e2854038	 add         r4, r5, #0x38
  000f8	e3a03000	 mov         r3, #0
  000fc	e3a02000	 mov         r2, #0
  00100	e58d600c	 str         r6, [sp, #0xC]
  00104	e58de004	 str         lr, [sp, #4]
  00108	e58d4000	 str         r4, [sp]
  0010c	eb000000	 bl          RegQueryValueExW
  00110	e3500000	 cmp         r0, #0
  00114	0a000004	 beq         |$LN34@CMK_Init|

; 803  :         __E("CMEMK: cannot open registry key: %s!\n",
; 804  :                 CMEMK_REG_KEY_PHYSICAL_END_0);

  00118	e59f15e4	 ldr         r1, [pc, #0x5E4]
  0011c	e59f05a0	 ldr         r0, [pc, #0x5A0]
  00120	eb000000	 bl          NKDbgPrintfW

; 805  :         block_end[0] = 0;

  00124	e3a03000	 mov         r3, #0
  00128	e5853038	 str         r3, [r5, #0x38]
  0012c		 |$LN34@CMK_Init|

; 806  :     }
; 807  : 
; 808  :     dwDataSize = sizeof(block_end[1]);
; 809  :     if (RegQueryValueEx(hKey, CMEMK_REG_KEY_PHYSICAL_END_1, NULL, NULL,
; 810  :                 (LPBYTE)&block_end[1], &dwDataSize) != ERROR_SUCCESS) {

  0012c	e59d0010	 ldr         r0, [sp, #0x10]
  00130	e59f15c8	 ldr         r1, [pc, #0x5C8]
  00134	e2853038	 add         r3, r5, #0x38
  00138	e2834004	 add         r4, r3, #4
  0013c	e3a06004	 mov         r6, #4
  00140	e28de00c	 add         lr, sp, #0xC
  00144	e3a03000	 mov         r3, #0
  00148	e3a02000	 mov         r2, #0
  0014c	e58d4000	 str         r4, [sp]
  00150	e58d600c	 str         r6, [sp, #0xC]
  00154	e58de004	 str         lr, [sp, #4]
  00158	eb000000	 bl          RegQueryValueExW
  0015c	e3500000	 cmp         r0, #0
  00160	0a000004	 beq         |$LN33@CMK_Init|

; 811  :         __E("CMEMK: cannot open registry key: %s!\n",
; 812  :                 CMEMK_REG_KEY_PHYSICAL_END_1);

  00164	e59f1594	 ldr         r1, [pc, #0x594]
  00168	e59f0554	 ldr         r0, [pc, #0x554]
  0016c	eb000000	 bl          NKDbgPrintfW

; 813  :         block_end[1] = 0;

  00170	e3a03000	 mov         r3, #0
  00174	e585303c	 str         r3, [r5, #0x3C]
  00178		 |$LN33@CMK_Init|

; 814  :     }
; 815  : 
; 816  : 
; 817  :     dwDataSize = sizeof(npools[0]);
; 818  :     if (RegQueryValueEx(hKey, CMEMK_REG_KEY_NUM_POOLS_0, NULL, NULL,
; 819  :                 (LPBYTE)&npools[0], &dwDataSize) != ERROR_SUCCESS) {

  00178	e59d0010	 ldr         r0, [sp, #0x10]
  0017c	e59f1578	 ldr         r1, [pc, #0x578]
  00180	e3a06004	 mov         r6, #4
  00184	e28de00c	 add         lr, sp, #0xC
  00188	e2854068	 add         r4, r5, #0x68
  0018c	e3a03000	 mov         r3, #0
  00190	e3a02000	 mov         r2, #0
  00194	e58d600c	 str         r6, [sp, #0xC]
  00198	e58de004	 str         lr, [sp, #4]
  0019c	e58d4000	 str         r4, [sp]
  001a0	eb000000	 bl          RegQueryValueExW
  001a4	e3500000	 cmp         r0, #0
  001a8	0a000004	 beq         |$LN32@CMK_Init|

; 820  :         __E("CMEMK: cannot open registry key: %s!\n",
; 821  :                 CMEMK_REG_KEY_NUM_POOLS_0);

  001ac	e59f1548	 ldr         r1, [pc, #0x548]
  001b0	e59f050c	 ldr         r0, [pc, #0x50C]
  001b4	eb000000	 bl          NKDbgPrintfW

; 822  :         npools[0] = 0;

  001b8	e3a03000	 mov         r3, #0
  001bc	e5853068	 str         r3, [r5, #0x68]
  001c0		 |$LN32@CMK_Init|

; 823  :     }
; 824  : 
; 825  :     dwDataSize = sizeof(npools[1]);
; 826  :     if (RegQueryValueEx(hKey, CMEMK_REG_KEY_NUM_POOLS_1, NULL, NULL,
; 827  :                 (LPBYTE)&npools[1], &dwDataSize) != ERROR_SUCCESS) {

  001c0	e59d0010	 ldr         r0, [sp, #0x10]
  001c4	e59f152c	 ldr         r1, [pc, #0x52C]
  001c8	e2853068	 add         r3, r5, #0x68
  001cc	e2834004	 add         r4, r3, #4
  001d0	e3a06004	 mov         r6, #4
  001d4	e28de00c	 add         lr, sp, #0xC
  001d8	e3a03000	 mov         r3, #0
  001dc	e3a02000	 mov         r2, #0
  001e0	e58d4000	 str         r4, [sp]
  001e4	e58d600c	 str         r6, [sp, #0xC]
  001e8	e58de004	 str         lr, [sp, #4]
  001ec	eb000000	 bl          RegQueryValueExW
  001f0	e3500000	 cmp         r0, #0
  001f4	0a000004	 beq         |$LN31@CMK_Init|

; 828  :         __E("CMEMK: cannot open registry key: %s!\n",
; 829  :                 CMEMK_REG_KEY_NUM_POOLS_1);

  001f8	e59f14f8	 ldr         r1, [pc, #0x4F8]
  001fc	e59f04c0	 ldr         r0, [pc, #0x4C0]
  00200	eb000000	 bl          NKDbgPrintfW

; 830  :         npools[1] = 0;

  00204	e3a03000	 mov         r3, #0
  00208	e585306c	 str         r3, [r5, #0x6C]
  0020c		 |$LN31@CMK_Init|

; 831  :     }
; 832  : 
; 833  :     dwDataSize = sizeof(useHeapIfPoolUnavailable);
; 834  :     if (RegQueryValueEx(hKey, CMEMK_REG_KEY_USE_HEAP, NULL, NULL,
; 835  :                 (LPBYTE)&useHeapIfPoolUnavailable,
; 836  :                 &dwDataSize) != ERROR_SUCCESS) {

  0020c	e59f44e0	 ldr         r4, [pc, #0x4E0]
  00210	e59f14d8	 ldr         r1, [pc, #0x4D8]
  00214	e59d0010	 ldr         r0, [sp, #0x10]
  00218	e3a06004	 mov         r6, #4
  0021c	e28de00c	 add         lr, sp, #0xC
  00220	e3a03000	 mov         r3, #0
  00224	e3a02000	 mov         r2, #0
  00228	e58d4000	 str         r4, [sp]
  0022c	e58d600c	 str         r6, [sp, #0xC]
  00230	e58de004	 str         lr, [sp, #4]
  00234	eb000000	 bl          RegQueryValueExW

; 837  :         __D("CMEMK: Warning: Cannot open registry key: %s\n",
; 838  :                 CMEMK_REG_KEY_USE_HEAP);
; 839  :         useHeapIfPoolUnavailable = 0;
; 840  :     }
; 841  : 
; 842  :     if (npools[0] > MAX_POOLS) {

  00238	e5951068	 ldr         r1, [r5, #0x68]
  0023c	e3500000	 cmp         r0, #0
  00240	13a03000	 movne       r3, #0
  00244	15843000	 strne       r3, [r4]
  00248	e3510080	 cmp         r1, #0x80

; 843  :         __E("Too many pools specified (%d) for Block 0, only %d supported.\n",
; 844  :                 npools[0], MAX_POOLS);

  0024c	c59f0498	 ldrgt       r0, [pc, #0x498]
  00250	c3a02080	 movgt       r2, #0x80
  00254	ca000108	 bgt         |$LN56@CMK_Init|

; 845  :         goto fail_after_create;
; 846  :     }
; 847  : 
; 848  : /* cut-and-paste below as part of adding support for more than 2 blocks */
; 849  :     if (npools[1] > MAX_POOLS) {

  00258	e595106c	 ldr         r1, [r5, #0x6C]
  0025c	e3510080	 cmp         r1, #0x80

; 850  :         __E("Too many pools specified (%d) for Block 1, only %d supported.\n",
; 851  :                 npools[1], MAX_POOLS);

  00260	c59f0480	 ldrgt       r0, [pc, #0x480]
  00264	c3a02080	 movgt       r2, #0x80
  00268	ca000103	 bgt         |$LN56@CMK_Init|

; 852  :         goto fail_after_create;
; 853  :     }
; 854  : 
; 855  : /* cut-and-paste above as part of adding support for more than 2 blocks */
; 856  : 
; 857  :     cmem_mutex = CreateMutex(NULL, FALSE, CMEMK_MUTEX_NAME);

  0026c	e59f2470	 ldr         r2, [pc, #0x470]
  00270	e3a01000	 mov         r1, #0
  00274	e3a00000	 mov         r0, #0
  00278	eb000000	 bl          CreateMutexW
  0027c	e1a03000	 mov         r3, r0

; 858  : 
; 859  :     GetSystemInfo(&systemInfo);

  00280	e28d0020	 add         r0, sp, #0x20
  00284	e5853480	 str         r3, [r5, #0x480]
  00288	eb000000	 bl          GetSystemInfo

; 860  :     gdwPageSize = systemInfo.dwPageSize;

  0028c	e59f842c	 ldr         r8, [pc, #0x42C]
  00290	e59d0024	 ldr         r0, [sp, #0x24]

; 861  : 
; 862  : /* cut-and-paste above as part of adding support for more than 2 blocks */
; 863  : 
; 864  :     for (bi = 0; bi < NBLOCKS; bi++) {

  00294	e59fa444	 ldr         r10, [pc, #0x444]
  00298	e3a06000	 mov         r6, #0
  0029c	e5880000	 str         r0, [r8]
  002a0		 |$LN58@CMK_Init|
  002a0	e2854018	 add         r4, r5, #0x18
  002a4	e285e040	 add         lr, r5, #0x40
  002a8	e2851038	 add         r1, r5, #0x38
  002ac	e2852030	 add         r2, r5, #0x30

; 865  : 
; 866  : /* cut-and-paste below as part of adding support for more than 2 blocks */
; 867  :         if (bi == 1 && (!block_start[1] || !block_end[1])) {

  002b0	e3560001	 cmp         r6, #1
  002b4	1a000005	 bne         |$LN24@CMK_Init|
  002b8	e5953034	 ldr         r3, [r5, #0x34]
  002bc	e3530000	 cmp         r3, #0
  002c0	0a0000c4	 beq         |$LN53@CMK_Init|
  002c4	e595303c	 ldr         r3, [r5, #0x3C]
  002c8	e3530000	 cmp         r3, #0
  002cc	0a0000c1	 beq         |$LN53@CMK_Init|
  002d0		 |$LN24@CMK_Init|

; 868  :             break;
; 869  :         }
; 870  : 
; 871  : /* cut-and-paste above as part of adding support for more than 2 blocks */
; 872  : 
; 873  :         /* Get the start and end of CMEM memory */
; 874  :         block_start[bi] = PAGE_ALIGN(block_start[bi]);

  002d0	e1a09106	 mov         r9, r6, lsl #2

; 875  :         block_end[bi] = PAGE_ALIGN(block_end[bi]);

  002d4	e7b93002	 ldr         r3, [r9, +r2]!
  002d8	e1a08106	 mov         r8, r6, lsl #2
  002dc	e7b82001	 ldr         r2, [r8, +r1]!
  002e0	e2401001	 sub         r1, r0, #1
  002e4	e0833000	 add         r3, r3, r0
  002e8	e2433001	 sub         r3, r3, #1
  002ec	e0822000	 add         r2, r2, r0
  002f0	e2422001	 sub         r2, r2, #1
  002f4	e1d30001	 bics        r0, r3, r1
  002f8	e1c23001	 bic         r3, r2, r1

; 876  :         length = block_end[bi] - block_start[bi];

  002fc	e0437000	 sub         r7, r3, r0

; 877  : 
; 878  :         if (length < 0) {
; 879  :             __E("Negative length of physical memory (%ld)\n", length);
; 880  :             err = 0;
; 881  :             goto fail_after_create;
; 882  :         }
; 883  : 
; 884  :         block_avail_size[bi] = length;

  00300	e1a0b106	 mov         r11, r6, lsl #2

; 885  :         numBlocks = bi + 1;

  00304	e2862001	 add         r2, r6, #1
  00308	e7ab700e	 str         r7, [r11, +lr]!
  0030c	e58d201c	 str         r2, [sp, #0x1C]
  00310	e5890000	 str         r0, [r9]
  00314	e5883000	 str         r3, [r8]
  00318	e585205c	 str         r2, [r5, #0x5C]

; 886  : 
; 887  :         // TODO: Can't do this in WINCE....figure out some other way!
; 888  :         /* attempt to determine the end of Linux kernel memory */
; 889  :         //phys_end_kernel = virt_to_phys((void *)PAGE_OFFSET) +
; 890  :         //  (num_physpages << PAGE_SHIFT);
; 891  : 
; 892  :         //if (phys_end_kernel > block_start[bi])
; 893  :         //{
; 894  :         //  if (allowOverlap == 0)
; 895  :         //  {
; 896  :         //      __E("CMEM phys_start (%#lx) overlaps kernel (%#lx -> %#lx)\n",
; 897  :         //          block_start[bi], virt_to_phys((void *)PAGE_OFFSET), phys_end_kernel);
; 898  :         //      err = 0;
; 899  :         //      goto fail_after_create;
; 900  :         //  }
; 901  :         //  else
; 902  :         //  {
; 903  :         //      printk("CMEM Range Overlaps Kernel Physical - allowing overlap\n");
; 904  :         //      printk("CMEM phys_start (%#lx) overlaps kernel (%#lx -> %#lx)\n",
; 905  :         //          block_start[bi], virt_to_phys((void *)PAGE_OFFSET), phys_end_kernel);
; 906  :         //  }
; 907  :         //}
; 908  : 
; 909  :         /* Initialize the top memory chunk in which to put the pools */
; 910  :         //#ifdef NOCACHE
; 911  :         //    block_virtp[bi] = (unsigned long) ioremap_nocache(block_start[bi], length);
; 912  :         //#else
; 913  :         //    block_virtp[bi] = (unsigned long) ioremap_cached(block_start[bi], length);
; 914  :         //#endif
; 915  :         if (block_start[bi]) {

  0031c	0a000007	 beq         |$LN21@CMK_Init|

; 916  :             // physical address specified in registry (hole was punched in
; 917  :             // address table in config.bib) - use it directly
; 918  :             // HACKHACKHACK!!!! - This is a big security risk.  Either remove
; 919  :             // this feature or add a check on the allowable physical address
; 920  :             // range.
; 921  :             //
; 922  :             PHYSICAL_ADDRESS pa = {block_start[bi], 0};
; 923  : #ifdef NOCACHE
; 924  :             block_virtp[bi] = (unsigned long)MmMapIoSpace(pa, length, FALSE);

  00320	e3a03000	 mov         r3, #0
  00324	e1a02007	 mov         r2, r7
  00328	e3a01000	 mov         r1, #0
  0032c	eb000000	 bl          MmMapIoSpace
  00330	e1a02106	 mov         r2, r6, lsl #2
  00334	e7a20004	 str         r0, [r2, +r4]!

; 925  : #else
; 926  :             block_virtp[bi] = (unsigned long)MmMapIoSpace(pa, length, TRUE);
; 927  : #endif // NOCACHE
; 928  :             mem_alloc_type[bi] = MMMAPIOSPACE;

  00338	e3a01000	 mov         r1, #0

; 929  :         }
; 930  :         else {

  0033c	ea00001c	 b           |$LN57@CMK_Init|
  00340		 |$LN21@CMK_Init|

; 931  :             // user did not specify a fixed physical address - let
; 932  :             // AllocPhysMem() decide where to allocate memory. Memory
; 933  :             // allocated this way is always uncached.
; 934  :             //
; 935  :             // block_virtp[bi] = (unsigned long)AllocPhysMem(length,
; 936  :             //         PAGE_READWRITE, gdwPageSize, 0, &block_start[bi]);
; 937  :             // block_virtp[bi] = (unsigned long)AllocPhysMem(length,
; 938  :             //         PAGE_READWRITE, 0, 0, &block_start[bi]);
; 939  : #define PHYS_ALLOC_MEM_ALIGN 0x10000
; 940  :             // hack: dsplink like the physical address which is 64k aligned,
; 941  :             // but AllocPhysMem seems to only care if the virtual address
; 942  :             // is aligned, so we have to adjust the physical address manually.
; 943  :             //
; 944  :             real_block_virtp[bi] = (unsigned long)AllocPhysMem(length +
; 945  :                     PHYS_ALLOC_MEM_ALIGN, PAGE_READWRITE, PHYS_ALLOC_MEM_ALIGN,
; 946  :                     0, &real_block_start[bi]);

  00340	e2854010	 add         r4, r5, #0x10
  00344	e0843106	 add         r3, r4, r6, lsl #2
  00348	e58d3000	 str         r3, [sp]
  0034c	e3a03000	 mov         r3, #0
  00350	e3a02801	 mov         r2, #1, 16
  00354	e3a01004	 mov         r1, #4
  00358	e2870801	 add         r0, r7, #1, 16
  0035c	eb000000	 bl          AllocPhysMem

; 947  :             block_start[bi] = (real_block_start[bi] &
; 948  :                     (PHYS_ALLOC_MEM_ALIGN - 1)) ?
; 949  :                 (real_block_start[bi] & ~(PHYS_ALLOC_MEM_ALIGN - 1)) +
; 950  :                     PHYS_ALLOC_MEM_ALIGN
; 951  :                 : real_block_start[bi];

  00360	e7942106	 ldr         r2, [r4, +r6, lsl #2]
  00364	e2853008	 add         r3, r5, #8
  00368	e3a01cff	 mov         r1, #0xFF, 24
  0036c	e7830106	 str         r0, [r3, +r6, lsl #2]
  00370	e38130ff	 orr         r3, r1, #0xFF
  00374	e1120003	 tst         r2, r3
  00378	13e01cff	 mvnne       r1, #0xFF, 24
  0037c	122130ff	 eorne       r3, r1, #0xFF
  00380	10023003	 andne       r3, r2, r3
  00384	1283e801	 addne       lr, r3, #1, 16

; 952  : 
; 953  :             block_virtp[bi] = real_block_virtp[bi] +
; 954  :                 (block_start[bi] - real_block_start[bi]);
; 955  : 
; 956  :             block_end[bi] += block_start[bi];

  00388	e5983000	 ldr         r3, [r8]
  0038c	01a0e002	 moveq       lr, r2
  00390	e04e1002	 sub         r1, lr, r2
  00394	e083300e	 add         r3, r3, lr
  00398	e5883000	 str         r3, [r8]
  0039c	e2853018	 add         r3, r5, #0x18
  003a0	e1a02106	 mov         r2, r6, lsl #2
  003a4	e0811000	 add         r1, r1, r0
  003a8	e7a21003	 str         r1, [r2, +r3]!

; 957  :             mem_alloc_type[bi] = ALLOCPHYSMEM;

  003ac	e3a01001	 mov         r1, #1
  003b0	e589e000	 str         lr, [r9]
  003b4		 |$LN57@CMK_Init|
  003b4	e2853050	 add         r3, r5, #0x50
  003b8	e7831106	 str         r1, [r3, +r6, lsl #2]

; 958  :         }
; 959  : 
; 960  :         if (block_virtp[bi] == 0) {

  003bc	e5923000	 ldr         r3, [r2]

; 964  : #else
; 965  :             __E("Failed to allocate contiguous memory (cached) (%#lx, %ld)\n",
; 966  :                     block_start[bi], length);
; 967  : #endif
; 968  :             err = 0;
; 969  :             goto fail_after_create;
; 970  :         }
; 971  :         else {
; 972  : #ifdef NOCACHE
; 973  :             __D("Allocate contiguous memory (non-cached)(%#lx, %ld)=%#lx\n",
; 974  :                     block_start[bi], length, block_virtp[bi]);
; 975  : #else
; 976  :             __D("allocate contiguous memory (cached)(%#lx, %ld)=%#lx\n",
; 977  :                     block_start[bi], length, block_virtp[bi]);
; 978  : #endif
; 979  :         }
; 980  : 
; 981  :         block_virtoff[bi] = block_virtp[bi] - block_start[bi];
; 982  :         block_virtend[bi] = block_virtp[bi] + length;
; 983  : 
; 984  :         memset((PUCHAR)block_virtp[bi], 0, length);

  003c0	e1a02007	 mov         r2, r7
  003c4	e1b00003	 movs        r0, r3
  003c8	0a0000a8	 beq         |$LN47@CMK_Init|
  003cc	e5993000	 ldr         r3, [r9]
  003d0	e2851020	 add         r1, r5, #0x20
  003d4	e080e007	 add         lr, r0, r7
  003d8	e0403003	 sub         r3, r0, r3
  003dc	e7813106	 str         r3, [r1, +r6, lsl #2]
  003e0	e2853028	 add         r3, r5, #0x28
  003e4	e3a01000	 mov         r1, #0
  003e8	e783e106	 str         lr, [r3, +r6, lsl #2]
  003ec	eb000000	 bl          memset

; 985  : 
; 986  :         /* Parse and allocate the pools */
; 987  :         for (i = 0; i < npools[bi]; i++) {

  003f0	e1a07106	 mov         r7, r6, lsl #2
  003f4	e2853068	 add         r3, r5, #0x68
  003f8	e7b73003	 ldr         r3, [r7, +r3]!
  003fc	e3a04000	 mov         r4, #0
  00400	e3a09000	 mov         r9, #0
  00404	e3530000	 cmp         r3, #0
  00408	da00004e	 ble         |$LN15@CMK_Init|
  0040c		 |$LL17@CMK_Init|

; 988  :             TCHAR tszRegKey[256];
; 989  :             dwDataSize = sizeof(pool_num_buffers);
; 990  :             if (StringCchPrintf(tszRegKey, 256, TEXT("%s%d_%s%d"),
; 991  :                         CMEMK_REG_KEY_BLOCK, bi, CMEMK_REG_KEY_NUM_BUFFERS, i)
; 992  :                     != S_OK) {

  0040c	e3a0e004	 mov         lr, #4
  00410	e58de00c	 str         lr, [sp, #0xC]
  00414	e59fe2c0	 ldr         lr, [pc, #0x2C0]
  00418	e59f32b0	 ldr         r3, [pc, #0x2B0]
  0041c	e59f22a8	 ldr         r2, [pc, #0x2A8]
  00420	e3a01c01	 mov         r1, #1, 24
  00424	e28d0044	 add         r0, sp, #0x44
  00428	e58de004	 str         lr, [sp, #4]
  0042c	e58d4008	 str         r4, [sp, #8]
  00430	e58d6000	 str         r6, [sp]
  00434	eb000000	 bl          StringCchPrintfW
  00438	e3500000	 cmp         r0, #0

; 993  :                 RETAILMSG(1, (TEXT("ERROR: CMEMK init(): StringCchPrintf (NUM_BUFFERS) failed!!!\r\n")));

  0043c	159f0294	 ldrne       r0, [pc, #0x294]
  00440	1b000000	 blne        NKDbgPrintfW

; 994  :             }
; 995  :             if (RegQueryValueEx(hKey, tszRegKey, NULL, NULL,
; 996  :                         (LPBYTE)&pool_num_buffers, &dwDataSize) !=
; 997  :                     ERROR_SUCCESS) {

  00444	e28de00c	 add         lr, sp, #0xC
  00448	e59d0010	 ldr         r0, [sp, #0x10]
  0044c	e58de004	 str         lr, [sp, #4]
  00450	e28de014	 add         lr, sp, #0x14
  00454	e3a03000	 mov         r3, #0
  00458	e3a02000	 mov         r2, #0
  0045c	e28d1044	 add         r1, sp, #0x44
  00460	e58de000	 str         lr, [sp]
  00464	eb000000	 bl          RegQueryValueExW
  00468	e3500000	 cmp         r0, #0
  0046c	0a000004	 beq         |$LN13@CMK_Init|

; 998  :                 __E("CMEMK: cannot open registry key: %s!\n", tszRegKey);

  00470	e59f024c	 ldr         r0, [pc, #0x24C]
  00474	e28d1044	 add         r1, sp, #0x44
  00478	eb000000	 bl          NKDbgPrintfW

; 999  :                 pool_num_buffers = 0;

  0047c	e3a03000	 mov         r3, #0
  00480	e58d3014	 str         r3, [sp, #0x14]
  00484		 |$LN13@CMK_Init|

; 1000 :             }
; 1001 : 
; 1002 :             if (StringCchPrintf(tszRegKey, 256, TEXT("%s%d_%s%d"),
; 1003 :                         CMEMK_REG_KEY_BLOCK, bi, CMEMK_REG_KEY_POOL_SIZE, i)
; 1004 :                     != S_OK) {

  00484	e59fe248	 ldr         lr, [pc, #0x248]
  00488	e59f3240	 ldr         r3, [pc, #0x240]
  0048c	e59f2238	 ldr         r2, [pc, #0x238]
  00490	e3a01c01	 mov         r1, #1, 24
  00494	e28d0044	 add         r0, sp, #0x44
  00498	e58de004	 str         lr, [sp, #4]
  0049c	e58d4008	 str         r4, [sp, #8]
  004a0	e58d6000	 str         r6, [sp]
  004a4	eb000000	 bl          StringCchPrintfW
  004a8	e3500000	 cmp         r0, #0

; 1005 :                 RETAILMSG(1, (TEXT("ERROR: CMEMK init(): StringCchPrintf (POOL_SIZE) failed!!!\r\n")));

  004ac	159f0214	 ldrne       r0, [pc, #0x214]
  004b0	1b000000	 blne        NKDbgPrintfW

; 1006 :             }
; 1007 :             dwDataSize = sizeof(pool_size);
; 1008 :             if (RegQueryValueEx(hKey, tszRegKey, NULL, NULL,
; 1009 :                         (LPBYTE)&pool_size, &dwDataSize) != ERROR_SUCCESS) {

  004b4	e3a0e004	 mov         lr, #4
  004b8	e58de00c	 str         lr, [sp, #0xC]
  004bc	e28de00c	 add         lr, sp, #0xC
  004c0	e59d0010	 ldr         r0, [sp, #0x10]
  004c4	e58de004	 str         lr, [sp, #4]
  004c8	e28de018	 add         lr, sp, #0x18
  004cc	e3a03000	 mov         r3, #0
  004d0	e3a02000	 mov         r2, #0
  004d4	e28d1044	 add         r1, sp, #0x44
  004d8	e58de000	 str         lr, [sp]
  004dc	eb000000	 bl          RegQueryValueExW
  004e0	e3500000	 cmp         r0, #0
  004e4	0a000005	 beq         |$LN52@CMK_Init|

; 1010 :                 __E("CMEMK: cannot open registry key: %s!\n", tszRegKey);

  004e8	e59f01d4	 ldr         r0, [pc, #0x1D4]
  004ec	e28d1044	 add         r1, sp, #0x44
  004f0	eb000000	 bl          NKDbgPrintfW

; 1011 :                 pool_size = 0;

  004f4	e3a03000	 mov         r3, #0
  004f8	e58d3018	 str         r3, [sp, #0x18]
  004fc	ea000000	 b           |$LN11@CMK_Init|
  00500		 |$LN52@CMK_Init|
  00500	e59d3018	 ldr         r3, [sp, #0x18]
  00504		 |$LN11@CMK_Init|

; 1012 :             }
; 1013 : 
; 1014 :             if (alloc_pool(bi, i, pool_num_buffers, pool_size, NULL) < 0) {

  00504	e59d2014	 ldr         r2, [sp, #0x14]
  00508	e1a01004	 mov         r1, r4
  0050c	e1a00006	 mov         r0, r6
  00510	e58d9000	 str         r9, [sp]
  00514	eb000000	 bl          alloc_pool
  00518	e3500000	 cmp         r0, #0
  0051c	4a000038	 bmi         |$LN45@CMK_Init|

; 1019 :             }
; 1020 : 
; 1021 :             total_num_buffers[bi] += pool_num_buffers;

  00520	e1a00106	 mov         r0, r6, lsl #2
  00524	e2853048	 add         r3, r5, #0x48
  00528	e7b02003	 ldr         r2, [r0, +r3]!
  0052c	e59d3014	 ldr         r3, [sp, #0x14]
  00530	e5971000	 ldr         r1, [r7]
  00534	e2844001	 add         r4, r4, #1
  00538	e0823003	 add         r3, r2, r3
  0053c	e5803000	 str         r3, [r0]
  00540	e1540001	 cmp         r4, r1
  00544	baffffb0	 blt         |$LL17@CMK_Init|
  00548		 |$LN15@CMK_Init|

; 1022 :         }
; 1023 : 
; 1024 :         /* use whatever is left for the heap */
; 1025 :         heap_size[bi] = block_avail_size[bi] & PAGE_MASK;

  00548	e59f8170	 ldr         r8, [pc, #0x170]
  0054c	e59b2000	 ldr         r2, [r11]

; 1026 :         heap_pool[bi] = npools[bi];

  00550	e5971000	 ldr         r1, [r7]
  00554	e5980000	 ldr         r0, [r8]
  00558	e1a04106	 mov         r4, r6, lsl #2
  0055c	e2403001	 sub         r3, r0, #1
  00560	e1d23003	 bics        r3, r2, r3
  00564	e59f2150	 ldr         r2, [pc, #0x150]
  00568	e7a4300a	 str         r3, [r4, +r10]!
  0056c	e7821106	 str         r1, [r2, +r6, lsl #2]

; 1027 :         if (heap_size[bi] > 0) {

  00570	0a000012	 beq         |$LN9@CMK_Init|

; 1028 :             err = alloc_pool(bi, heap_pool[bi], 1, heap_size[bi],
; 1029 :                     &heap_virtp[bi]);

  00574	e59f213c	 ldr         r2, [pc, #0x13C]
  00578	e1a00006	 mov         r0, r6
  0057c	e0827106	 add         r7, r2, r6, lsl #2
  00580	e3a02001	 mov         r2, #1
  00584	e58d7000	 str         r7, [sp]
  00588	eb000000	 bl          alloc_pool
  0058c	e3500000	 cmp         r0, #0

; 1030 :             if (err < 0) {

  00590	4a000020	 bmi         |$LN48@CMK_Init|

; 1032 :                 goto fail_after_ioremap;
; 1033 :             }
; 1034 :             __D("allocated heap buffer %#lx of size %#lx\n", heap_virtp[bi],
; 1035 :                     heap_size[bi]);
; 1036 :             header = (HeapMem_Header *)heap_virtp[bi];
; 1037 :             heap_head[bi].next = header;
; 1038 :             heap_head[bi].size = heap_size[bi];

  00594	e59fe118	 ldr         lr, [pc, #0x118]
  00598	e5971000	 ldr         r1, [r7]
  0059c	e5942000	 ldr         r2, [r4]
  005a0	e08e3186	 add         r3, lr, r6, lsl #3
  005a4	e78e1186	 str         r1, [lr, +r6, lsl #3]
  005a8	e5832004	 str         r2, [r3, #4]

; 1039 :             header->next = NULL;

  005ac	e5819000	 str         r9, [r1]

; 1040 :             header->size = heap_size[bi];

  005b0	e5943000	 ldr         r3, [r4]
  005b4	e5813004	 str         r3, [r1, #4]

; 1041 :         }
; 1042 :         else {

  005b8	e5980000	 ldr         r0, [r8]
  005bc	ea000001	 b           |$LN26@CMK_Init|
  005c0		 |$LN9@CMK_Init|

; 1043 :             __D("no remaining memory for heap, no heap created for memory block %d\n", bi);
; 1044 :             heap_head[bi].next = NULL;
; 1045 :             heap_head[bi].next = 0;

  005c0	e59f30ec	 ldr         r3, [pc, #0xEC]
  005c4	e7839186	 str         r9, [r3, +r6, lsl #3]
  005c8		 |$LN26@CMK_Init|
  005c8	e59d301c	 ldr         r3, [sp, #0x1C]
  005cc	e1a06003	 mov         r6, r3
  005d0	e3530002	 cmp         r3, #2
  005d4	baffff31	 blt         |$LN58@CMK_Init|
  005d8		 |$LN53@CMK_Init|

; 1046 :         }
; 1047 : 
; 1048 :         __D("cmem initialized %d pools between %#lx and %#lx\n", npools[bi],
; 1049 :                 block_start[bi], block_end[bi]);
; 1050 :     }
; 1051 : 
; 1052 :     /* Initialize list of mapped buffers */
; 1053 :     InitializeListHead(&mappedBufferList);
; 1054 : 
; 1055 :     __D("Successfully initialized module\n");
; 1056 : 
; 1057 :     RegCloseKey(hKey);

  005d8	e59d0010	 ldr         r0, [sp, #0x10]
  005dc	e5855004	 str         r5, [r5, #4]
  005e0	e5855000	 str         r5, [r5]
  005e4	eb000000	 bl          RegCloseKey

; 1058 :     CMKDevice.openCount = 0;

  005e8	e59f40c0	 ldr         r4, [pc, #0xC0]
  005ec	e3a03000	 mov         r3, #0

; 1059 :     CMKDevice.initialized = TRUE;

  005f0	e3a02001	 mov         r2, #1
  005f4	e884000c	 stmia       r4, {r2, r3}

; 1060 : 
; 1061 :     return (DWORD)&CMKDevice;

  005f8	e59d0244	 ldr         r0, [sp, #0x244]
  005fc	eb000000	 bl          __security_check_cookie
  00600	ea000023	 b           |$LN38@CMK_Init|
  00604		 |$LN45@CMK_Init|

; 1015 :                 __E("Failed to alloc pool of size %d and number of buffers %d\n",
; 1016 :                         pool_size, pool_num_buffers);

  00604	e59d2014	 ldr         r2, [sp, #0x14]
  00608	e59d1018	 ldr         r1, [sp, #0x18]
  0060c	e59f0098	 ldr         r0, [pc, #0x98]
  00610	eb000000	 bl          NKDbgPrintfW

; 1017 :                 err = 0;
; 1018 :                 goto fail_after_ioremap;

  00614	ea000002	 b           |$fail_after_ioremap$40523|
  00618		 |$LN48@CMK_Init|

; 1031 :                 __E("Failed to alloc heap of size %#lx\n", heap_size[bi]);

  00618	e79a1106	 ldr         r1, [r10, +r6, lsl #2]
  0061c	e59f0084	 ldr         r0, [pc, #0x84]
  00620	eb000000	 bl          NKDbgPrintfW
  00624		 |$fail_after_ioremap$40523|

; 1062 : 
; 1063 : 
; 1064 :   fail_after_ioremap:
; 1065 :     for (bi = 0; bi < NBLOCKS; bi++) {

  00624	e2858050	 add         r8, r5, #0x50
  00628	e2856040	 add         r6, r5, #0x40
  0062c	e2857018	 add         r7, r5, #0x18
  00630	e2855018	 add         r5, r5, #0x18
  00634	e3a04000	 mov         r4, #0
  00638		 |$LL6@CMK_Init|

; 1066 :         if (mem_alloc_type[bi] == MMMAPIOSPACE) {

  00638	e7943008	 ldr         r3, [r4, +r8]
  0063c	e3530000	 cmp         r3, #0
  00640	1a000003	 bne         |$LN3@CMK_Init|

; 1067 :             MmUnmapIoSpace((PVOID)block_virtp[bi], block_avail_size[bi]);

  00644	e7941006	 ldr         r1, [r4, +r6]
  00648	e7940007	 ldr         r0, [r4, +r7]
  0064c	eb000000	 bl          MmUnmapIoSpace
  00650	ea000002	 b           |$LN5@CMK_Init|
  00654		 |$LN3@CMK_Init|

; 1068 :         }
; 1069 :         else if (mem_alloc_type[bi] == ALLOCPHYSMEM) {

  00654	e3530001	 cmp         r3, #1

; 1070 :             FreePhysMem((LPVOID)block_virtp[bi]);

  00658	07940005	 ldreq       r0, [r4, +r5]
  0065c	0b000000	 bleq        FreePhysMem
  00660		 |$LN5@CMK_Init|
  00660	e2844004	 add         r4, r4, #4
  00664	e3540008	 cmp         r4, #8
  00668	bafffff2	 blt         |$LL6@CMK_Init|
  0066c	ea000003	 b           |$fail_after_create$40477|
  00670		 |$LN47@CMK_Init|

; 961  : #ifdef NOCACHE
; 962  :             __E("Failed to allocate contiguous memory (non-cached) (%#lx, %ld)\n",
; 963  :                     block_start[bi], length);

  00670	e2853030	 add         r3, r5, #0x30
  00674	e7931106	 ldr         r1, [r3, +r6, lsl #2]
  00678	e59f0024	 ldr         r0, [pc, #0x24]
  0067c		 |$LN56@CMK_Init|
  0067c	eb000000	 bl          NKDbgPrintfW
  00680		 |$fail_after_create$40477|

; 1071 :         }
; 1072 :     }
; 1073 : 
; 1074 :   fail_after_create:
; 1075 : //fail_after_reg:
; 1076 :     RegCloseKey(hKey);

  00680	e59d0010	 ldr         r0, [sp, #0x10]
  00684	eb000000	 bl          RegCloseKey
  00688		 |$LN55@CMK_Init|

; 1077 :     return 0;

  00688	e59d0244	 ldr         r0, [sp, #0x244]
  0068c	eb000000	 bl          __security_check_cookie
  00690	e3a04000	 mov         r4, #0
  00694		 |$LN38@CMK_Init|

; 1078 : }

  00694	e1a00004	 mov         r0, r4
  00698	e28ddf92	 add         sp, sp, #0x92, 30
  0069c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  006a0	e12fff1e	 bx          lr
  006a4		 |$LN63@CMK_Init|
  006a4		 |$LN64@CMK_Init|
  006a4	00000000	 DCD         |??_C@_1JI@POFHIEIK@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?5@|
  006a8		 |$LN65@CMK_Init|
  006a8	00000000	 DCD         |??_C@_1GA@EHIEFMCN@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AAh?$AAe?$AAa@|
  006ac		 |$LN66@CMK_Init|
  006ac	00000000	 DCD         |??_C@_1IO@JOGLBBIA@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AAp?$AAo?$AAo@|
  006b0		 |$LN67@CMK_Init|
  006b0	00000000	 DCD         |CMKDevice|
  006b4		 |$LN68@CMK_Init|
  006b4	00000000	 DCD         |heap_head|
  006b8		 |$LN69@CMK_Init|
  006b8	00000000	 DCD         |heap_virtp|
  006bc		 |$LN70@CMK_Init|
  006bc	00000000	 DCD         |heap_pool|
  006c0		 |$LN71@CMK_Init|
  006c0	00000000	 DCD         |gdwPageSize|
  006c4		 |$LN72@CMK_Init|
  006c4	00000000	 DCD         |??_C@_1GG@BKOAGPDI@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?3?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5@|
  006c8		 |$LN73@CMK_Init|
  006c8	00000000	 DCD         |??_C@_1HK@PBGLKGFP@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CJ?$AA?3?$AA?5?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AAC?$AAc?$AAh?$AAP?$AAr@|
  006cc		 |$LN74@CMK_Init|
  006cc	00000000	 DCD         |??_C@_1BE@DMMEGEFO@?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA_?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@|
  006d0		 |$LN75@CMK_Init|
  006d0	00000000	 DCD         |??_C@_1M@PICFELOA@?$AAB?$AAl?$AAo?$AAc?$AAk?$AA?$AA@|
  006d4		 |$LN76@CMK_Init|
  006d4	00000000	 DCD         |??_C@_1BM@GDPAOOKP@?$AAP?$AAo?$AAo?$AAl?$AAS?$AAi?$AAz?$AAe?$AA_?$AAP?$AAo?$AAo?$AAl?$AA?$AA@|
  006d8		 |$LN77@CMK_Init|
  006d8	00000000	 DCD         |??_C@_1HO@CDBIOCIL@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CJ?$AA?3?$AA?5?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AAC?$AAc?$AAh?$AAP?$AAr@|
  006dc		 |$LN78@CMK_Init|
  006dc	00000000	 DCD         |??_C@_1CA@JCJOGNFE@?$AAN?$AAu?$AAm?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAs?$AA_?$AAP?$AAo?$AAo?$AAl?$AA?$AA@|
  006e0		 |$LN79@CMK_Init|
  006e0	00000000	 DCD         |heap_size|
  006e4		 |$LN80@CMK_Init|
  006e4	00000000	 DCD         |??_C@_1BI@DJKHEDFH@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA_?$AAM?$AAU?$AAT?$AAE?$AAX?$AA?$AA@|
  006e8		 |$LN81@CMK_Init|
  006e8	00000000	 DCD         |??_C@_1JI@FJFCHAIK@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AAs?$AAp?$AAe?$AAc@|
  006ec		 |$LN82@CMK_Init|
  006ec	00000000	 DCD         |??_C@_1JI@CGJLOLBJ@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AAs?$AAp?$AAe?$AAc@|
  006f0		 |$LN83@CMK_Init|
  006f0	00000000	 DCD         |??_C@_1DC@KFACKDPH@?$AAU?$AAs?$AAe?$AAH?$AAe?$AAa?$AAp?$AAI?$AAf?$AAP?$AAo?$AAo?$AAl?$AAU?$AAn?$AAa?$AAv?$AAa?$AAi?$AAl?$AAa?$AAb?$AAl?$AAe?$AA?$AA@|
  006f4		 |$LN84@CMK_Init|
  006f4	00000000	 DCD         |useHeapIfPoolUnavailable|
  006f8		 |$LN85@CMK_Init|
  006f8	00000000	 DCD         |??_C@_1BE@NOPHIHDE@?$AAN?$AAu?$AAm?$AAP?$AAo?$AAo?$AAl?$AAs?$AA1?$AA?$AA@|
  006fc		 |$LN86@CMK_Init|
  006fc	00000000	 DCD         |??_C@_1BE@GGELOAFB@?$AAN?$AAu?$AAm?$AAP?$AAo?$AAo?$AAl?$AAs?$AA0?$AA?$AA@|
  00700		 |$LN87@CMK_Init|
  00700	00000000	 DCD         |??_C@_1BK@EEHBOAGL@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAE?$AAn?$AAd?$AA1?$AA?$AA@|
  00704		 |$LN88@CMK_Init|
  00704	00000000	 DCD         |??_C@_1BK@PMMNIHAO@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAE?$AAn?$AAd?$AA0?$AA?$AA@|
  00708		 |$LN89@CMK_Init|
  00708	00000000	 DCD         |??_C@_1BO@ODBAMBIC@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAS?$AAt?$AAa?$AAr?$AAt?$AA1?$AA?$AA@|
  0070c		 |$LN90@CMK_Init|
  0070c	00000000	 DCD         |??_C@_1BO@FLKMKGOH@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAS?$AAt?$AAa?$AAr?$AAt?$AA0?$AA?$AA@|
  00710		 |$LN91@CMK_Init|
  00710	00000000	 DCD         |mappedBufferList|
  00714		 |$LN92@CMK_Init|
  00714	00000000	 DCD         |??_C@_1FO@GGDGBKHC@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?3?$AA?5?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5@|
  00718		 |$LN93@CMK_Init|
  00718	00000000	 DCD         |??_C@_1CM@BOKDKMGI@?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAB?$AAu?$AAi?$AAl?$AAt?$AAI?$AAn?$AA?2?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?$AA@|
  0071c		 |$LN94@CMK_Init|
  0071c	00000000	 DCD         |__security_cookie|
  00720		 |$M41269|

			 ENDP  ; |CMK_Init|

	EXPORT	|CMK_Deinit|
	EXPORT	|??_C@_1GE@MBPJBFA@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?3?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?0?$AA?5?$AAd?$AAe?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAd?$AA?5?$AAw?$AAi@| [ DATA ] ; `string'
	IMPORT	|CloseHandle|
	IMPORT	|free|

  00000			 AREA	 |.pdata|, PDATA
|$T41331| DCD	|$LN32@CMK_Deinit|
	DCD	0x40004a02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GE@MBPJBFA@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?3?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?0?$AA?5?$AAd?$AAe?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAd?$AA?5?$AAw?$AAi@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, ":", 0x0, " "
	DCB	0x0, "w", 0x0, "a", 0x0, "r", 0x0, "n", 0x0, "i", 0x0, "n"
	DCB	0x0, "g", 0x0, ",", 0x0, " ", 0x0, "d", 0x0, "e", 0x0, "i"
	DCB	0x0, "n", 0x0, "i", 0x0, "t", 0x0, "i", 0x0, "a", 0x0, "l"
	DCB	0x0, "i", 0x0, "z", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "w"
	DCB	0x0, "i", 0x0, "t", 0x0, "h", 0x0, " ", 0x0, "o", 0x0, "p"
	DCB	0x0, "e", 0x0, "n", 0x0, " ", 0x0, "c", 0x0, "l", 0x0, "i"
	DCB	0x0, "e", 0x0, "n", 0x0, "t", 0x0, "s", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CMK_Deinit| PROC

; 1086 : {

  00000		 |$LN32@CMK_Deinit|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M41328|
  00008	e58d0000	 str         r0, [sp]

; 1087 :     DEVICE_STATE *pCMKDevice = (DEVICE_STATE *)dwContext;
; 1088 :     LIST_ENTRY *freelistp;
; 1089 :     LIST_ENTRY *busylistp;
; 1090 :     LIST_ENTRY *e;
; 1091 :     struct pool_buffer *entry;
; 1092 :     int num_pools;
; 1093 :     int bi;
; 1094 :     int i;
; 1095 : 
; 1096 :     __D("In cmem_exit()\n");
; 1097 : 
; 1098 :     for (bi = 0; bi < NBLOCKS; bi++) {

  0000c	e59f3110	 ldr         r3, [pc, #0x110]
  00010	e59f6108	 ldr         r6, [pc, #0x108]
  00014	e59f2100	 ldr         r2, [pc, #0x100]
  00018	e283a008	 add         r10, r3, #8
  0001c	e2863050	 add         r3, r6, #0x50
  00020	e3a04000	 mov         r4, #0
  00024	e2861038	 add         r1, r6, #0x38
  00028	e286b028	 add         r11, r6, #0x28
  0002c		 |$LL16@CMK_Deinit|

; 1099 :         num_pools = npools[bi];

  0002c	e7943003	 ldr         r3, [r4, +r3]
  00030	e1b05003	 movs        r5, r3

; 1100 :         if (!num_pools) {

  00034	0a000024	 beq         |$LN15@CMK_Deinit|

; 1101 :             continue;
; 1102 :         }
; 1103 : 
; 1104 :         if (heap_pool[bi] != -1) {

  00038	e7943002	 ldr         r3, [r4, +r2]
  0003c	e3730001	 cmn         r3, #1

; 1105 :             num_pools++;

  00040	12855001	 addne       r5, r5, #1

; 1106 :         }
; 1107 : 
; 1108 :         /* Free the pool structures and empty the lists. */
; 1109 :         for (i=0; i<num_pools; i++) {

  00044	e3550000	 cmp         r5, #0
  00048	da000013	 ble         |$LN9@CMK_Deinit|
  0004c	e1a0700a	 mov         r7, r10
  00050		 |$LL11@CMK_Deinit|

; 1110 :             __D("Freeing memory associated with pool %d\n", i);
; 1111 : 
; 1112 :             freelistp = &p_objs[bi][i].freelist;
; 1113 :             busylistp = &p_objs[bi][i].busylist;
; 1114 : 
; 1115 :             e = busylistp->Flink;

  00050	e5978000	 ldr         r8, [r7]
  00054	e2479008	 sub         r9, r7, #8
  00058	ea000002	 b           |$LN27@CMK_Deinit|
  0005c		 |$LL8@CMK_Deinit|

; 1116 :             while (e != busylistp) {
; 1117 :                 entry = CONTAINING_RECORD(e, struct pool_buffer, element);

  0005c	e1a00008	 mov         r0, r8

; 1118 :                 __D("Warning: Freeing busy entry %d at %#lx\n",
; 1119 :                         entry->id, entry->physp);
; 1120 :                 e = e->Flink;

  00060	e5988000	 ldr         r8, [r8]

; 1121 :                 free(entry);

  00064	eb000000	 bl          free
  00068		 |$LN27@CMK_Deinit|
  00068	e1580007	 cmp         r8, r7
  0006c	1afffffa	 bne         |$LL8@CMK_Deinit|

; 1122 :             }
; 1123 : 
; 1124 :             e = freelistp->Flink;

  00070	e5998000	 ldr         r8, [r9]
  00074	ea000002	 b           |$LN28@CMK_Deinit|
  00078		 |$LL6@CMK_Deinit|

; 1125 :             while (e != freelistp) {
; 1126 :                 entry = CONTAINING_RECORD(e, struct pool_buffer, element);

  00078	e1a00008	 mov         r0, r8

; 1127 :                 __D("Freeing free entry %d at %#lx\n", entry->id, entry->physp);
; 1128 :                 e = e->Flink;

  0007c	e5988000	 ldr         r8, [r8]

; 1129 :                 free(entry);

  00080	eb000000	 bl          free
  00084		 |$LN28@CMK_Deinit|
  00084	e1580009	 cmp         r8, r9
  00088	1afffffa	 bne         |$LL6@CMK_Deinit|
  0008c	e287701c	 add         r7, r7, #0x1C
  00090	e2555001	 subs        r5, r5, #1
  00094	1affffed	 bne         |$LL11@CMK_Deinit|
  00098	e2861038	 add         r1, r6, #0x38
  0009c		 |$LN9@CMK_Deinit|

; 1130 :             }
; 1131 :         }
; 1132 : 
; 1133 :         //iounmap((void *) block_virtp[bi]);
; 1134 :         if (mem_alloc_type[bi] == MMMAPIOSPACE) {

  0009c	e7943001	 ldr         r3, [r4, +r1]
  000a0	e3530000	 cmp         r3, #0
  000a4	1a000003	 bne         |$LN4@CMK_Deinit|

; 1135 :             MmUnmapIoSpace((PVOID)block_virtp[bi], block_avail_size[bi]);

  000a8	e794100b	 ldr         r1, [r4, +r11]
  000ac	e7940006	 ldr         r0, [r4, +r6]
  000b0	eb000000	 bl          MmUnmapIoSpace
  000b4	ea000003	 b           |$LN29@CMK_Deinit|
  000b8		 |$LN4@CMK_Deinit|

; 1136 :         }
; 1137 :         else if (mem_alloc_type[bi] == ALLOCPHYSMEM) {

  000b8	e3530001	 cmp         r3, #1
  000bc	1a000002	 bne         |$LN15@CMK_Deinit|

; 1138 :             FreePhysMem((LPVOID)block_virtp[bi]);

  000c0	e7940006	 ldr         r0, [r4, +r6]
  000c4	eb000000	 bl          FreePhysMem
  000c8		 |$LN29@CMK_Deinit|
  000c8	e2861038	 add         r1, r6, #0x38
  000cc		 |$LN15@CMK_Deinit|
  000cc	e2844004	 add         r4, r4, #4
  000d0	e59f2044	 ldr         r2, [pc, #0x44]
  000d4	e3540008	 cmp         r4, #8
  000d8	e28aac0e	 add         r10, r10, #0xE, 24
  000dc	e2863050	 add         r3, r6, #0x50
  000e0	baffffd1	 blt         |$LL16@CMK_Deinit|

; 1139 :         }
; 1140 :     }
; 1141 :     CloseHandle(cmem_mutex);

  000e4	e5960468	 ldr         r0, [r6, #0x468]
  000e8	eb000000	 bl          CloseHandle

; 1142 : 
; 1143 :     pCMKDevice->initialized = FALSE;
; 1144 :     if (pCMKDevice->openCount != 0) {

  000ec	e59db000	 ldr         r11, [sp]
  000f0	e3a02000	 mov         r2, #0
  000f4	e59b3004	 ldr         r3, [r11, #4]
  000f8	e58b2000	 str         r2, [r11]
  000fc	e3530000	 cmp         r3, #0

; 1145 :         RETAILMSG(1, (L"CMEMK: warning, deinitialized with open clients\r\n"));

  00100	159f0010	 ldrne       r0, [pc, #0x10]
  00104	1b000000	 blne        NKDbgPrintfW

; 1146 :     }
; 1147 : 
; 1148 :     return TRUE;

  00108	e3a00001	 mov         r0, #1

; 1149 : }

  0010c	e28dd004	 add         sp, sp, #4
  00110	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00114	e12fff1e	 bx          lr
  00118		 |$LN33@CMK_Deinit|
  00118		 |$LN34@CMK_Deinit|
  00118	00000000	 DCD         |??_C@_1GE@MBPJBFA@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?3?$AA?5?$AAw?$AAa?$AAr?$AAn?$AAi?$AAn?$AAg?$AA?0?$AA?5?$AAd?$AAe?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAd?$AA?5?$AAw?$AAi@|
  0011c		 |$LN35@CMK_Deinit|
  0011c	00000000	 DCD         |heap_pool|
  00120		 |$LN36@CMK_Deinit|
  00120	00000000	 DCD         |block_virtp|
  00124		 |$LN37@CMK_Deinit|
  00124	00000000	 DCD         |p_objs|
  00128		 |$M41329|

			 ENDP  ; |CMK_Deinit|

	EXPORT	|CMK_Open|
	IMPORT	|InterlockedIncrement|

  00000			 AREA	 |.pdata|, PDATA
|$T41346| DCD	|$LN5@CMK_Open|
	DCD	0x40000701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CMK_Open| PROC

; 1157 : {

  00000		 |$LN5@CMK_Open|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M41343|
  00004	e1a04000	 mov         r4, r0

; 1158 :     DEVICE_STATE *pCMKDevice = (DEVICE_STATE *)Context;
; 1159 : 
; 1160 :     InterlockedIncrement(&pCMKDevice->openCount);

  00008	e2840004	 add         r0, r4, #4
  0000c	eb000000	 bl          InterlockedIncrement

; 1161 : 
; 1162 :     return (Context);
; 1163 : }

  00010	e1a00004	 mov         r0, r4
  00014	e8bd4010	 ldmia       sp!, {r4, lr}
  00018	e12fff1e	 bx          lr
  0001c		 |$M41344|

			 ENDP  ; |CMK_Open|

	EXPORT	|CMK_Close|
	EXPORT	|??_C@_1EM@DJHCFEOD@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?3?$AA?5?$AAC?$AAM?$AAK?$AA_?$AAC?$AAl?$AAo?$AAs?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?9?$AA?5?$AAo?$AAp?$AAe?$AAn?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM@| [ DATA ] ; `string'
	IMPORT	|InterlockedDecrement|

  00000			 AREA	 |.pdata|, PDATA
|$T41356| DCD	|$LN6@CMK_Close|
	DCD	0x40000f01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EM@DJHCFEOD@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?3?$AA?5?$AAC?$AAM?$AAK?$AA_?$AAC?$AAl?$AAo?$AAs?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?9?$AA?5?$AAo?$AAp?$AAe?$AAn?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, ":", 0x0, " "
	DCB	0x0, "C", 0x0, "M", 0x0, "K", 0x0, "_", 0x0, "C", 0x0, "l"
	DCB	0x0, "o", 0x0, "s", 0x0, "e", 0x0, "(", 0x0, ")", 0x0, " "
	DCB	0x0, "-", 0x0, " ", 0x0, "o", 0x0, "p", 0x0, "e", 0x0, "n"
	DCB	0x0, "C", 0x0, "o", 0x0, "u", 0x0, "n", 0x0, "t", 0x0, " "
	DCB	0x0, "<", 0x0, " ", 0x0, "1", 0x0, "!", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CMK_Close| PROC

; 1172 : {

  00000		 |$LN6@CMK_Close|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41353|

; 1173 :     DEVICE_STATE *pCMKDevice = (DEVICE_STATE *)dwContext;
; 1174 : 
; 1175 :     if (pCMKDevice->openCount < 1) {

  00004	e5903004	 ldr         r3, [r0, #4]
  00008	e3530001	 cmp         r3, #1
  0000c	2a000004	 bcs         |$LN1@CMK_Close|

; 1176 :         RETAILMSG(1, (TEXT("CMEMK: CMK_Close() - openCount < 1!\r\n")));

  00010	e59f0020	 ldr         r0, [pc, #0x20]
  00014	eb000000	 bl          NKDbgPrintfW

; 1177 :         return FALSE;

  00018	e3a00000	 mov         r0, #0

; 1183 : }

  0001c	e49de004	 ldr         lr, [sp], #4
  00020	e12fff1e	 bx          lr
  00024		 |$LN1@CMK_Close|

; 1178 :     }
; 1179 : 
; 1180 :     InterlockedDecrement(&pCMKDevice->openCount);

  00024	e2800004	 add         r0, r0, #4
  00028	eb000000	 bl          InterlockedDecrement

; 1181 : 
; 1182 :     return (TRUE);

  0002c	e3a00001	 mov         r0, #1

; 1183 : }

  00030	e49de004	 ldr         lr, [sp], #4
  00034	e12fff1e	 bx          lr
  00038		 |$LN7@CMK_Close|
  00038		 |$LN8@CMK_Close|
  00038	00000000	 DCD         |??_C@_1EM@DJHCFEOD@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?3?$AA?5?$AAC?$AAM?$AAK?$AA_?$AAC?$AAl?$AAo?$AAs?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?9?$AA?5?$AAo?$AAp?$AAe?$AAn?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM@|
  0003c		 |$M41354|

			 ENDP  ; |CMK_Close|

	EXPORT	|CMK_Read|

  00000			 AREA	 |.pdata|, PDATA
|$T41367| DCD	|$LN5@CMK_Read|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CMK_Read| PROC

; 1193 : {

  00000		 |$LN5@CMK_Read|
  00000		 |$M41364|

; 1194 :     return  0;

  00000	e3a00000	 mov         r0, #0

; 1195 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M41365|

			 ENDP  ; |CMK_Read|

	EXPORT	|CMK_Write|

  00000			 AREA	 |.pdata|, PDATA
|$T41376| DCD	|$LN5@CMK_Write|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CMK_Write| PROC

; 1204 : {

  00000		 |$LN5@CMK_Write|
  00000		 |$M41373|

; 1205 :     return  0;

  00000	e3a00000	 mov         r0, #0

; 1206 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M41374|

			 ENDP  ; |CMK_Write|

	EXPORT	|CMK_Seek|

  00000			 AREA	 |.pdata|, PDATA
|$T41385| DCD	|$LN5@CMK_Seek|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CMK_Seek| PROC

; 1215 : {

  00000		 |$LN5@CMK_Seek|
  00000		 |$M41382|

; 1216 :     return 0;

  00000	e3a00000	 mov         r0, #0

; 1217 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M41383|

			 ENDP  ; |CMK_Seek|

	EXPORT	|CMK_PowerDown|

  00000			 AREA	 |.pdata|, PDATA
|$T41392| DCD	|$LN5@CMK_PowerD|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CMK_PowerDown| PROC

; 1855 : {

  00000		 |$LN5@CMK_PowerD|
  00000		 |$M41389|

; 1856 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M41390|

			 ENDP  ; |CMK_PowerDown|

	EXPORT	|CMK_PowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T41399| DCD	|$LN5@CMK_PowerU|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CMK_PowerUp| PROC

; 1861 : {

  00000		 |$LN5@CMK_PowerU|
  00000		 |$M41396|

; 1862 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M41397|

			 ENDP  ; |CMK_PowerUp|

	EXPORT	|??_C@_1FO@JPKAAJLM@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAV?$AAi?$AAr?$AAt?$AAu?$AAa?$AAl@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HO@HEJCJEEM@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAM?$AAm?$AAM?$AAa?$AAp?$AAI?$AAo@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HM@FPLHNBAD@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAV?$AAi?$AAr?$AAt?$AAu?$AAa?$AAl@| [ DATA ] ; `string'
	EXPORT	|??_C@_1IM@MAGACGEM@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5@| [ DATA ] ; `string'
	IMPORT	|VirtualCopyEx|
	IMPORT	|VirtualFreeEx|
	IMPORT	|VirtualAllocEx|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41422| DCD	|$LN16@mapAddress|
	DCD	0x40005502

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FO@JPKAAJLM@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAV?$AAi?$AAr?$AAt?$AAu?$AAa?$AAl@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "m", 0x0, "a", 0x0, "p", 0x0, "A", 0x0, "d", 0x0, "d"
	DCB	0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, ":", 0x0, " "
	DCB	0x0, "V", 0x0, "i", 0x0, "r", 0x0, "t", 0x0, "u", 0x0, "a"
	DCB	0x0, "l", 0x0, "C", 0x0, "o", 0x0, "p", 0x0, "y", 0x0, "E"
	DCB	0x0, "x", 0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l"
	DCB	0x0, "e", 0x0, "d", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HO@HEJCJEEM@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAM?$AAm?$AAM?$AAa?$AAp?$AAI?$AAo@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "m", 0x0, "a", 0x0, "p", 0x0, "A", 0x0, "d", 0x0, "d"
	DCB	0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, ":", 0x0, " "
	DCB	0x0, "M", 0x0, "m", 0x0, "M", 0x0, "a", 0x0, "p", 0x0, "I"
	DCB	0x0, "o", 0x0, "S", 0x0, "p", 0x0, "a", 0x0, "c", 0x0, "e"
	DCB	0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e"
	DCB	0x0, "d", 0x0, " ", 0x0, "f", 0x0, "o", 0x0, "r", 0x0, " "
	DCB	0x0, "a", 0x0, "d", 0x0, "d", 0x0, "r", 0x0, "e", 0x0, "s"
	DCB	0x0, "s", 0x0, " ", 0x0, "%", 0x0, "#", 0x0, "l", 0x0, "x"
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@FPLHNBAD@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAV?$AAi?$AAr?$AAt?$AAu?$AAa?$AAl@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "m", 0x0, "a", 0x0, "p", 0x0, "A", 0x0, "d", 0x0, "d"
	DCB	0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, ":", 0x0, " "
	DCB	0x0, "V", 0x0, "i", 0x0, "r", 0x0, "t", 0x0, "u", 0x0, "a"
	DCB	0x0, "l", 0x0, "A", 0x0, "l", 0x0, "l", 0x0, "o", 0x0, "c"
	DCB	0x0, "E", 0x0, "x", 0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i"
	DCB	0x0, "l", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "f", 0x0, "o"
	DCB	0x0, "r", 0x0, " ", 0x0, "s", 0x0, "i", 0x0, "z", 0x0, "e"
	DCB	0x0, " ", 0x0, "%", 0x0, "#", 0x0, "l", 0x0, "x", 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IM@MAGACGEM@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "m", 0x0, "a", 0x0, "p", 0x0, "A", 0x0, "d", 0x0, "d"
	DCB	0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "a", 0x0, "l"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, "a", 0x0, "t", 0x0, "e"
	DCB	0x0, " ", 0x0, "M", 0x0, "a", 0x0, "p", 0x0, "p", 0x0, "e"
	DCB	0x0, "d", 0x0, "_", 0x0, "b", 0x0, "u", 0x0, "f", 0x0, "f"
	DCB	0x0, "e", 0x0, "r", 0x0, " ", 0x0, "l", 0x0, "i", 0x0, "s"
	DCB	0x0, "t", 0x0, " ", 0x0, "e", 0x0, "n", 0x0, "t", 0x0, "r"
	DCB	0x0, "y", 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy
; File i:\library\trees\winceutils\winceutils-b01x\src\ti\sdo\winceutils\cmem\drivers\cmemk.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |mapAddress| PROC

; 1869 : {

  00000		 |$LN16@mapAddress|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M41419|
  00008	e1a07002	 mov         r7, r2
  0000c	e1a06001	 mov         r6, r1
  00010	e1a08000	 mov         r8, r0

; 1870 :     PHYSICAL_ADDRESS    pa;
; 1871 :     PVOID               pv;
; 1872 :     PVOID               pUsrVA;
; 1873 :     Mapped_buffer      *entry;
; 1874 :     BOOL                retVal;
; 1875 : 
; 1876 : 
; 1877 :     entry = (Mapped_buffer *)malloc(sizeof(Mapped_buffer));

  00014	e3a00024	 mov         r0, #0x24
  00018	eb000000	 bl          malloc
  0001c	e1b05000	 movs        r5, r0

; 1878 :     if (entry == NULL) {

  00020	1a000003	 bne         |$LN7@mapAddress|

; 1879 :         __E("mapAddress: Failed to allocate Mapped_buffer list entry\n");

  00024	e59f0124	 ldr         r0, [pc, #0x124]
  00028	eb000000	 bl          NKDbgPrintfW

; 1880 :         return (0);

  0002c	e3a04000	 mov         r4, #0
  00030	ea00003e	 b           |$LN8@mapAddress|
  00034		 |$LN7@mapAddress|

; 1881 :     }
; 1882 : 
; 1883 :     /* Reserve a block of virtual memory for the calling process. */
; 1884 :     pUsrVA = VirtualAllocEx((HANDLE)dwProcId, NULL, size, MEM_RESERVE,
; 1885 :             PAGE_READWRITE | PAGE_NOCACHE);

  00034	e3a0af81	 mov         r10, #0x81, 30
  00038	e3a03a02	 mov         r3, #2, 20
  0003c	e1a02006	 mov         r2, r6
  00040	e3a01000	 mov         r1, #0
  00044	e1a00007	 mov         r0, r7
  00048	e58da000	 str         r10, [sp]
  0004c	eb000000	 bl          VirtualAllocEx
  00050	e1b04000	 movs        r4, r0

; 1886 : 
; 1887 :     if (pUsrVA == NULL) {

  00054	1a000004	 bne         |$LN6@mapAddress|

; 1888 :         __E("mapAddress: VirtualAllocEx failed for size %#lx\n", size);

  00058	e59f00ec	 ldr         r0, [pc, #0xEC]
  0005c	e1a01006	 mov         r1, r6
  00060	eb000000	 bl          NKDbgPrintfW
  00064	e3a04000	 mov         r4, #0
  00068	ea000030	 b           |$LN8@mapAddress|
  0006c		 |$LN6@mapAddress|

; 1889 :         return (0);
; 1890 :     }
; 1891 : 
; 1892 :     /* Map physAddr to kernal virtual address, non-cached */
; 1893 :     pa.QuadPart = physAddr;

  0006c	e3a01000	 mov         r1, #0

; 1894 :     pv = MmMapIoSpace(pa, size, FALSE);

  00070	e3a03000	 mov         r3, #0
  00074	e1a02006	 mov         r2, r6
  00078	e1a00008	 mov         r0, r8
  0007c	eb000000	 bl          MmMapIoSpace
  00080	e1b09000	 movs        r9, r0

; 1895 : 
; 1896 :     if (pv == NULL) {

  00084	1a000009	 bne         |$LN5@mapAddress|

; 1897 :         __E("mapAddress: MmMapIoSpace failed for address %#lx\n", physAddr);

  00088	e59f00b8	 ldr         r0, [pc, #0xB8]
  0008c	e1a01008	 mov         r1, r8
  00090	eb000000	 bl          NKDbgPrintfW
  00094		 |$LN13@mapAddress|

; 1898 :         VirtualFreeEx((HANDLE)dwProcId, pUsrVA, 0, MEM_RELEASE);

  00094	e3a03902	 mov         r3, #2, 18
  00098	e3a02000	 mov         r2, #0
  0009c	e1a01004	 mov         r1, r4
  000a0	e1a00007	 mov         r0, r7
  000a4	eb000000	 bl          VirtualFreeEx
  000a8	e3a04000	 mov         r4, #0
  000ac	ea00001f	 b           |$LN8@mapAddress|
  000b0		 |$LN5@mapAddress|

; 1899 :         return (0);
; 1900 :     }
; 1901 : 
; 1902 :     /* Map the kernel virtual address to caller's virtual address */
; 1903 :     retVal = VirtualCopyEx((HANDLE)dwProcId, pUsrVA,
; 1904 :             (HANDLE)GetCurrentProcessId(), pv, size,
; 1905 :             PAGE_READWRITE | PAGE_NOCACHE);

  000b0	e3a0000c	 mov         r0, #0xC
  000b4	eb000000	 bl          __GetUserKData
  000b8	e1a02000	 mov         r2, r0
  000bc	e1a00007	 mov         r0, r7
  000c0	e1a03009	 mov         r3, r9
  000c4	e1a01004	 mov         r1, r4
  000c8	e58da004	 str         r10, [sp, #4]
  000cc	e58d6000	 str         r6, [sp]
  000d0	eb000000	 bl          VirtualCopyEx
  000d4	e3500000	 cmp         r0, #0

; 1906 : 
; 1907 :     if (retVal == FALSE) {

  000d8	1a000007	 bne         |$LN4@mapAddress|

; 1908 :         __E("mapAddress: VirtualCopyEx failed\n");

  000dc	e59f0060	 ldr         r0, [pc, #0x60]
  000e0	eb000000	 bl          NKDbgPrintfW

; 1909 :         free(entry);

  000e4	e1a00005	 mov         r0, r5
  000e8	eb000000	 bl          free

; 1910 :         MmUnmapIoSpace(pv, size);        

  000ec	e1a01006	 mov         r1, r6
  000f0	e1a00009	 mov         r0, r9
  000f4	eb000000	 bl          MmUnmapIoSpace

; 1911 :         VirtualFreeEx((HANDLE)dwProcId, pUsrVA, 0, MEM_RELEASE);
; 1912 :         return (0);

  000f8	eaffffe5	 b           |$LN13@mapAddress|
  000fc		 |$LN4@mapAddress|

; 1913 :     }
; 1914 : 
; 1915 :     /* Add mapped buffer info to list */
; 1916 :     entry->id = 0;
; 1917 :     entry->physp = physAddr;
; 1918 :     entry->flags = 0;       /* ?? */
; 1919 :     entry->kvirtp = (PVOID)pv;
; 1920 :     entry->size = size;
; 1921 :     entry->pUsrVA = pUsrVA;
; 1922 :     entry->dwUsrProcId = dwProcId;
; 1923 : 
; 1924 :     InsertTailList(&mappedBufferList, &entry->element);

  000fc	e59f203c	 ldr         r2, [pc, #0x3C]
  00100	e3a03000	 mov         r3, #0
  00104	e285c008	 add         r12, r5, #8
  00108	e88c0108	 stmia       r12, {r3, r8}
  0010c	e285c010	 add         r12, r5, #0x10
  00110	e88c0208	 stmia       r12, {r3, r9}
  00114	e5856018	 str         r6, [r5, #0x18]
  00118	e285c01c	 add         r12, r5, #0x1C
  0011c	e88c0090	 stmia       r12, {r4, r7}
  00120	e5923004	 ldr         r3, [r2, #4]
  00124	e885000c	 stmia       r5, {r2, r3}

; 1925 : 
; 1926 :     return ((unsigned long)pUsrVA);

  00128	e5835000	 str         r5, [r3]
  0012c	e5825004	 str         r5, [r2, #4]
  00130		 |$LN8@mapAddress|

; 1927 : }

  00130	e1a00004	 mov         r0, r4
  00134	e28dd008	 add         sp, sp, #8
  00138	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  0013c	e12fff1e	 bx          lr
  00140		 |$LN17@mapAddress|
  00140		 |$LN18@mapAddress|
  00140	00000000	 DCD         |mappedBufferList|
  00144		 |$LN19@mapAddress|
  00144	00000000	 DCD         |??_C@_1FO@JPKAAJLM@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAV?$AAi?$AAr?$AAt?$AAu?$AAa?$AAl@|
  00148		 |$LN20@mapAddress|
  00148	00000000	 DCD         |??_C@_1HO@HEJCJEEM@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAM?$AAm?$AAM?$AAa?$AAp?$AAI?$AAo@|
  0014c		 |$LN21@mapAddress|
  0014c	00000000	 DCD         |??_C@_1HM@FPLHNBAD@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAV?$AAi?$AAr?$AAt?$AAu?$AAa?$AAl@|
  00150		 |$LN22@mapAddress|
  00150	00000000	 DCD         |??_C@_1IM@MAGACGEM@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5@|
  00154		 |$M41420|

			 ENDP  ; |mapAddress|

	EXPORT	|??_C@_1GC@BHAKEIBM@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAu?$AAn?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAV?$AAi?$AAr?$AAt?$AAu@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HE@HLGKHAFC@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAu?$AAn?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T41446| DCD	|$LN18@unmapAddre|
	DCD	0x40003401

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GC@BHAKEIBM@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAu?$AAn?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAV?$AAi?$AAr?$AAt?$AAu@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "u", 0x0, "n", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "A"
	DCB	0x0, "d", 0x0, "d", 0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s"
	DCB	0x0, ":", 0x0, " ", 0x0, "V", 0x0, "i", 0x0, "r", 0x0, "t"
	DCB	0x0, "u", 0x0, "a", 0x0, "l", 0x0, "F", 0x0, "r", 0x0, "e"
	DCB	0x0, "e", 0x0, "E", 0x0, "x", 0x0, " ", 0x0, "f", 0x0, "a"
	DCB	0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HE@HLGKHAFC@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAu?$AAn?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "u", 0x0, "n", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "A"
	DCB	0x0, "d", 0x0, "d", 0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s"
	DCB	0x0, ":", 0x0, " ", 0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l"
	DCB	0x0, "e", 0x0, "d", 0x0, " ", 0x0, "t", 0x0, "o", 0x0, " "
	DCB	0x0, "f", 0x0, "i", 0x0, "n", 0x0, "d", 0x0, " ", 0x0, "m"
	DCB	0x0, "a", 0x0, "p", 0x0, "p", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "b", 0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r"
	DCB	0x0, "!", 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |unmapAddress| PROC

; 1933 : {

  00000		 |$LN18@unmapAddre|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M41443|
  00004	e1a06002	 mov         r6, r2
  00008	e1a07000	 mov         r7, r0

; 1934 :     Mapped_buffer      *entry;
; 1935 :     LIST_ENTRY         *listp;
; 1936 :     LIST_ENTRY         *e;
; 1937 : 
; 1938 : 
; 1939 :     listp = &mappedBufferList;
; 1940 : 
; 1941 :     for (e = listp->Flink; e != listp; e = e->Flink) {

  0000c	e59fe0b8	 ldr         lr, [pc, #0xB8]
  00010	e59e4000	 ldr         r4, [lr]
  00014	e154000e	 cmp         r4, lr
  00018	0a000024	 beq         |$LN15@unmapAddre|
  0001c		 |$LL9@unmapAddre|

; 1942 :         entry = CONTAINING_RECORD(e, struct Mapped_buffer, element);
; 1943 : 
; 1944 :         if ((entry->pUsrVA == pUsrVA) && (entry->dwUsrProcId == dwProcId)) {

  0001c	e594301c	 ldr         r3, [r4, #0x1C]
  00020	e1a05004	 mov         r5, r4
  00024	e1530007	 cmp         r3, r7
  00028	1a000002	 bne         |$LN8@unmapAddre|
  0002c	e5943020	 ldr         r3, [r4, #0x20]
  00030	e1530006	 cmp         r3, r6
  00034	0a000002	 beq         |$LN13@unmapAddre|
  00038		 |$LN8@unmapAddre|

; 1934 :     Mapped_buffer      *entry;
; 1935 :     LIST_ENTRY         *listp;
; 1936 :     LIST_ENTRY         *e;
; 1937 : 
; 1938 : 
; 1939 :     listp = &mappedBufferList;
; 1940 : 
; 1941 :     for (e = listp->Flink; e != listp; e = e->Flink) {

  00038	e5944000	 ldr         r4, [r4]
  0003c	e154000e	 cmp         r4, lr
  00040	1afffff5	 bne         |$LL9@unmapAddre|
  00044		 |$LN13@unmapAddre|

; 1945 :             break;
; 1946 :         }
; 1947 :     }
; 1948 : 
; 1949 :     if (e == listp) {

  00044	e154000e	 cmp         r4, lr
  00048	0a000018	 beq         |$LN15@unmapAddre|

; 1952 :     }
; 1953 : 
; 1954 :     MmUnmapIoSpace((PVOID)entry->kvirtp, size);

  0004c	e5950014	 ldr         r0, [r5, #0x14]
  00050	eb000000	 bl          MmUnmapIoSpace

; 1955 : 
; 1956 :     if (!VirtualFreeEx((HANDLE)dwProcId, (LPVOID)pUsrVA, 0, MEM_RELEASE)) {

  00054	e3a03902	 mov         r3, #2, 18
  00058	e3a02000	 mov         r2, #0
  0005c	e1a01007	 mov         r1, r7
  00060	e1a00006	 mov         r0, r6
  00064	eb000000	 bl          VirtualFreeEx
  00068	e3500000	 cmp         r0, #0
  0006c	1a000004	 bne         |$LN3@unmapAddre|

; 1957 :         __E("unmapAddress: VirtualFreeEx failed\n");

  00070	e59f0050	 ldr         r0, [pc, #0x50]
  00074	eb000000	 bl          NKDbgPrintfW

; 1958 :         return (-2);

  00078	e3e00001	 mvn         r0, #1

; 1965 : }

  0007c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$LN3@unmapAddre|

; 1959 :     }
; 1960 : 
; 1961 :     RemoveEntryList(e);

  00084	e5942004	 ldr         r2, [r4, #4]
  00088	e5943000	 ldr         r3, [r4]

; 1962 :     free(entry);

  0008c	e1a00005	 mov         r0, r5
  00090	e5823000	 str         r3, [r2]
  00094	e5942000	 ldr         r2, [r4]
  00098	e5943004	 ldr         r3, [r4, #4]
  0009c	e5823004	 str         r3, [r2, #4]
  000a0	eb000000	 bl          free

; 1963 : 
; 1964 :     return (0);

  000a4	e3a00000	 mov         r0, #0

; 1965 : }

  000a8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$LN15@unmapAddre|

; 1950 :         __E("unmapAddress: Failed to find mapped buffer!\n");

  000b0	e59f000c	 ldr         r0, [pc, #0xC]
  000b4	eb000000	 bl          NKDbgPrintfW

; 1951 :         return (-1);

  000b8	e3e00000	 mvn         r0, #0

; 1965 : }

  000bc	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$LN19@unmapAddre|
  000c4		 |$LN20@unmapAddre|
  000c4	00000000	 DCD         |??_C@_1HE@HLGKHAFC@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAu?$AAn?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe@|
  000c8		 |$LN21@unmapAddre|
  000c8	00000000	 DCD         |??_C@_1GC@BHAKEIBM@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAu?$AAn?$AAm?$AAa?$AAp?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AAV?$AAi?$AAr?$AAt?$AAu@|
  000cc		 |$LN22@unmapAddre|
  000cc	00000000	 DCD         |mappedBufferList|
  000d0		 |$M41444|

			 ENDP  ; |unmapAddress|

	EXPORT	|CMK_IOControl|
	EXPORT	|??_C@_1EM@MJEFGDHI@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?5?$AAr?$AAe?$AAc?$AAe?$AAi@| [ DATA ] ; `string'
	EXPORT	|??_C@_1IC@BMAEIIKN@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAU?$AAN?$AAM?$AAA?$AAP?$AAA?$AAD?$AAD?$AAR?$AAE?$AAS?$AAS?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HM@PINJBPBF@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAM?$AAA?$AAP?$AAA?$AAD?$AAD?$AAR?$AAE?$AAS?$AAS?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GM@ONIPBDBF@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAM?$AAA?$AAP?$AAA?$AAD?$AAD?$AAR?$AAE?$AAS?$AAS?$AA?3?$AA?5?$AAW?$AAa?$AAi?$AAt?$AAF?$AAo?$AAr@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GE@ODKFOIGO@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAf?$AAi?$AAn?$AAd?$AA?5?$AAa?$AA?5?$AAp?$AAo@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GC@JHLICFOL@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAG?$AAE?$AAT?$AAS?$AAI?$AAZ?$AAE?$AA?3?$AA?5?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAo@| [ DATA ] ; `string'
	EXPORT	|??_C@_1IG@EKDDKMDK@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAG?$AAE?$AAT?$AAP?$AAH?$AAY?$AAS?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FI@PDOJBEOL@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAf?$AAr?$AAe?$AAe?$AA?5?$AAm?$AAe?$AAm?$AAo@| [ DATA ] ; `string'
	EXPORT	|??_C@_1JC@KNEBIOIE@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAR?$AAE?$AAE?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo@| [ DATA ] ; `string'
	EXPORT	|??_C@_04DGHHAJMG@HEAP?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_04KNJFKMFD@PHYS?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_1GC@NHBEENPF@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAA?$AAL?$AAL?$AAO?$AAC?$AA?$CF?$AAs?$AA?3?$AA?5?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAo@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HE@ECHHIHNI@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAA?$AAL?$AAL?$AAO?$AAC?$AA?$CF?$AAs?$AA?3?$AA?5?$AAV?$AAi?$AAr?$AAt?$AAu?$AAa?$AAl?$AAC?$AAo?$AAp@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HK@NMPGNINP@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAA?$AAL?$AAL?$AAO?$AAC?$AA?$CF?$AAs?$AA?3?$AA?5?$AAN?$AAo?$AA?5?$AAf?$AAr?$AAe?$AAe?$AA?5?$AAb?$AAu@| [ DATA ] ; `string'
	EXPORT	|??_C@_00CNPNBAHC@?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_06HAMDABMN@CACHED?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_1IC@IKJLIPKE@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?3?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAm?$AAa@| [ DATA ] ; `string'
	EXPORT	|??_C@_1IA@DGANCHDM@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?3?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAa?$AAl@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GO@HIHOKAPN@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?3?$AA?5?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAb?$AAl?$AAo?$AAc@| [ DATA ] ; `string'
	IMPORT	|CacheRangeFlush|
	IMPORT	|GetLastError|
	IMPORT	|ReleaseMutex|
	IMPORT	|WaitForSingleObject|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T41569| DCD	|$LN167@CMK_IOCont|
	DCD	0x40026e02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EM@MJEFGDHI@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?5?$AAr?$AAe?$AAc?$AAe?$AAi@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "U", 0x0, "n", 0x0, "k", 0x0, "n", 0x0, "o", 0x0, "w"
	DCB	0x0, "n", 0x0, " ", 0x0, "i", 0x0, "o", 0x0, "c", 0x0, "t"
	DCB	0x0, "l", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "c", 0x0, "e"
	DCB	0x0, "i", 0x0, "v", 0x0, "e", 0x0, "d", 0x0, ".", 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IC@BMAEIIKN@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAU?$AAN?$AAM?$AAA?$AAP?$AAA?$AAD?$AAD?$AAR?$AAE?$AAS?$AAS?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "U", 0x0, "N", 0x0, "M", 0x0, "A", 0x0, "P", 0x0, "A"
	DCB	0x0, "D", 0x0, "D", 0x0, "R", 0x0, "E", 0x0, "S", 0x0, "S"
	DCB	0x0, ":", 0x0, " ", 0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l"
	DCB	0x0, "e", 0x0, "d", 0x0, " ", 0x0, "t", 0x0, "o", 0x0, " "
	DCB	0x0, "u", 0x0, "n", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, " "
	DCB	0x0, "v", 0x0, "i", 0x0, "r", 0x0, "t", 0x0, "u", 0x0, "a"
	DCB	0x0, "l", 0x0, " ", 0x0, "a", 0x0, "d", 0x0, "d", 0x0, "r"
	DCB	0x0, "e", 0x0, "s", 0x0, "s", 0x0, " ", 0x0, "%", 0x0, "#"
	DCB	0x0, "l", 0x0, "x", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@PINJBPBF@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAM?$AAA?$AAP?$AAA?$AAD?$AAD?$AAR?$AAE?$AAS?$AAS?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "M", 0x0, "A", 0x0, "P", 0x0, "A", 0x0, "D", 0x0, "D"
	DCB	0x0, "R", 0x0, "E", 0x0, "S", 0x0, "S", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "m", 0x0, "a"
	DCB	0x0, "p", 0x0, " ", 0x0, "p", 0x0, "h", 0x0, "y", 0x0, "s"
	DCB	0x0, "i", 0x0, "c", 0x0, "a", 0x0, "l", 0x0, " ", 0x0, "a"
	DCB	0x0, "d", 0x0, "d", 0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s"
	DCB	0x0, " ", 0x0, "%", 0x0, "#", 0x0, "l", 0x0, "x", 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GM@ONIPBDBF@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAM?$AAA?$AAP?$AAA?$AAD?$AAD?$AAR?$AAE?$AAS?$AAS?$AA?3?$AA?5?$AAW?$AAa?$AAi?$AAt?$AAF?$AAo?$AAr@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "M", 0x0, "A", 0x0, "P", 0x0, "A", 0x0, "D", 0x0, "D"
	DCB	0x0, "R", 0x0, "E", 0x0, "S", 0x0, "S", 0x0, ":", 0x0, " "
	DCB	0x0, "W", 0x0, "a", 0x0, "i", 0x0, "t", 0x0, "F", 0x0, "o"
	DCB	0x0, "r", 0x0, "S", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, "l"
	DCB	0x0, "e", 0x0, "O", 0x0, "b", 0x0, "j", 0x0, "e", 0x0, "c"
	DCB	0x0, "t", 0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l"
	DCB	0x0, "e", 0x0, "d", 0x0, "!", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GE@ODKFOIGO@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAf?$AAi?$AAn?$AAd?$AA?5?$AAa?$AA?5?$AAp?$AAo@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "f", 0x0, "i"
	DCB	0x0, "n", 0x0, "d", 0x0, " ", 0x0, "a", 0x0, " ", 0x0, "p"
	DCB	0x0, "o", 0x0, "o", 0x0, "l", 0x0, " ", 0x0, "w", 0x0, "h"
	DCB	0x0, "i", 0x0, "c", 0x0, "h", 0x0, " ", 0x0, "f", 0x0, "i"
	DCB	0x0, "t", 0x0, "s", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GC@JHLICFOL@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAG?$AAE?$AAT?$AAS?$AAI?$AAZ?$AAE?$AA?3?$AA?5?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAo@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "G", 0x0, "E", 0x0, "T", 0x0, "S", 0x0, "I", 0x0, "Z"
	DCB	0x0, "E", 0x0, ":", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, "v"
	DCB	0x0, "a", 0x0, "l", 0x0, "i", 0x0, "d", 0x0, " ", 0x0, "p"
	DCB	0x0, "o", 0x0, "o", 0x0, "l", 0x0, " ", 0x0, "(", 0x0, "%"
	DCB	0x0, "d", 0x0, ")", 0x0, " ", 0x0, "p", 0x0, "a", 0x0, "s"
	DCB	0x0, "s", 0x0, "e", 0x0, "d", 0x0, ".", 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IG@EKDDKMDK@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAG?$AAE?$AAT?$AAP?$AAH?$AAY?$AAS?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "G", 0x0, "E", 0x0, "T", 0x0, "P", 0x0, "H", 0x0, "Y"
	DCB	0x0, "S", 0x0, ":", 0x0, " ", 0x0, "F", 0x0, "a", 0x0, "i"
	DCB	0x0, "l", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "t", 0x0, "o"
	DCB	0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n", 0x0, "v", 0x0, "e"
	DCB	0x0, "r", 0x0, "t", 0x0, " ", 0x0, "v", 0x0, "i", 0x0, "r"
	DCB	0x0, "t", 0x0, "u", 0x0, "a", 0x0, "l", 0x0, " ", 0x0, "%"
	DCB	0x0, "#", 0x0, "l", 0x0, "x", 0x0, " ", 0x0, "t", 0x0, "o"
	DCB	0x0, " ", 0x0, "p", 0x0, "h", 0x0, "y", 0x0, "s", 0x0, "i"
	DCB	0x0, "c", 0x0, "a", 0x0, "l", 0x0, ".", 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@PDOJBEOL@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAf?$AAr?$AAe?$AAe?$AA?5?$AAm?$AAe?$AAm?$AAo@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "f", 0x0, "r"
	DCB	0x0, "e", 0x0, "e", 0x0, " ", 0x0, "m", 0x0, "e", 0x0, "m"
	DCB	0x0, "o", 0x0, "r", 0x0, "y", 0x0, " ", 0x0, "a", 0x0, "t"
	DCB	0x0, " ", 0x0, "%", 0x0, "#", 0x0, "l", 0x0, "x", 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JC@KNEBIOIE@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAR?$AAE?$AAE?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "F", 0x0, "R", 0x0, "E", 0x0, "E", 0x0, "%", 0x0, "s"
	DCB	0x0, "%", 0x0, "s", 0x0, ":", 0x0, " ", 0x0, "F", 0x0, "a"
	DCB	0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "t"
	DCB	0x0, "o", 0x0, " ", 0x0, "f", 0x0, "r", 0x0, "e", 0x0, "e"
	DCB	0x0, " ", 0x0, "b", 0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e"
	DCB	0x0, "r", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, " ", 0x0, "f"
	DCB	0x0, "r", 0x0, "o", 0x0, "m", 0x0, " ", 0x0, "p", 0x0, "o"
	DCB	0x0, "o", 0x0, "l", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, " "
	DCB	0x0, "-", 0x0, " ", 0x0, "e", 0x0, "r", 0x0, "r", 0x0, "o"
	DCB	0x0, "r", 0x0, ":", 0x0, "%", 0x0, "d", 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_04DGHHAJMG@HEAP?$AA@| DCB "HEAP", 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_04KNJFKMFD@PHYS?$AA@| DCB "PHYS", 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GC@NHBEENPF@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAA?$AAL?$AAL?$AAO?$AAC?$AA?$CF?$AAs?$AA?3?$AA?5?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAo@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "A", 0x0, "L", 0x0, "L", 0x0, "O", 0x0, "C", 0x0, "%"
	DCB	0x0, "s", 0x0, ":", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, "v"
	DCB	0x0, "a", 0x0, "l", 0x0, "i", 0x0, "d", 0x0, " ", 0x0, "p"
	DCB	0x0, "o", 0x0, "o", 0x0, "l", 0x0, " ", 0x0, "(", 0x0, "%"
	DCB	0x0, "d", 0x0, ")", 0x0, " ", 0x0, "p", 0x0, "a", 0x0, "s"
	DCB	0x0, "s", 0x0, "e", 0x0, "d", 0x0, ".", 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HE@ECHHIHNI@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAA?$AAL?$AAL?$AAO?$AAC?$AA?$CF?$AAs?$AA?3?$AA?5?$AAV?$AAi?$AAr?$AAt?$AAu?$AAa?$AAl?$AAC?$AAo?$AAp@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "A", 0x0, "L", 0x0, "L", 0x0, "O", 0x0, "C", 0x0, "%"
	DCB	0x0, "s", 0x0, ":", 0x0, " ", 0x0, "V", 0x0, "i", 0x0, "r"
	DCB	0x0, "t", 0x0, "u", 0x0, "a", 0x0, "l", 0x0, "C", 0x0, "o"
	DCB	0x0, "p", 0x0, "y", 0x0, "E", 0x0, "x", 0x0, "(", 0x0, ")"
	DCB	0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e"
	DCB	0x0, "d", 0x0, " ", 0x0, "f", 0x0, "o", 0x0, "r", 0x0, " "
	DCB	0x0, "p", 0x0, "o", 0x0, "o", 0x0, "l", 0x0, " ", 0x0, "%"
	DCB	0x0, "d", 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HK@NMPGNINP@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAA?$AAL?$AAL?$AAO?$AAC?$AA?$CF?$AAs?$AA?3?$AA?5?$AAN?$AAo?$AA?5?$AAf?$AAr?$AAe?$AAe?$AA?5?$AAb?$AAu@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "A", 0x0, "L", 0x0, "L", 0x0, "O", 0x0, "C", 0x0, "%"
	DCB	0x0, "s", 0x0, ":", 0x0, " ", 0x0, "N", 0x0, "o", 0x0, " "
	DCB	0x0, "f", 0x0, "r", 0x0, "e", 0x0, "e", 0x0, " ", 0x0, "b"
	DCB	0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, "s"
	DCB	0x0, " ", 0x0, "a", 0x0, "v", 0x0, "a", 0x0, "i", 0x0, "l"
	DCB	0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e", 0x0, " ", 0x0, "f"
	DCB	0x0, "o", 0x0, "r", 0x0, " ", 0x0, "p", 0x0, "o", 0x0, "o"
	DCB	0x0, "l", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_00CNPNBAHC@?$AA@| DCB 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_06HAMDABMN@CACHED?$AA@| DCB "CACHED", 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IC@IKJLIPKE@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?3?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAm?$AAa@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "i", 0x0, "o", 0x0, "c", 0x0, "t", 0x0, "l", 0x0, ":"
	DCB	0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e"
	DCB	0x0, "d", 0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "m"
	DCB	0x0, "a", 0x0, "l", 0x0, "l", 0x0, "o", 0x0, "c", 0x0, " "
	DCB	0x0, "p", 0x0, "o", 0x0, "o", 0x0, "l", 0x0, "_", 0x0, "b"
	DCB	0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "s", 0x0, "t", 0x0, "r", 0x0, "u", 0x0, "c", 0x0, "t"
	DCB	0x0, " ", 0x0, "f", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "h"
	DCB	0x0, "e", 0x0, "a", 0x0, "p", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IA@DGANCHDM@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?3?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAa?$AAl@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "i", 0x0, "o", 0x0, "c", 0x0, "t", 0x0, "l", 0x0, ":"
	DCB	0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e"
	DCB	0x0, "d", 0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "a"
	DCB	0x0, "l", 0x0, "l", 0x0, "o", 0x0, "c", 0x0, "a", 0x0, "t"
	DCB	0x0, "e", 0x0, " ", 0x0, "h", 0x0, "e", 0x0, "a", 0x0, "p"
	DCB	0x0, " ", 0x0, "b", 0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e"
	DCB	0x0, "r", 0x0, " ", 0x0, "o", 0x0, "f", 0x0, " ", 0x0, "s"
	DCB	0x0, "i", 0x0, "z", 0x0, "e", 0x0, " ", 0x0, "%", 0x0, "#"
	DCB	0x0, "x", 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GO@HIHOKAPN@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?3?$AA?5?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAb?$AAl?$AAo?$AAc@| DCB "C"
	DCB	0x0, "M", 0x0, "E", 0x0, "M", 0x0, "K", 0x0, " ", 0x0, "E"
	DCB	0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, ":", 0x0, " "
	DCB	0x0, "i", 0x0, "o", 0x0, "c", 0x0, "t", 0x0, "l", 0x0, ":"
	DCB	0x0, " ", 0x0, "i", 0x0, "n", 0x0, "v", 0x0, "a", 0x0, "l"
	DCB	0x0, "i", 0x0, "d", 0x0, " ", 0x0, "b", 0x0, "l", 0x0, "o"
	DCB	0x0, "c", 0x0, "k", 0x0, " ", 0x0, "i", 0x0, "d", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ",", 0x0, " ", 0x0, "m", 0x0, "u"
	DCB	0x0, "s", 0x0, "t", 0x0, " ", 0x0, "b", 0x0, "e", 0x0, " "
	DCB	0x0, "<", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy
; File i:\library\trees\winceutils\winceutils-b01x\src\ti\sdo\winceutils\cmem\drivers\cmemk.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CMK_IOControl| PROC

; 1231 : {

  00000		 |$LN167@CMK_IOCont|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd02c	 sub         sp, sp, #0x2C
  00008		 |$M41566|
  00008	e1a04003	 mov         r4, r3
  0000c	e1a05002	 mov         r5, r2
  00010	e1a07001	 mov         r7, r1

; 1232 : 
; 1233 :     LIST_ENTRY *freelistp = NULL;
; 1234 :     LIST_ENTRY *busylistp = NULL;
; 1235 :     LIST_ENTRY *e = NULL;
; 1236 :     struct pool_buffer *entry;
; 1237 :     unsigned long physp;
; 1238 :     unsigned long virtp, virtp_end;
; 1239 :     size_t reqsize, size, align;
; 1240 :     int delta = MAXTYPE(int);
; 1241 :     int pool = -1;
; 1242 :     int i;
; 1243 :     int bi;
; 1244 :     struct block_struct block;
; 1245 :     struct block_struct *pBlock;
; 1246 :     union CMEM_AllocUnion allocDesc;
; 1247 :     //PUCHAR pInBufSafe = NULL;
; 1248 :     union CMEM_AllocUnion *pAllocDesc;
; 1249 :     PVOID pUsrVA;
; 1250 :     DWORD dwCallerProcId;
; 1251 :     DWORD cacheFlag;
; 1252 : 
; 1253 :     switch (Ioctl & CMEM_IOCCMDMASK) {

  00014	e20700ff	 and         r0, r7, #0xFF
  00018	e2403001	 sub         r3, r0, #1
  0001c	e3a02000	 mov         r2, #0
  00020	e3e06000	 mvn         r6, #0
  00024	e353000c	 cmp         r3, #0xC
  00028	e58d2008	 str         r2, [sp, #8]
  0002c	e3e0a102	 mvn         r10, #2, 2
  00030	e58d600c	 str         r6, [sp, #0xC]
  00034	8a000242	 bhi         |$LN1@CMK_IOCont|
  00038	e1a00083	 mov         r0, r3, lsl #1
  0003c	e080000f	 add         r0, r0, pc
  00040	e1d000b4	 ldrh        r0, [r0, #4]
  00044	e08ff000	 add         pc, pc, r0
  00048		 |$LN151@CMK_IOCont|
  00048		 |$LN150@CMK_IOCont|
  00048		 |$LN152@CMK_IOCont|
  00048	01ac		 DCW         0x1ac
  0004a		 |$LN153@CMK_IOCont|
  0004a	0018		 DCW         0x18
  0004c		 |$LN154@CMK_IOCont|
  0004c	0364		 DCW         0x364
  0004e		 |$LN155@CMK_IOCont|
  0004e	0520		 DCW         0x520
  00050		 |$LN156@CMK_IOCont|
  00050	05ac		 DCW         0x5ac
  00052		 |$LN157@CMK_IOCont|
  00052	0620		 DCW         0x620
  00054		 |$LN158@CMK_IOCont|
  00054	0728		 DCW         0x728
  00056		 |$LN159@CMK_IOCont|
  00056	0790		 DCW         0x790
  00058		 |$LN160@CMK_IOCont|
  00058	07c8		 DCW         0x7c8
  0005a		 |$LN161@CMK_IOCont|
  0005a	08f8		 DCW         0x8f8
  0005c		 |$LN162@CMK_IOCont|
  0005c	07ac		 DCW         0x7ac
  0005e		 |$LN163@CMK_IOCont|
  0005e	0808		 DCW         0x808
  00060		 |$LN164@CMK_IOCont|
  00060	0884		 DCW         0x884
  00062		 |$LN192@CMK_IOCont|

; 1850 : }

  00062	0884		 DCW         0x884
  00064		 |$LN108@CMK_IOCont|

; 1254 :         case CMEM_IOCALLOCHEAP:
; 1255 :             if (!pInBuf || InBufLen < sizeof(union CMEM_AllocUnion)) {

  00064	e3550000	 cmp         r5, #0
  00068	0a000237	 beq         |$LN136@CMK_IOCont|
  0006c	e3540010	 cmp         r4, #0x10
  00070	3a000235	 bcc         |$LN136@CMK_IOCont|

; 1256 :                 return FALSE;
; 1257 :             }
; 1258 :             pAllocDesc = (union CMEM_AllocUnion*)pInBuf;
; 1259 : 
; 1260 :             size = pAllocDesc->alloc_heap_inparams.size;
; 1261 :             align = pAllocDesc->alloc_heap_inparams.align;
; 1262 :             bi = pAllocDesc->alloc_heap_inparams.blockid;

  00074	e5958008	 ldr         r8, [r5, #8]

; 1263 :             dwCallerProcId = pAllocDesc->alloc_heap_inparams.dwProcId;
; 1264 : 
; 1265 :             __D("ALLOCHEAP%s ioctl received on heap pool for block %d\n",
; 1266 :                     Ioctl & CMEM_CACHED ? "CACHED" : "", bi);
; 1267 : 
; 1268 :             if (bi >= NBLOCKS) {

  00078	e595300c	 ldr         r3, [r5, #0xC]
  0007c	e5954000	 ldr         r4, [r5]
  00080	e595a004	 ldr         r10, [r5, #4]
  00084	e3580002	 cmp         r8, #2
  00088	e58d300c	 str         r3, [sp, #0xC]
  0008c	ba000004	 blt         |$LN105@CMK_IOCont|

; 1269 :                 __E("ioctl: invalid block id %d, must be < %d\n",
; 1270 :                         bi, NBLOCKS);

  00090	e1a01008	 mov         r1, r8
  00094		 |$LN149@CMK_IOCont|
  00094	e59f0918	 ldr         r0, [pc, #0x918]
  00098	e3a02002	 mov         r2, #2
  0009c	eb000000	 bl          NKDbgPrintfW

; 1271 :                 return FALSE;

  000a0	ea000229	 b           |$LN136@CMK_IOCont|
  000a4		 |$LN105@CMK_IOCont|

; 1272 :             }
; 1273 : 
; 1274 :             if (WaitForSingleObject(cmem_mutex, INFINITE) != WAIT_OBJECT_0) {

  000a4	e59f98b8	 ldr         r9, [pc, #0x8B8]
  000a8	e1a01006	 mov         r1, r6
  000ac	e5990450	 ldr         r0, [r9, #0x450]
  000b0	eb000000	 bl          WaitForSingleObject
  000b4	e3500000	 cmp         r0, #0

; 1275 :                 return FALSE;

  000b8	1a000223	 bne         |$LN136@CMK_IOCont|

; 1276 :             }
; 1277 : 
; 1278 :             virtp = (unsigned long)HeapMem_alloc(bi, size, align, ALLOCRUN);

  000bc	e3a03000	 mov         r3, #0
  000c0	e1a0200a	 mov         r2, r10
  000c4	e1a01004	 mov         r1, r4
  000c8	e1a00008	 mov         r0, r8
  000cc	eb000000	 bl          HeapMem_alloc
  000d0	e1b0a000	 movs        r10, r0

; 1279 :             if (virtp == (unsigned long)NULL) {

  000d4	1a000005	 bne         |$LN103@CMK_IOCont|

; 1280 :                 __E("ioctl: failed to allocate heap buffer of size %#x\n",
; 1281 :                         size);

  000d8	e59f08d0	 ldr         r0, [pc, #0x8D0]
  000dc	e1a01004	 mov         r1, r4
  000e0	eb000000	 bl          NKDbgPrintfW
  000e4		 |$LN145@CMK_IOCont|

; 1282 :                 ReleaseMutex(cmem_mutex);

  000e4	e5990450	 ldr         r0, [r9, #0x450]
  000e8	eb000000	 bl          ReleaseMutex

; 1283 :                 return FALSE;

  000ec	ea000216	 b           |$LN136@CMK_IOCont|
  000f0		 |$LN103@CMK_IOCont|

; 1284 :             }
; 1285 : 
; 1286 :             entry = (pool_buffer*)malloc(sizeof(struct pool_buffer));

  000f0	e3a00024	 mov         r0, #0x24
  000f4	eb000000	 bl          malloc

; 1287 : 
; 1288 :             cacheFlag = (Ioctl & CMEM_CACHED) ? 0 : PAGE_NOCACHE;

  000f8	e3170b02	 tst         r7, #2, 22
  000fc	13a03000	 movne       r3, #0
  00100	03a03c02	 moveq       r3, #2, 24

; 1289 : 
; 1290 :             pUsrVA = VirtualAllocEx((HANDLE)dwCallerProcId, NULL, size,
; 1291 :                     MEM_RESERVE, PAGE_READWRITE | cacheFlag);

  00104	e3833004	 orr         r3, r3, #4
  00108	e1a0b000	 mov         r11, r0
  0010c	e59d000c	 ldr         r0, [sp, #0xC]
  00110	e58d3010	 str         r3, [sp, #0x10]
  00114	e58d3000	 str         r3, [sp]
  00118	e3a03a02	 mov         r3, #2, 20
  0011c	e1a02004	 mov         r2, r4
  00120	e3a01000	 mov         r1, #0
  00124	eb000000	 bl          VirtualAllocEx
  00128	e1a06000	 mov         r6, r0

; 1292 : 
; 1293 :             if (!entry || !pUsrVA ||
; 1294 :                     !VirtualCopyEx((HANDLE)dwCallerProcId, pUsrVA,
; 1295 :                             (HANDLE)GetCurrentProcessId(), (PVOID)virtp, size,
; 1296 :                             PAGE_READWRITE | cacheFlag)) {

  0012c	e35b0000	 cmp         r11, #0
  00130	0a000029	 beq         |$LN101@CMK_IOCont|
  00134	e3560000	 cmp         r6, #0
  00138	0a000027	 beq         |$LN101@CMK_IOCont|
  0013c	e3a0000c	 mov         r0, #0xC
  00140	eb000000	 bl          __GetUserKData
  00144	e59de010	 ldr         lr, [sp, #0x10]
  00148	e1a02000	 mov         r2, r0
  0014c	e59d000c	 ldr         r0, [sp, #0xC]
  00150	e1a0300a	 mov         r3, r10
  00154	e1a01006	 mov         r1, r6
  00158	e58de004	 str         lr, [sp, #4]
  0015c	e58d4000	 str         r4, [sp]
  00160	eb000000	 bl          VirtualCopyEx
  00164	e3500000	 cmp         r0, #0
  00168	0a00001b	 beq         |$LN101@CMK_IOCont|

; 1301 :             }
; 1302 : 
; 1303 :             physp = get_phys(virtp);

  0016c	e1a0000a	 mov         r0, r10
  00170	eb000000	 bl          get_phys

; 1304 : 
; 1305 :             entry->id = heap_pool[bi];

  00174	e59f37f4	 ldr         r3, [pc, #0x7F4]

; 1306 :             entry->physp = physp;
; 1307 :             entry->kvirtp = virtp;
; 1308 :             entry->size = size;
; 1309 :             entry->flags = Ioctl & ~CMEM_IOCCMDMASK;

  00178	e3c720ff	 bic         r2, r7, #0xFF
  0017c	e2831004	 add         r1, r3, #4
  00180	e7b13108	 ldr         r3, [r1, +r8, lsl #2]!
  00184	e28bc00c	 add         r12, r11, #0xC
  00188	e88c0405	 stmia       r12, {r0, r2, r10}
  0018c	e58b3008	 str         r3, [r11, #8]

; 1310 :             entry->pUsrVA = pUsrVA;
; 1311 :             entry->dwUsrProcId = dwCallerProcId;

  00190	e59d300c	 ldr         r3, [sp, #0xC]
  00194	e28bc018	 add         r12, r11, #0x18
  00198	e88c0050	 stmia       r12, {r4, r6}
  0019c	e58b3020	 str         r3, [r11, #0x20]

; 1312 : 
; 1313 :             busylistp = &p_objs[bi][heap_pool[bi]].busylist;
; 1314 :             //list_add_tail(&entry->element, busylistp);
; 1315 :             InsertTailList(busylistp, &entry->element);

  001a0	e5913000	 ldr         r3, [r1]
  001a4	e59f17d0	 ldr         r1, [pc, #0x7D0]

; 1316 : 
; 1317 :             ReleaseMutex(cmem_mutex);

  001a8	e5990450	 ldr         r0, [r9, #0x450]
  001ac	e0833388	 add         r3, r3, r8, lsl #7
  001b0	e0632183	 rsb         r2, r3, r3, lsl #3
  001b4	e2813008	 add         r3, r1, #8
  001b8	e0832102	 add         r2, r3, r2, lsl #2
  001bc	e5923004	 ldr         r3, [r2, #4]
  001c0	e88b000c	 stmia       r11, {r2, r3}
  001c4	e583b000	 str         r11, [r3]
  001c8	e582b004	 str         r11, [r2, #4]
  001cc	eb000000	 bl          ReleaseMutex
  001d0		 |$LN140@CMK_IOCont|

; 1318 : 
; 1319 :             pAllocDesc->physp = physp;
; 1320 :             pAllocDesc->virtp = (unsigned long)pUsrVA;

  001d0	e5856000	 str         r6, [r5]

; 1847 :     }
; 1848 : 
; 1849 :     return TRUE;

  001d4	e3a00001	 mov         r0, #1
  001d8	ea0001dc	 b           |$LN111@CMK_IOCont|
  001dc		 |$LN101@CMK_IOCont|

; 1297 :                 __E("ioctl: failed to malloc pool_buffer struct for heap");

  001dc	e59f07c8	 ldr         r0, [pc, #0x7C8]
  001e0	eb000000	 bl          NKDbgPrintfW

; 1298 :                 HeapMem_free(bi, (void *)virtp, size);

  001e4	e1a02004	 mov         r2, r4
  001e8	e1a0100a	 mov         r1, r10
  001ec	e1a00008	 mov         r0, r8
  001f0	eb000000	 bl          HeapMem_free

; 1299 :                 ReleaseMutex(cmem_mutex);
; 1300 :                 return FALSE;

  001f4	eaffffba	 b           |$LN145@CMK_IOCont|
  001f8		 |$LN97@CMK_IOCont|

; 1321 : 
; 1322 :             __D("ALLOCHEAP%s: allocated %#x size buffer at %#lx (phys address)\n",
; 1323 :                     Ioctl & CMEM_CACHED ? "CACHED" : "", entry->size,
; 1324 :                     entry->physp);
; 1325 : 
; 1326 :             break;
; 1327 : 
; 1328 :             /*
; 1329 :              * argp contains a pointer to an alloc descriptor coming in, and the
; 1330 :              * physical address and size of the allocated buffer when returning.
; 1331 :              */
; 1332 :         case CMEM_IOCALLOC:
; 1333 :             if (!pInBuf || InBufLen < sizeof(union CMEM_AllocUnion)) {

  001f8	e3550000	 cmp         r5, #0
  001fc	0a0001d2	 beq         |$LN136@CMK_IOCont|
  00200	e3540010	 cmp         r4, #0x10
  00204	3a0001d0	 bcc         |$LN136@CMK_IOCont|

; 1334 :                 return FALSE;
; 1335 :             }
; 1336 :             pAllocDesc = (union CMEM_AllocUnion*)pInBuf;
; 1337 : 
; 1338 :             pool = pAllocDesc->alloc_pool_inparams.poolid;
; 1339 :             bi = pAllocDesc->alloc_pool_inparams.blockid;

  00208	e5951004	 ldr         r1, [r5, #4]

; 1340 :             dwCallerProcId = pAllocDesc->alloc_pool_inparams.dwProcId;
; 1341 : 
; 1342 :             __D("ALLOC%s ioctl received on pool %d for memory block %d\n",
; 1343 :                     Ioctl & CMEM_CACHED ? "CACHED" : "", pool, bi);
; 1344 : 
; 1345 :             if (bi >= NBLOCKS) {

  0020c	e5958000	 ldr         r8, [r5]
  00210	e595b008	 ldr         r11, [r5, #8]
  00214	e3510002	 cmp         r1, #2

; 1346 :                 __E("ioctl: invalid block id %d, must be < %d\n",
; 1347 :                         bi, NBLOCKS);
; 1348 :                 return FALSE;

  00218	aaffff9d	 bge         |$LN149@CMK_IOCont|

; 1349 :             }
; 1350 : 
; 1351 :             if (pool >= npools[bi] || pool < 0) {

  0021c	e59f9740	 ldr         r9, [pc, #0x740]
  00220	e2893038	 add         r3, r9, #0x38
  00224	e7933101	 ldr         r3, [r3, +r1, lsl #2]
  00228	e1580003	 cmp         r8, r3
  0022c	aa000058	 bge         |$LN92@CMK_IOCont|
  00230	e3580000	 cmp         r8, #0
  00234	4a000056	 bmi         |$LN92@CMK_IOCont|

; 1354 :                 return FALSE;
; 1355 :             }
; 1356 : 
; 1357 :             freelistp = &p_objs[bi][pool].freelist;

  00238	e59f273c	 ldr         r2, [pc, #0x73C]
  0023c	e0883381	 add         r3, r8, r1, lsl #7
  00240	e0631183	 rsb         r1, r3, r3, lsl #3

; 1358 :             busylistp = &p_objs[bi][pool].busylist;
; 1359 : 
; 1360 :             if (WaitForSingleObject(cmem_mutex, INFINITE) != WAIT_OBJECT_0) {

  00244	e5990450	 ldr         r0, [r9, #0x450]
  00248	e2823008	 add         r3, r2, #8
  0024c	e0833101	 add         r3, r3, r1, lsl #2
  00250	e58d1010	 str         r1, [sp, #0x10]
  00254	e082a101	 add         r10, r2, r1, lsl #2
  00258	e1a01006	 mov         r1, r6
  0025c	e58d3008	 str         r3, [sp, #8]
  00260	eb000000	 bl          WaitForSingleObject
  00264	e3500000	 cmp         r0, #0

; 1361 :                 return FALSE;

  00268	1a0001b7	 bne         |$LN136@CMK_IOCont|

; 1362 :             }
; 1363 : 
; 1364 :             e = freelistp->Flink;

  0026c	e59a4000	 ldr         r4, [r10]

; 1365 :             if (e == freelistp) {

  00270	e154000a	 cmp         r4, r10
  00274	1a000006	 bne         |$LN90@CMK_IOCont|

; 1366 :                 __E("ALLOC%s: No free buffers available for pool %d\n",
; 1367 :                         Ioctl & CMEM_CACHED ? "CACHED" : "", pool);

  00278	e3170b02	 tst         r7, #2, 22
  0027c	159f171c	 ldrne       r1, [pc, #0x71C]
  00280	059f1710	 ldreq       r1, [pc, #0x710]
  00284	e59f071c	 ldr         r0, [pc, #0x71C]
  00288		 |$LN148@CMK_IOCont|
  00288	e1a02008	 mov         r2, r8
  0028c	eb000000	 bl          NKDbgPrintfW

; 1368 :                 ReleaseMutex(cmem_mutex);
; 1369 :                 return FALSE;

  00290	eaffff93	 b           |$LN145@CMK_IOCont|
  00294		 |$LN90@CMK_IOCont|

; 1370 :             }
; 1371 :             entry = CONTAINING_RECORD(e, struct pool_buffer, element);
; 1372 : 
; 1373 :             cacheFlag = (Ioctl & CMEM_CACHED) ? 0 : PAGE_NOCACHE;
; 1374 : 
; 1375 :             pAllocDesc->alloc_pool_outparams.physp = entry->physp;
; 1376 :             pAllocDesc->alloc_pool_outparams.size = p_objs[bi][pool].size;

  00294	e59f16e0	 ldr         r1, [pc, #0x6E0]
  00298	e59d0010	 ldr         r0, [sp, #0x10]
  0029c	e594300c	 ldr         r3, [r4, #0xC]
  002a0	e217ab02	 ands        r10, r7, #2, 22
  002a4	13a02000	 movne       r2, #0
  002a8	03a02c02	 moveq       r2, #2, 24
  002ac	e0810100	 add         r0, r1, r0, lsl #2

; 1377 : 
; 1378 :             pUsrVA = VirtualAllocEx((HANDLE)dwCallerProcId, NULL,
; 1379 :                     p_objs[bi][pool].size, MEM_RESERVE,
; 1380 :                     PAGE_READWRITE | cacheFlag);

  002b0	e382e004	 orr         lr, r2, #4
  002b4	e5853000	 str         r3, [r5]
  002b8	e5902014	 ldr         r2, [r0, #0x14]
  002bc	e3a03a02	 mov         r3, #2, 20
  002c0	e3a01000	 mov         r1, #0
  002c4	e5852008	 str         r2, [r5, #8]
  002c8	e5902014	 ldr         r2, [r0, #0x14]
  002cc	e1a0000b	 mov         r0, r11
  002d0	e58de00c	 str         lr, [sp, #0xC]
  002d4	e58de000	 str         lr, [sp]
  002d8	eb000000	 bl          VirtualAllocEx
  002dc	e1b06000	 movs        r6, r0

; 1381 : 
; 1382 :             if (!pUsrVA || !VirtualCopyEx((HANDLE)dwCallerProcId, pUsrVA,
; 1383 :                         (HANDLE)GetCurrentProcessId(), (PVOID)entry->kvirtp,
; 1384 :                         p_objs[bi][pool].size,
; 1385 :                         PAGE_READWRITE | cacheFlag)) {

  002e0	0a000024	 beq         |$LN88@CMK_IOCont|
  002e4	e3a0000c	 mov         r0, #0xC
  002e8	eb000000	 bl          __GetUserKData
  002ec	e59de010	 ldr         lr, [sp, #0x10]
  002f0	e59f2684	 ldr         r2, [pc, #0x684]
  002f4	e082310e	 add         r3, r2, lr, lsl #2
  002f8	e5931014	 ldr         r1, [r3, #0x14]
  002fc	e59de00c	 ldr         lr, [sp, #0xC]
  00300	e5943014	 ldr         r3, [r4, #0x14]
  00304	e58d1000	 str         r1, [sp]
  00308	e1a02000	 mov         r2, r0
  0030c	e1a01006	 mov         r1, r6
  00310	e1a0000b	 mov         r0, r11
  00314	e58de004	 str         lr, [sp, #4]
  00318	eb000000	 bl          VirtualCopyEx
  0031c	e3500000	 cmp         r0, #0
  00320	0a000014	 beq         |$LN88@CMK_IOCont|

; 1390 :             }
; 1391 :             pAllocDesc->alloc_pool_outparams.virtp = (unsigned long)pUsrVA;
; 1392 :             entry->pUsrVA = pUsrVA;
; 1393 :             entry->dwUsrProcId = dwCallerProcId;
; 1394 :             entry->flags = Ioctl & ~CMEM_IOCCMDMASK;

  00324	e3c730ff	 bic         r3, r7, #0xFF
  00328	e5856004	 str         r6, [r5, #4]
  0032c	e5843010	 str         r3, [r4, #0x10]
  00330	e584601c	 str         r6, [r4, #0x1C]
  00334	e584b020	 str         r11, [r4, #0x20]

; 1395 : 
; 1396 :             RemoveEntryList(e);

  00338	e5942004	 ldr         r2, [r4, #4]
  0033c	e5943000	 ldr         r3, [r4]

; 1397 :             InitializeListHead(e);
; 1398 : 
; 1399 :             InsertHeadList(busylistp, e);
; 1400 : 
; 1401 :             ReleaseMutex(cmem_mutex);

  00340	e5990450	 ldr         r0, [r9, #0x450]
  00344	e5823000	 str         r3, [r2]
  00348	e5942000	 ldr         r2, [r4]
  0034c	e5943004	 ldr         r3, [r4, #4]
  00350	e5823004	 str         r3, [r2, #4]
  00354	e59d2008	 ldr         r2, [sp, #8]
  00358	e5844004	 str         r4, [r4, #4]
  0035c	e5844000	 str         r4, [r4]
  00360	e5923000	 ldr         r3, [r2]
  00364	e5843000	 str         r3, [r4]
  00368	e5842004	 str         r2, [r4, #4]
  0036c	e5834004	 str         r4, [r3, #4]
  00370	e5824000	 str         r4, [r2]

; 1402 : 
; 1403 :             __D("ALLOC%s: allocated a buffer at %#lx (phys address)\n",
; 1404 :                     Ioctl & CMEM_CACHED ? "CACHED" : "", entry->physp);
; 1405 : 
; 1406 : #ifdef __DEBUG
; 1407 :             dump_lists(bi, pool);
; 1408 : #endif
; 1409 :             break;

  00374	ea00016f	 b           |$LN137@CMK_IOCont|
  00378		 |$LN88@CMK_IOCont|

; 1386 :                 __E("ALLOC%s: VirtualCopyEx() failed for pool %d\n",
; 1387 :                         Ioctl & CMEM_CACHED ? "CACHED" : "", pool);

  00378	e35a0000	 cmp         r10, #0
  0037c	159f161c	 ldrne       r1, [pc, #0x61C]
  00380	159f061c	 ldrne       r0, [pc, #0x61C]
  00384	1affffbf	 bne         |$LN148@CMK_IOCont|
  00388	e59f1608	 ldr         r1, [pc, #0x608]
  0038c	e59f0610	 ldr         r0, [pc, #0x610]

; 1388 :                 ReleaseMutex(cmem_mutex);
; 1389 :                 return FALSE;

  00390	eaffffbc	 b           |$LN148@CMK_IOCont|
  00394		 |$LN92@CMK_IOCont|

; 1352 :                 __E("ALLOC%s: invalid pool (%d) passed.\n",
; 1353 :                         Ioctl & CMEM_CACHED ? "CACHED" : "", pool);

  00394	e3170b02	 tst         r7, #2, 22
  00398	159f1600	 ldrne       r1, [pc, #0x600]
  0039c	059f15f4	 ldreq       r1, [pc, #0x5F4]
  003a0	e59f05f4	 ldr         r0, [pc, #0x5F4]
  003a4	e1a02008	 mov         r2, r8
  003a8	eb000000	 bl          NKDbgPrintfW
  003ac	ea000166	 b           |$LN136@CMK_IOCont|
  003b0		 |$LN81@CMK_IOCont|

; 1410 : 
; 1411 :             /*
; 1412 :              * argp contains either the user virtual address or the physical
; 1413 :              * address of the buffer to free coming in, and contains the pool
; 1414 :              * where it was freed from and the size of the block on return.
; 1415 :              */
; 1416 :         case CMEM_IOCFREE:
; 1417 :             __D("FREE%s%s ioctl received.\n",
; 1418 :                     Ioctl & CMEM_HEAP ? "HEAP" : "",
; 1419 :                     Ioctl & CMEM_PHYS ? "PHYS" : "");
; 1420 : 
; 1421 :             if (InBufLen < sizeof(union CMEM_AllocUnion)) {

  003b0	e3540010	 cmp         r4, #0x10

; 1422 :                 return FALSE;

  003b4	3a000164	 bcc         |$LN136@CMK_IOCont|

; 1423 :             }
; 1424 : 
; 1425 :             allocDesc = *(union CMEM_AllocUnion*)pInBuf;
; 1426 : 
; 1427 :             if (WaitForSingleObject(cmem_mutex, INFINITE) != WAIT_OBJECT_0) {

  003b8	e59f25a4	 ldr         r2, [pc, #0x5A4]
  003bc	e5953004	 ldr         r3, [r5, #4]
  003c0	e5959000	 ldr         r9, [r5]
  003c4	e5920450	 ldr         r0, [r2, #0x450]
  003c8	e5952008	 ldr         r2, [r5, #8]
  003cc	e1a01006	 mov         r1, r6
  003d0	e58d3020	 str         r3, [sp, #0x20]
  003d4	e58d2014	 str         r2, [sp, #0x14]
  003d8	e595200c	 ldr         r2, [r5, #0xC]
  003dc	e58d2018	 str         r2, [sp, #0x18]
  003e0	eb000000	 bl          WaitForSingleObject
  003e4	e3500000	 cmp         r0, #0

; 1428 :                 return FALSE;

  003e8	1a000157	 bne         |$LN136@CMK_IOCont|

; 1429 :             }
; 1430 : 
; 1431 :             if (Ioctl & CMEM_PHYS) {

  003ec	e2174a01	 ands        r4, r7, #1, 20

; 1432 :                 // user passed in a physical address
; 1433 :                 entry = find_busy_entry(allocDesc.virtp, &pool, &e, &bi, FALSE);

  003f0	e28d2008	 add         r2, sp, #8
  003f4	e28d100c	 add         r1, sp, #0xC
  003f8	e1a00009	 mov         r0, r9
  003fc	0a000004	 beq         |$LN78@CMK_IOCont|
  00400	e3a03000	 mov         r3, #0
  00404	e58d3000	 str         r3, [sp]
  00408	e28d3010	 add         r3, sp, #0x10
  0040c	eb000000	 bl          find_busy_entry

; 1434 :             }
; 1435 :             else {

  00410	ea000003	 b           |$LN138@CMK_IOCont|
  00414		 |$LN78@CMK_IOCont|

; 1436 :                 // user passed in a virtual address
; 1437 :                 entry = find_busy_entry(allocDesc.virtp, &pool, &e, &bi, TRUE);

  00414	e3a03001	 mov         r3, #1
  00418	e58d3000	 str         r3, [sp]
  0041c	e28d3010	 add         r3, sp, #0x10
  00420	eb000000	 bl          find_busy_entry
  00424		 |$LN138@CMK_IOCont|
  00424	e1a06000	 mov         r6, r0

; 1438 :             }
; 1439 : 
; 1440 :             if (entry) {

  00428	e59fb54c	 ldr         r11, [pc, #0x54C]
  0042c	e59d800c	 ldr         r8, [sp, #0xC]
  00430	e59da010	 ldr         r10, [sp, #0x10]
  00434	e3560000	 cmp         r6, #0
  00438	0a000034	 beq         |$LN64@CMK_IOCont|

; 1441 :                 if (!VirtualFreeEx((HANDLE)entry->dwUsrProcId, entry->pUsrVA,
; 1442 :                             0, MEM_RELEASE)) {

  0043c	e596101c	 ldr         r1, [r6, #0x1C]
  00440	e5960020	 ldr         r0, [r6, #0x20]
  00444	e3a03902	 mov         r3, #2, 18
  00448	e3a02000	 mov         r2, #0
  0044c	eb000000	 bl          VirtualFreeEx
  00450	e3500000	 cmp         r0, #0
  00454	1a00000c	 bne         |$LN75@CMK_IOCont|

; 1443 :                     __E("FREE%s%s: Failed to free buffer %d from pool %d - error:%d\n",
; 1444 :                             Ioctl & CMEM_HEAP ? "HEAP" : "",
; 1445 :                             Ioctl & CMEM_PHYS ? "PHYS" : "",
; 1446 :                             entry->id, pool, GetLastError());

  00458	eb000000	 bl          GetLastError
  0045c	e59f1534	 ldr         r1, [pc, #0x534]
  00460	e3540000	 cmp         r4, #0
  00464	159f2528	 ldrne       r2, [pc, #0x528]
  00468	01a02001	 moveq       r2, r1
  0046c	e3170b01	 tst         r7, #1, 22
  00470	159f1518	 ldrne       r1, [pc, #0x518]
  00474	e5963008	 ldr         r3, [r6, #8]
  00478	e1a0e000	 mov         lr, r0
  0047c	e59f0508	 ldr         r0, [pc, #0x508]
  00480	e58de004	 str         lr, [sp, #4]
  00484	e58d8000	 str         r8, [sp]
  00488	eb000000	 bl          NKDbgPrintfW
  0048c		 |$LN75@CMK_IOCont|

; 1447 :                 }
; 1448 : 
; 1449 :                 if (Ioctl & CMEM_HEAP) {

  0048c	e3170b01	 tst         r7, #1, 22
  00490	0a00000d	 beq         |$LN69@CMK_IOCont|

; 1450 :                     HeapMem_free(bi, (void *)entry->kvirtp, entry->size);

  00494	e5962018	 ldr         r2, [r6, #0x18]
  00498	e5961014	 ldr         r1, [r6, #0x14]
  0049c	e1a0000a	 mov         r0, r10
  004a0	eb000000	 bl          HeapMem_free

; 1451 :                     RemoveEntryList(e);

  004a4	e59d1008	 ldr         r1, [sp, #8]

; 1452 :                     free(entry);

  004a8	e1a00006	 mov         r0, r6
  004ac	e5912004	 ldr         r2, [r1, #4]
  004b0	e5913000	 ldr         r3, [r1]
  004b4	e5823000	 str         r3, [r2]
  004b8	e5912000	 ldr         r2, [r1]
  004bc	e5913004	 ldr         r3, [r1, #4]
  004c0	e5823004	 str         r3, [r2, #4]
  004c4	eb000000	 bl          free

; 1453 :                 }
; 1454 :                 else {

  004c8	ea000010	 b           |$LN64@CMK_IOCont|
  004cc		 |$LN69@CMK_IOCont|

; 1455 :                     RemoveEntryList(e);

  004cc	e59d4008	 ldr         r4, [sp, #8]

; 1456 :                     InitializeListHead(e);
; 1457 :                     InsertHeadList(&p_objs[bi][pool].freelist, e);

  004d0	e088338a	 add         r3, r8, r10, lsl #7
  004d4	e063e183	 rsb         lr, r3, r3, lsl #3
  004d8	e5940004	 ldr         r0, [r4, #4]
  004dc	e5942000	 ldr         r2, [r4]
  004e0	e5802000	 str         r2, [r0]
  004e4	e5942000	 ldr         r2, [r4]
  004e8	e5943004	 ldr         r3, [r4, #4]
  004ec	e1a0000b	 mov         r0, r11
  004f0	e5823004	 str         r3, [r2, #4]
  004f4	e5844004	 str         r4, [r4, #4]
  004f8	e5844000	 str         r4, [r4]
  004fc	e7b0310e	 ldr         r3, [r0, +lr, lsl #2]!
  00500	e5843000	 str         r3, [r4]
  00504	e5840004	 str         r0, [r4, #4]
  00508	e5834004	 str         r4, [r3, #4]
  0050c	e5804000	 str         r4, [r0]
  00510		 |$LN64@CMK_IOCont|

; 1458 :                 }
; 1459 : 
; 1460 :                 __D("FREE%s%s: Successfully freed buffer %d from pool %d\n",
; 1461 :                         Ioctl & CMEM_HEAP ? "HEAP" : "",
; 1462 :                         Ioctl & CMEM_PHYS ? "PHYS" : "", entry->id, pool);
; 1463 :             }
; 1464 : 
; 1465 :             ReleaseMutex(cmem_mutex);

  00510	e59f344c	 ldr         r3, [pc, #0x44C]
  00514	e5930450	 ldr         r0, [r3, #0x450]
  00518	eb000000	 bl          ReleaseMutex

; 1466 : 
; 1467 :             if (!entry) {

  0051c	e3560000	 cmp         r6, #0
  00520	1a000003	 bne         |$LN63@CMK_IOCont|

; 1468 :                 __E("Failed to free memory at %#lx\n", allocDesc.virtp);

  00524	e59f045c	 ldr         r0, [pc, #0x45C]
  00528	e1a01009	 mov         r1, r9
  0052c	eb000000	 bl          NKDbgPrintfW

; 1469 :                 return FALSE;

  00530	ea000105	 b           |$LN136@CMK_IOCont|
  00534		 |$LN63@CMK_IOCont|

; 1470 :             }
; 1471 : 
; 1472 : #ifdef __DEBUG
; 1473 :             dump_lists(bi, pool);
; 1474 : #endif
; 1475 :             if (Ioctl & CMEM_HEAP) {

  00534	e3170b01	 tst         r7, #1, 22

; 1476 :                 allocDesc.free_outparams.size = entry->size;

  00538	15963018	 ldrne       r3, [r6, #0x18]

; 1477 :             }
; 1478 :             else {
; 1479 :                 allocDesc.free_outparams.size = p_objs[bi][pool].size;

  0053c	0088338a	 addeq       r3, r8, r10, lsl #7
  00540	00633183	 rsbeq       r3, r3, r3, lsl #3
  00544	008b3103	 addeq       r3, r11, r3, lsl #2
  00548	05933014	 ldreq       r3, [r3, #0x14]

; 1480 :             }
; 1481 :             allocDesc.free_outparams.poolid = pool;
; 1482 :             if (!pInBuf || InBufLen < sizeof(allocDesc)) {
; 1483 :                 return FALSE;
; 1484 :             }
; 1485 :             *(union CMEM_AllocUnion*)pInBuf = allocDesc;

  0054c	e5858000	 str         r8, [r5]

; 1847 :     }
; 1848 : 
; 1849 :     return TRUE;

  00550	e3a00001	 mov         r0, #1
  00554	e5853004	 str         r3, [r5, #4]
  00558	e59d3014	 ldr         r3, [sp, #0x14]
  0055c	e5853008	 str         r3, [r5, #8]
  00560	e59d3018	 ldr         r3, [sp, #0x18]
  00564	e585300c	 str         r3, [r5, #0xC]
  00568	ea0000f8	 b           |$LN111@CMK_IOCont|
  0056c		 |$LN58@CMK_IOCont|

; 1486 : 
; 1487 :             __D("FREE%s%s: returning size %d, poolid %d\n",
; 1488 :                     Ioctl & CMEM_HEAP ? "HEAP" : "",
; 1489 :                     Ioctl & CMEM_PHYS ? "PHYS" : "",
; 1490 :                     allocDesc.free_outparams.size,
; 1491 :                     allocDesc.free_outparams.poolid);
; 1492 : 
; 1493 :             break;
; 1494 : 
; 1495 :        /*
; 1496 :         * argp contains the user virtual address of the buffer to translate
; 1497 :         * coming in, and the translated physical address on return.
; 1498 :         */
; 1499 :         case CMEM_IOCGETPHYS:
; 1500 :             __D("GETPHYS ioctl received.\n");
; 1501 :             //if (get_user(virtp, argp))
; 1502 :             if (!pInBuf || InBufLen < sizeof(union CMEM_AllocUnion)) {

  0056c	e3550000	 cmp         r5, #0
  00570	0a0000f5	 beq         |$LN136@CMK_IOCont|
  00574	e3540010	 cmp         r4, #0x10
  00578	3a0000f3	 bcc         |$LN136@CMK_IOCont|

; 1503 :                 return FALSE;
; 1504 :             }
; 1505 :             virtp = ((union CMEM_AllocUnion*)pInBuf)->virtp;

  0057c	e5954000	 ldr         r4, [r5]

; 1506 :             __D("CMK_IOControl case CMEM_IOCGETPHYS: virtp = %#lx.\n", virtp);
; 1507 : 
; 1508 :             physp = get_phys(virtp);

  00580	e1a00004	 mov         r0, r4
  00584	eb000000	 bl          get_phys
  00588	e1b07000	 movs        r7, r0

; 1509 : 
; 1510 :             if (physp == 0) {

  0058c	1a000011	 bne         |$LN55@CMK_IOCont|

; 1511 :                 // user passed in a user space virtual address, maybe?
; 1512 :                 if (WaitForSingleObject(cmem_mutex, INFINITE) != WAIT_OBJECT_0) {

  00590	e59f73cc	 ldr         r7, [pc, #0x3CC]
  00594	e1a01006	 mov         r1, r6
  00598	e5970450	 ldr         r0, [r7, #0x450]
  0059c	eb000000	 bl          WaitForSingleObject
  005a0	e3500000	 cmp         r0, #0

; 1513 :                     return FALSE;

  005a4	1a0000e8	 bne         |$LN136@CMK_IOCont|

; 1514 :                 }
; 1515 :                 entry = find_busy_entry(virtp, &pool, &e, &bi, TRUE);

  005a8	e3a03001	 mov         r3, #1
  005ac	e58d3000	 str         r3, [sp]
  005b0	e28d3010	 add         r3, sp, #0x10
  005b4	e28d2008	 add         r2, sp, #8
  005b8	e28d100c	 add         r1, sp, #0xC
  005bc	e1a00004	 mov         r0, r4
  005c0	eb000000	 bl          find_busy_entry
  005c4	e1b03000	 movs        r3, r0

; 1524 :                     return FALSE;
; 1525 :                 }
; 1526 :                 ReleaseMutex(cmem_mutex);

  005c8	e5970450	 ldr         r0, [r7, #0x450]
  005cc	0a000004	 beq         |$LN53@CMK_IOCont|
  005d0	e593700c	 ldr         r7, [r3, #0xC]
  005d4	eb000000	 bl          ReleaseMutex
  005d8		 |$LN55@CMK_IOCont|

; 1527 :             }
; 1528 : 
; 1529 :             ((union CMEM_AllocUnion*)pInBuf)->physp = physp;

  005d8	e5857000	 str         r7, [r5]

; 1847 :     }
; 1848 : 
; 1849 :     return TRUE;

  005dc	e3a00001	 mov         r0, #1
  005e0	ea0000da	 b           |$LN111@CMK_IOCont|
  005e4		 |$LN53@CMK_IOCont|

; 1516 : 
; 1517 :                 if (entry) {
; 1518 :                     physp = entry->physp;
; 1519 :                 }
; 1520 :                 else {
; 1521 :                     ReleaseMutex(cmem_mutex);

  005e4	eb000000	 bl          ReleaseMutex

; 1522 :                     __E("GETPHYS: Failed to convert virtual %#lx to physical.\n",
; 1523 :                             virtp);

  005e8	e59f0394	 ldr         r0, [pc, #0x394]
  005ec	e1a01004	 mov         r1, r4
  005f0	eb000000	 bl          NKDbgPrintfW
  005f4	ea0000d4	 b           |$LN136@CMK_IOCont|
  005f8		 |$LN51@CMK_IOCont|

; 1530 : 
; 1531 :             __D("GETPHYS: returning %#lx\n", physp);
; 1532 :             break;
; 1533 : 
; 1534 :             /*
; 1535 :              * argp contains the pool to query for size coming in, and the size
; 1536 :              * of the pool on return.
; 1537 :              */
; 1538 :         case CMEM_IOCGETSIZE:
; 1539 :             __D("GETSIZE ioctl received\n");
; 1540 : 
; 1541 :             if (!pInBuf || InBufLen < sizeof(union CMEM_AllocUnion)) {

  005f8	e3550000	 cmp         r5, #0
  005fc	0a0000d2	 beq         |$LN136@CMK_IOCont|
  00600	e3540010	 cmp         r4, #0x10
  00604	3a0000d0	 bcc         |$LN136@CMK_IOCont|

; 1542 :                 return FALSE;
; 1543 :             }
; 1544 :             pAllocDesc = (union CMEM_AllocUnion*)pInBuf;
; 1545 : 
; 1546 :             pool = pAllocDesc->get_size_inparams.poolid;
; 1547 :             bi = pAllocDesc->get_size_inparams.blockid;

  00608	e595e004	 ldr         lr, [r5, #4]

; 1548 : 
; 1549 :             if (bi >= NBLOCKS) {

  0060c	e5951000	 ldr         r1, [r5]
  00610	e35e0002	 cmp         lr, #2

; 1550 :                 __E("ioctl: invalid block id %d, must be < %d\n",
; 1551 :                         bi, NBLOCKS);

  00614	a1a0100e	 movge       r1, lr
  00618	aafffe9d	 bge         |$LN149@CMK_IOCont|

; 1552 :                 return FALSE;
; 1553 :             }
; 1554 : 
; 1555 :             if (pool >= npools[bi] || pool < 0) {

  0061c	e59f3340	 ldr         r3, [pc, #0x340]
  00620	e2833038	 add         r3, r3, #0x38
  00624	e793310e	 ldr         r3, [r3, +lr, lsl #2]
  00628	e1510003	 cmp         r1, r3
  0062c	aa00000b	 bge         |$LN46@CMK_IOCont|
  00630	e3510000	 cmp         r1, #0
  00634	4a000009	 bmi         |$LN46@CMK_IOCont|

; 1557 :                 return FALSE;
; 1558 :             }
; 1559 : 
; 1560 :             if (InBufLen < sizeof(p_objs[bi][pool].size)) {

  00638	e3540004	 cmp         r4, #4

; 1561 :                 return FALSE;

  0063c	3a0000c2	 bcc         |$LN136@CMK_IOCont|

; 1562 :             }
; 1563 :             *(unsigned long *)pInBuf = p_objs[bi][pool].size;

  00640	e59f2334	 ldr         r2, [pc, #0x334]
  00644	e081338e	 add         r3, r1, lr, lsl #7
  00648	e0633183	 rsb         r3, r3, r3, lsl #3
  0064c	e0823103	 add         r3, r2, r3, lsl #2
  00650	e5933014	 ldr         r3, [r3, #0x14]
  00654		 |$LN141@CMK_IOCont|
  00654	e5853000	 str         r3, [r5]

; 1847 :     }
; 1848 : 
; 1849 :     return TRUE;

  00658	e3a00001	 mov         r0, #1
  0065c	ea0000bb	 b           |$LN111@CMK_IOCont|
  00660		 |$LN46@CMK_IOCont|

; 1556 :                 __E("GETSIZE: invalid pool (%d) passed.\n", pool);

  00660	e59f0318	 ldr         r0, [pc, #0x318]
  00664	eb000000	 bl          NKDbgPrintfW
  00668	ea0000b7	 b           |$LN136@CMK_IOCont|
  0066c		 |$LN44@CMK_IOCont|

; 1564 : 
; 1565 :             __D("GETSIZE returning %d\n", p_objs[bi][pool].size);
; 1566 :             break;
; 1567 : 
; 1568 :             /*
; 1569 :              * argp contains the requested pool buffers size coming in, and the
; 1570 :              * pool id (index) on return.
; 1571 :              */
; 1572 :         case CMEM_IOCGETPOOL:
; 1573 :             __D("GETPOOL ioctl received.\n");
; 1574 : 
; 1575 :             if (!pInBuf || InBufLen < sizeof(union CMEM_AllocUnion)) {

  0066c	e3550000	 cmp         r5, #0
  00670	0a0000b5	 beq         |$LN136@CMK_IOCont|
  00674	e3540010	 cmp         r4, #0x10
  00678	3a0000b3	 bcc         |$LN136@CMK_IOCont|

; 1576 :                 return FALSE;
; 1577 :             }
; 1578 :             pAllocDesc = (union CMEM_AllocUnion*)pInBuf;
; 1579 : 
; 1580 :             reqsize = pAllocDesc->get_pool_inparams.size;
; 1581 :             bi = pAllocDesc->get_pool_inparams.blockid;

  0067c	e5957004	 ldr         r7, [r5, #4]

; 1582 : 
; 1583 :             if (bi >= NBLOCKS) {

  00680	e5958000	 ldr         r8, [r5]
  00684	e3570002	 cmp         r7, #2

; 1584 :                 __E("ioctl: invalid block id %d, must be < %d\n",
; 1585 :                         bi, NBLOCKS);

  00688	a1a01007	 movge       r1, r7
  0068c	aafffe80	 bge         |$LN149@CMK_IOCont|

; 1586 :                 return FALSE;
; 1587 :             }
; 1588 : 
; 1589 :             if (WaitForSingleObject(cmem_mutex, INFINITE) != WAIT_OBJECT_0) {

  00690	e59f92cc	 ldr         r9, [pc, #0x2CC]
  00694	e1a01006	 mov         r1, r6
  00698	e5990450	 ldr         r0, [r9, #0x450]
  0069c	eb000000	 bl          WaitForSingleObject
  006a0	e3500000	 cmp         r0, #0

; 1590 :                 return FALSE;

  006a4	1a0000a8	 bne         |$LN136@CMK_IOCont|

; 1591 :             }
; 1592 : 
; 1593 :             __D("GETPOOL: Trying to find a pool to fit size %d\n", reqsize);
; 1594 :             for (i = 0; i < npools[bi]; i++) {

  006a8	e2893038	 add         r3, r9, #0x38
  006ac	e793e107	 ldr         lr, [r3, +r7, lsl #2]
  006b0	e3a01000	 mov         r1, #0
  006b4	e35e0000	 cmp         lr, #0
  006b8	da000012	 ble         |$LN135@CMK_IOCont|
  006bc	e59f22b8	 ldr         r2, [pc, #0x2B8]
  006c0	e0673187	 rsb         r3, r7, r7, lsl #3
  006c4	e0822483	 add         r2, r2, r3, lsl #9
  006c8		 |$LL39@CMK_IOCont|

; 1595 :                 size = p_objs[bi][i].size;

  006c8	e5923014	 ldr         r3, [r2, #0x14]

; 1596 :                 freelistp = &p_objs[bi][i].freelist;
; 1597 : 
; 1598 :                 __D("GETPOOL: size (%d) > reqsize (%d)?\n", size, reqsize);
; 1599 :                 if (size >= reqsize) {

  006cc	e1530008	 cmp         r3, r8
  006d0	3a000006	 bcc         |$LN38@CMK_IOCont|

; 1600 :                     __D("GETPOOL: delta (%d) < olddelta (%d)?\n",
; 1601 :                             size - reqsize, delta);
; 1602 :                     if ((size - reqsize) < (unsigned int)delta) {

  006d4	e0430008	 sub         r0, r3, r8
  006d8	e150000a	 cmp         r0, r10
  006dc	2a000003	 bcs         |$LN38@CMK_IOCont|

; 1603 :                         if (!IsListEmpty(freelistp)) {

  006e0	e5923000	 ldr         r3, [r2]
  006e4	e1530002	 cmp         r3, r2

; 1604 :                             delta = size - reqsize;

  006e8	11a0a000	 movne       r10, r0

; 1605 :                             __D("GETPOOL: Found a best fit delta %d\n", delta);
; 1606 :                             pool = i;

  006ec	11a06001	 movne       r6, r1
  006f0		 |$LN38@CMK_IOCont|
  006f0	e2811001	 add         r1, r1, #1
  006f4	e151000e	 cmp         r1, lr
  006f8	e282201c	 add         r2, r2, #0x1C
  006fc	bafffff1	 blt         |$LL39@CMK_IOCont|

; 1607 :                         }
; 1608 :                     }
; 1609 :                 }
; 1610 :             }
; 1611 : 
; 1612 :             if (pool == -1 && heap_pool[bi] != -1) {

  00700	e3760001	 cmn         r6, #1
  00704	1a00000f	 bne         |$LN31@CMK_IOCont|
  00708		 |$LN135@CMK_IOCont|
  00708	e59f3260	 ldr         r3, [pc, #0x260]
  0070c	e2833004	 add         r3, r3, #4
  00710	e7933107	 ldr         r3, [r3, +r7, lsl #2]
  00714	e3730001	 cmn         r3, #1
  00718	0a00000a	 beq         |$LN31@CMK_IOCont|

; 1613 :                 if (useHeapIfPoolUnavailable) {

  0071c	e599344c	 ldr         r3, [r9, #0x44C]
  00720	e3530000	 cmp         r3, #0
  00724	0a000007	 beq         |$LN31@CMK_IOCont|

; 1614 :                     /* no pool buffer available, try heap */
; 1615 :                     virtp = (unsigned long)HeapMem_alloc(bi, reqsize,
; 1616 :                             HEAP_ALIGN, DRYRUN);

  00728	e59f2248	 ldr         r2, [pc, #0x248]
  0072c	e3a03001	 mov         r3, #1
  00730	e1a01008	 mov         r1, r8
  00734	e5922000	 ldr         r2, [r2]
  00738	e1a00007	 mov         r0, r7
  0073c	eb000000	 bl          HeapMem_alloc
  00740	e3500000	 cmp         r0, #0

; 1617 :                     if (virtp != (unsigned long)NULL) {
; 1618 :                         /*
; 1619 :                          * Indicate heap pool with magic negative value.
; 1620 :                          * -1 indicates no pool and no heap.
; 1621 :                          * -2 indicates no pool but heap available and allowed.
; 1622 :                          */
; 1623 :                         pool = -2;

  00744	13e06001	 mvnne       r6, #1
  00748		 |$LN31@CMK_IOCont|

; 1624 : 
; 1625 :                         __D("GETPOOL: no pool-based buffer available, returning heap \"pool\" instead (due to config override)\n");
; 1626 :                     }
; 1627 :                 }
; 1628 :             }
; 1629 : 
; 1630 :             ReleaseMutex(cmem_mutex);

  00748	e5990450	 ldr         r0, [r9, #0x450]
  0074c	eb000000	 bl          ReleaseMutex

; 1631 : 
; 1632 :             if (pool == -1) {

  00750	e3760001	 cmn         r6, #1
  00754	1a000003	 bne         |$LN30@CMK_IOCont|

; 1633 :                 __E("Failed to find a pool which fits %d\n", reqsize);

  00758	e59f0214	 ldr         r0, [pc, #0x214]
  0075c	e1a01008	 mov         r1, r8
  00760	eb000000	 bl          NKDbgPrintfW
  00764	ea000078	 b           |$LN136@CMK_IOCont|
  00768		 |$LN30@CMK_IOCont|

; 1634 :                 return FALSE;
; 1635 :             }
; 1636 : 
; 1637 :             if (InBufLen < sizeof(pool)) {

  00768	e3540004	 cmp         r4, #4

; 1638 :                 return FALSE;

  0076c	3a000076	 bcc         |$LN136@CMK_IOCont|

; 1639 :             }
; 1640 :             ((union CMEM_AllocUnion*)pInBuf)->poolid = pool;
; 1641 :             __D("GETPOOL: returning %d\n", pool);
; 1642 :             break;

  00770	eafffe96	 b           |$LN140@CMK_IOCont|
  00774		 |$LN28@CMK_IOCont|

; 1643 : 
; 1644 :         case CMEM_IOCCACHE:
; 1645 :             __D("CACHE%s%s ioctl received.\n",
; 1646 :                     Ioctl & CMEM_WB ? "WB" : "", Ioctl & CMEM_INV ? "INV" : "");
; 1647 : 
; 1648 :             if (!pInBuf || InBufLen < sizeof(block)) {

  00774	e3550000	 cmp         r5, #0
  00778	0a000073	 beq         |$LN136@CMK_IOCont|
  0077c	e3540008	 cmp         r4, #8
  00780	3a000071	 bcc         |$LN136@CMK_IOCont|

; 1649 :                 return FALSE;
; 1650 :             }
; 1651 :             pBlock = (struct block_struct*)pInBuf;
; 1652 : 
; 1653 :             virtp = pBlock->addr;

  00784	e5950000	 ldr         r0, [r5]

; 1654 :             virtp_end = virtp + pBlock->size;

  00788	e5952004	 ldr         r2, [r5, #4]
  0078c	e3a03c01	 mov         r3, #1, 24

; 1655 : 
; 1656 : #ifdef CHECK_FOR_ALLOCATED_BUFFER
; 1657 :             physp = get_phys(virtp);
; 1658 :             if (physp == 0) {
; 1659 :                 __E("CACHE%s%s: Failed to convert virtual %#lx to physical\n",
; 1660 :                         Ioctl & CMEM_WB ? "WB" : "", Ioctl & CMEM_INV ? "INV" : "",
; 1661 :                         virtp);
; 1662 :                 return FALSE;
; 1663 :             }
; 1664 : 
; 1665 :             __D("CACHE%s%s: translated %#lx user virtual to %#lx physical\n",
; 1666 :                     Ioctl & CMEM_WB ? "WB" : "", Ioctl & CMEM_INV ? "INV" : "",
; 1667 :                     virtp, physp);
; 1668 : 
; 1669 :             if (WaitForSingleObject(cmem_mutex, INFINITE) != WAIT_OBJECT_0) {
; 1670 :                 return FALSE;
; 1671 :             }
; 1672 :             entry = find_busy_entry(physp, &pool, &e, &bi, FALSE);
; 1673 :             ReleaseMutex(cmem_mutex);
; 1674 :             if (!entry) {
; 1675 :                 __E("CACHE%s%s: Failed to find allocated buffer at virtual %#lx\n",
; 1676 :                         Ioctl & CMEM_WB ? "WB" : "",
; 1677 :                         Ioctl & CMEM_INV ? "INV" : "", virtp);
; 1678 :                 return FALSE;
; 1679 :             }
; 1680 :             if (!(entry->flags & CMEM_CACHED)) {
; 1681 :                 __E("CACHE%s%s: virtual buffer %#lx not cached\n",
; 1682 :                         Ioctl & CMEM_WB ? "WB" : "", Ioctl & CMEM_INV ? "INV" : "",
; 1683 :                         virtp);
; 1684 :                 return FALSE;
; 1685 :             }
; 1686 : #endif
; 1687 : 
; 1688 : #ifdef USE_MMAPSEM
; 1689 :             __D("CACHE%s%s: acquiring mmap_sem ...\n",
; 1690 :                     Ioctl & CMEM_WB ? "WB" : "", Ioctl & CMEM_INV ? "INV" : "");
; 1691 :             down_write(&current->mm->mmap_sem);
; 1692 : #endif
; 1693 : 
; 1694 :             switch (Ioctl) {

  00790	e3833007	 orr         r3, r3, #7
  00794	e0821000	 add         r1, r2, r0
  00798	e1570003	 cmp         r7, r3
  0079c	0a000009	 beq         |$LN23@CMK_IOCont|
  007a0	e3a03c02	 mov         r3, #2, 24
  007a4	e3833007	 orr         r3, r3, #7
  007a8	e1570003	 cmp         r7, r3
  007ac	0a000003	 beq         |$LN22@CMK_IOCont|
  007b0	e3a03c03	 mov         r3, #3, 24
  007b4	e3833007	 orr         r3, r3, #7
  007b8	e1570003	 cmp         r7, r3
  007bc	1a00005e	 bne         |$LN109@CMK_IOCont|
  007c0		 |$LN22@CMK_IOCont|

; 1699 :                     __D("CACHEWB: cleaned user virtual %#lx->%#lx\n",
; 1700 :                             virtp, virtp_end);
; 1701 : 
; 1702 :                     break;
; 1703 : 
; 1704 :                 case CMEM_IOCCACHEINV:
; 1705 :                     CacheRangeFlush((LPVOID)virtp,
; 1706 :                             (DWORD)virtp_end - (DWORD)virtp,
; 1707 :                             CACHE_SYNC_DISCARD);

  007c0	e3a02001	 mov         r2, #1

; 1708 :                     __D("CACHEINV: invalidated user virtual %#lx->%#lx\n",
; 1709 :                             virtp, virtp_end);
; 1710 : 
; 1711 :                     break;

  007c4	ea000000	 b           |$LN142@CMK_IOCont|
  007c8		 |$LN23@CMK_IOCont|

; 1695 :                 case CMEM_IOCCACHEWB:
; 1696 :                     CacheRangeFlush((LPVOID)virtp,
; 1697 :                             (DWORD)virtp_end - (DWORD)virtp,
; 1698 :                             CACHE_SYNC_WRITEBACK);

  007c8	e3a02004	 mov         r2, #4
  007cc		 |$LN142@CMK_IOCont|
  007cc	e0411000	 sub         r1, r1, r0
  007d0	eb000000	 bl          CacheRangeFlush

; 1847 :     }
; 1848 : 
; 1849 :     return TRUE;

  007d4	e3a00001	 mov         r0, #1
  007d8	ea00005c	 b           |$LN111@CMK_IOCont|
  007dc		 |$LN20@CMK_IOCont|

; 1712 : 
; 1713 :                 case CMEM_IOCCACHEWBINV:
; 1714 :                     CacheRangeFlush((LPVOID)virtp,
; 1715 :                             (DWORD)virtp_end - (DWORD)virtp,
; 1716 :                             CACHE_SYNC_DISCARD);
; 1717 :                     __D("CACHEWBINV: flushed user virtual %#lx->%#lx\n",
; 1718 :                             virtp, virtp_end);
; 1719 : 
; 1720 :                     break;
; 1721 :             }
; 1722 : 
; 1723 : #ifdef USE_MMAPSEM
; 1724 :             __D("CACHE%s%s: releasing mmap_sem ...\n",
; 1725 :                     Ioctl & CMEM_WB ? "WB" : "", Ioctl & CMEM_INV ? "INV" : "");
; 1726 :             up_write(&current->mm->mmap_sem);
; 1727 : #endif
; 1728 :             break;
; 1729 : 
; 1730 :         case CMEM_IOCGETVERSION:
; 1731 :             __D("GETVERSION ioctl received, returning %#x.\n", version);
; 1732 : 
; 1733 :             if (!pInBuf || InBufLen < sizeof(version)) {

  007dc	e3550000	 cmp         r5, #0
  007e0	0a000059	 beq         |$LN136@CMK_IOCont|
  007e4	e3540004	 cmp         r4, #4
  007e8	3a000057	 bcc         |$LN136@CMK_IOCont|

; 1734 :                 return FALSE;
; 1735 :             }
; 1736 :             *(unsigned int*)pInBuf = version;

  007ec	e59f317c	 ldr         r3, [pc, #0x17C]
  007f0	e5933000	 ldr         r3, [r3]

; 1737 : 
; 1738 :             break;

  007f4	eaffff96	 b           |$LN141@CMK_IOCont|
  007f8		 |$LN17@CMK_IOCont|

; 1739 : 
; 1740 :         case CMEM_IOCGETNUMBLOCKS:
; 1741 :             __D("GETNUMBLOCKS ioctl received, returning %#x.\n", numBlocks);
; 1742 : 
; 1743 :             if (!pInBuf || InBufLen < sizeof(numBlocks)) {

  007f8	e3550000	 cmp         r5, #0
  007fc	0a000052	 beq         |$LN136@CMK_IOCont|
  00800	e3540004	 cmp         r4, #4
  00804	3a000050	 bcc         |$LN136@CMK_IOCont|

; 1744 :                 return FALSE;
; 1745 :             }
; 1746 :             *(unsigned int*)pInBuf = numBlocks;

  00808	e59f3154	 ldr         r3, [pc, #0x154]
  0080c	e593302c	 ldr         r3, [r3, #0x2C]

; 1747 : 
; 1748 :             break;

  00810	eaffff8f	 b           |$LN141@CMK_IOCont|
  00814		 |$LN14@CMK_IOCont|

; 1749 : 
; 1750 :         case CMEM_IOCGETBLOCK:
; 1751 :             if (!pInBuf || InBufLen < sizeof(union CMEM_AllocUnion)) {

  00814	e3550000	 cmp         r5, #0
  00818	0a00004b	 beq         |$LN136@CMK_IOCont|
  0081c	e3540010	 cmp         r4, #0x10
  00820	3a000049	 bcc         |$LN136@CMK_IOCont|

; 1752 :                 return FALSE;
; 1753 :             }
; 1754 :             pAllocDesc = (union CMEM_AllocUnion*)pInBuf;
; 1755 : 
; 1756 :             bi = pAllocDesc->blockid;

  00824	e5950000	 ldr         r0, [r5]

; 1757 : 
; 1758 :             pAllocDesc->get_block_outparams.physp = block_start[bi];

  00828	e59f2134	 ldr         r2, [pc, #0x134]
  0082c	e1a01100	 mov         r1, r0, lsl #2
  00830	e7b13002	 ldr         r3, [r1, +r2]!

; 1759 :             pAllocDesc->get_block_outparams.size = block_end[bi] -
; 1760 :                 block_start[bi];

  00834	e2822008	 add         r2, r2, #8
  00838	e5853000	 str         r3, [r5]
  0083c	e7922100	 ldr         r2, [r2, +r0, lsl #2]
  00840	e5913000	 ldr         r3, [r1]

; 1847 :     }
; 1848 : 
; 1849 :     return TRUE;

  00844	e3a00001	 mov         r0, #1
  00848	e0423003	 sub         r3, r2, r3
  0084c	e5853004	 str         r3, [r5, #4]
  00850	ea00003e	 b           |$LN111@CMK_IOCont|
  00854		 |$LN11@CMK_IOCont|

; 1761 : 
; 1762 :             __D("GETBLOCK ioctl received, returning phys base 0x%lx, size 0x%x.\n",
; 1763 :                     pAllocDesc->get_block_outparams.physp,
; 1764 :                     pAllocDesc->get_block_outparams.size);
; 1765 : 
; 1766 :             //if (copy_to_user(argp, &allocDesc, sizeof(allocDesc)))
; 1767 :             //{
; 1768 :             //  return FALSE;
; 1769 :             //}
; 1770 : 
; 1771 :             break;
; 1772 : 
; 1773 :        /*
; 1774 :         * argp contains the physical address and size of the region
; 1775 :         * to map, and the mapped physical address on return.
; 1776 :         */
; 1777 :         case CMEM_IOCMAPADDRESS:
; 1778 :             __D("MAPADDRESS ioctl received.\n");
; 1779 :             if (!pInBuf || InBufLen < sizeof(union CMEM_AllocUnion)) {

  00854	e3550000	 cmp         r5, #0
  00858	0a00003b	 beq         |$LN136@CMK_IOCont|
  0085c	e3540010	 cmp         r4, #0x10
  00860	3a000039	 bcc         |$LN136@CMK_IOCont|

; 1780 :                 return (FALSE);
; 1781 :             }
; 1782 :             pAllocDesc = (union CMEM_AllocUnion *)pInBuf;
; 1783 :             physp = pAllocDesc->map_inparams.physp;
; 1784 :             size = pAllocDesc->map_inparams.size;
; 1785 :             dwCallerProcId = pAllocDesc->map_inparams.dwProcId;
; 1786 : 
; 1787 :             __D("MAPADDRESS: physp = %#x.\n", physp);
; 1788 : 
; 1789 :             /* Acquire mutex since we will be updating mapped buffer list */
; 1790 :             if (WaitForSingleObject(cmem_mutex, INFINITE) != WAIT_OBJECT_0) {

  00864	e59f70f8	 ldr         r7, [pc, #0xF8]
  00868	e5954004	 ldr         r4, [r5, #4]
  0086c	e5958008	 ldr         r8, [r5, #8]
  00870	e5970450	 ldr         r0, [r7, #0x450]
  00874	e1a01006	 mov         r1, r6
  00878	e5956000	 ldr         r6, [r5]
  0087c	eb000000	 bl          WaitForSingleObject
  00880	e3500000	 cmp         r0, #0
  00884	0a000001	 beq         |$LN8@CMK_IOCont|
  00888		 |$LN143@CMK_IOCont|

; 1791 :                 __E("MAPADDRESS: WaitForSingleObject failed!\n");

  00888	e59f00dc	 ldr         r0, [pc, #0xDC]

; 1792 :                 return (FALSE);

  0088c	ea00002d	 b           |$LN139@CMK_IOCont|
  00890		 |$LN8@CMK_IOCont|

; 1793 :             }
; 1794 : 
; 1795 :             virtp = mapAddress(physp, size, dwCallerProcId);

  00890	e1a02008	 mov         r2, r8
  00894	e1a01004	 mov         r1, r4
  00898	e1a00006	 mov         r0, r6
  0089c	eb000000	 bl          mapAddress
  008a0	e1a04000	 mov         r4, r0

; 1796 : 
; 1797 :             ReleaseMutex(cmem_mutex);

  008a4	e5970450	 ldr         r0, [r7, #0x450]
  008a8	eb000000	 bl          ReleaseMutex

; 1798 : 
; 1799 :             if (virtp == 0) {

  008ac	e3540000	 cmp         r4, #0
  008b0	1a000003	 bne         |$LN7@CMK_IOCont|

; 1800 :                 __E("MAPADDRESS: Failed to map physical address %#lx\n",
; 1801 :                         physp);

  008b4	e59f00ac	 ldr         r0, [pc, #0xAC]
  008b8	e1a01006	 mov         r1, r6
  008bc	eb000000	 bl          NKDbgPrintfW
  008c0	ea000021	 b           |$LN136@CMK_IOCont|
  008c4		 |$LN7@CMK_IOCont|

; 1802 :                 return (FALSE);
; 1803 :             }
; 1804 : 
; 1805 :             pAllocDesc->virtp = virtp;

  008c4	e5854000	 str         r4, [r5]

; 1847 :     }
; 1848 : 
; 1849 :     return TRUE;

  008c8	e3a00001	 mov         r0, #1
  008cc	ea00001f	 b           |$LN111@CMK_IOCont|
  008d0		 |$LN6@CMK_IOCont|

; 1806 : 
; 1807 :             __D("MAPADDRESS: returning %#lx\n", virtp);
; 1808 :             break;
; 1809 : 
; 1810 :        /*
; 1811 :         * argp contains the physical address and size of the region
; 1812 :         * to map, and the mapped physical address on return.
; 1813 :         */
; 1814 :         case CMEM_IOCUNMAPADDRESS:
; 1815 :             __D("UNMAPADDRESS ioctl received.\n");
; 1816 :             if (!pInBuf || InBufLen < sizeof(union CMEM_AllocUnion)) {

  008d0	e3550000	 cmp         r5, #0
  008d4	0a00001c	 beq         |$LN136@CMK_IOCont|
  008d8	e3540010	 cmp         r4, #0x10
  008dc	3a00001a	 bcc         |$LN136@CMK_IOCont|

; 1817 :                 return (FALSE);
; 1818 :             }
; 1819 : 
; 1820 :             pAllocDesc = (union CMEM_AllocUnion *)pInBuf;
; 1821 :             virtp = pAllocDesc->unmap_inparams.virtp;
; 1822 :             size = pAllocDesc->unmap_inparams.size;
; 1823 :             dwCallerProcId = pAllocDesc->unmap_inparams.dwProcId;
; 1824 :             __D("UNMAPADDRESS: virtp = %#lx.\n", virtp);
; 1825 :             __D("UNMAPADDRESS: size = %#lx.\n", size);
; 1826 : 
; 1827 :             /* Acquire mutex since we will be updating mapped buffer list */
; 1828 :             if (WaitForSingleObject(cmem_mutex, INFINITE) != WAIT_OBJECT_0) {

  008e0	e59f407c	 ldr         r4, [pc, #0x7C]
  008e4	e5957004	 ldr         r7, [r5, #4]
  008e8	e1a01006	 mov         r1, r6
  008ec	e5940450	 ldr         r0, [r4, #0x450]
  008f0	e5956000	 ldr         r6, [r5]
  008f4	e5955008	 ldr         r5, [r5, #8]
  008f8	eb000000	 bl          WaitForSingleObject
  008fc	e3500000	 cmp         r0, #0

; 1829 :                 __E("MAPADDRESS: WaitForSingleObject failed!\n");
; 1830 :                 return (FALSE);

  00900	1affffe0	 bne         |$LN143@CMK_IOCont|

; 1831 :             }
; 1832 : 
; 1833 :             if (unmapAddress(virtp, size, dwCallerProcId) != 0) {

  00904	e1a02005	 mov         r2, r5
  00908	e1a01007	 mov         r1, r7
  0090c	e1a00006	 mov         r0, r6
  00910	eb000000	 bl          unmapAddress
  00914	e3500000	 cmp         r0, #0
  00918	0a000005	 beq         |$LN2@CMK_IOCont|

; 1834 :                 __E("UNMAPADDRESS: Failed to unmap virtual address %#lx\n",
; 1835 :                         virtp);

  0091c	e59f003c	 ldr         r0, [pc, #0x3C]
  00920	e1a01006	 mov         r1, r6
  00924	eb000000	 bl          NKDbgPrintfW

; 1836 :                 ReleaseMutex(cmem_mutex);

  00928	e5940450	 ldr         r0, [r4, #0x450]
  0092c	eb000000	 bl          ReleaseMutex
  00930	ea000005	 b           |$LN136@CMK_IOCont|
  00934		 |$LN2@CMK_IOCont|

; 1837 :                 return (FALSE);
; 1838 :             }
; 1839 : 
; 1840 :             ReleaseMutex(cmem_mutex);

  00934	e5940450	 ldr         r0, [r4, #0x450]
  00938		 |$LN137@CMK_IOCont|
  00938	eb000000	 bl          ReleaseMutex
  0093c		 |$LN109@CMK_IOCont|

; 1847 :     }
; 1848 : 
; 1849 :     return TRUE;

  0093c	e3a00001	 mov         r0, #1
  00940	ea000002	 b           |$LN111@CMK_IOCont|
  00944		 |$LN1@CMK_IOCont|

; 1841 : 
; 1842 :             break;
; 1843 : 
; 1844 :         default:
; 1845 :             __E("Unknown ioctl received.\n");

  00944	e59f0010	 ldr         r0, [pc, #0x10]
  00948		 |$LN139@CMK_IOCont|
  00948	eb000000	 bl          NKDbgPrintfW
  0094c		 |$LN136@CMK_IOCont|

; 1846 :             return FALSE;

  0094c	e3a00000	 mov         r0, #0
  00950		 |$LN111@CMK_IOCont|

; 1850 : }

  00950	e28dd02c	 add         sp, sp, #0x2C
  00954	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00958	e12fff1e	 bx          lr
  0095c		 |$LN168@CMK_IOCont|
  0095c		 |$LN169@CMK_IOCont|
  0095c	00000000	 DCD         |??_C@_1EM@MJEFGDHI@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?5?$AAr?$AAe?$AAc?$AAe?$AAi@|
  00960		 |$LN170@CMK_IOCont|
  00960	00000000	 DCD         |??_C@_1IC@BMAEIIKN@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAU?$AAN?$AAM?$AAA?$AAP?$AAA?$AAD?$AAD?$AAR?$AAE?$AAS?$AAS?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe@|
  00964		 |$LN171@CMK_IOCont|
  00964	00000000	 DCD         |block_start|
  00968		 |$LN172@CMK_IOCont|
  00968	00000000	 DCD         |??_C@_1HM@PINJBPBF@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAM?$AAA?$AAP?$AAA?$AAD?$AAD?$AAR?$AAE?$AAS?$AAS?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5@|
  0096c		 |$LN173@CMK_IOCont|
  0096c	00000000	 DCD         |??_C@_1GM@ONIPBDBF@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAM?$AAA?$AAP?$AAA?$AAD?$AAD?$AAR?$AAE?$AAS?$AAS?$AA?3?$AA?5?$AAW?$AAa?$AAi?$AAt?$AAF?$AAo?$AAr@|
  00970		 |$LN174@CMK_IOCont|
  00970	00000000	 DCD         |version|
  00974		 |$LN175@CMK_IOCont|
  00974	00000000	 DCD         |??_C@_1GE@ODKFOIGO@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAf?$AAi?$AAn?$AAd?$AA?5?$AAa?$AA?5?$AAp?$AAo@|
  00978		 |$LN176@CMK_IOCont|
  00978	00000000	 DCD         |gdwPageSize|
  0097c		 |$LN177@CMK_IOCont|
  0097c	00000000	 DCD         |p_objs|
  00980		 |$LN178@CMK_IOCont|
  00980	00000000	 DCD         |??_C@_1GC@JHLICFOL@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAG?$AAE?$AAT?$AAS?$AAI?$AAZ?$AAE?$AA?3?$AA?5?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAo@|
  00984		 |$LN179@CMK_IOCont|
  00984	00000000	 DCD         |??_C@_1IG@EKDDKMDK@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAG?$AAE?$AAT?$AAP?$AAH?$AAY?$AAS?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5@|
  00988		 |$LN180@CMK_IOCont|
  00988	00000000	 DCD         |??_C@_1FI@PDOJBEOL@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAf?$AAr?$AAe?$AAe?$AA?5?$AAm?$AAe?$AAm?$AAo@|
  0098c		 |$LN181@CMK_IOCont|
  0098c	00000000	 DCD         |??_C@_1JC@KNEBIOIE@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAF?$AAR?$AAE?$AAE?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo@|
  00990		 |$LN182@CMK_IOCont|
  00990	00000000	 DCD         |??_C@_04DGHHAJMG@HEAP?$AA@|
  00994		 |$LN183@CMK_IOCont|
  00994	00000000	 DCD         |??_C@_04KNJFKMFD@PHYS?$AA@|
  00998		 |$LN184@CMK_IOCont|
  00998	00000000	 DCD         |??_C@_00CNPNBAHC@?$AA@|
  0099c		 |$LN185@CMK_IOCont|
  0099c	00000000	 DCD         |??_C@_1GC@NHBEENPF@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAA?$AAL?$AAL?$AAO?$AAC?$AA?$CF?$AAs?$AA?3?$AA?5?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAo@|
  009a0		 |$LN186@CMK_IOCont|
  009a0	00000000	 DCD         |??_C@_06HAMDABMN@CACHED?$AA@|
  009a4		 |$LN187@CMK_IOCont|
  009a4	00000000	 DCD         |??_C@_1HE@ECHHIHNI@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAA?$AAL?$AAL?$AAO?$AAC?$AA?$CF?$AAs?$AA?3?$AA?5?$AAV?$AAi?$AAr?$AAt?$AAu?$AAa?$AAl?$AAC?$AAo?$AAp@|
  009a8		 |$LN188@CMK_IOCont|
  009a8	00000000	 DCD         |??_C@_1HK@NMPGNINP@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAA?$AAL?$AAL?$AAO?$AAC?$AA?$CF?$AAs?$AA?3?$AA?5?$AAN?$AAo?$AA?5?$AAf?$AAr?$AAe?$AAe?$AA?5?$AAb?$AAu@|
  009ac		 |$LN189@CMK_IOCont|
  009ac	00000000	 DCD         |??_C@_1IC@IKJLIPKE@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?3?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAm?$AAa@|
  009b0		 |$LN190@CMK_IOCont|
  009b0	00000000	 DCD         |??_C@_1IA@DGANCHDM@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?3?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAa?$AAl@|
  009b4		 |$LN191@CMK_IOCont|
  009b4	00000000	 DCD         |??_C@_1GO@HIHOKAPN@?$AAC?$AAM?$AAE?$AAM?$AAK?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?3?$AA?5?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAb?$AAl?$AAo?$AAc@|
  009b8		 |$M41567|

			 ENDP  ; |CMK_IOControl|

	END
