<html><head><title>module xdc.runtime.Log</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/* --COPYRIGHT--,ESD
</span>     2    <span class="comment"> *  Copyright (c) 2008 Texas Instruments. All rights reserved. 
</span>     3    <span class="comment"> *  This program and the accompanying materials are made available under the 
</span>     4    <span class="comment"> *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
</span>     5    <span class="comment"> *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
</span>     6    <span class="comment"> *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
</span>     7    <span class="comment"> *  Distribution License is available at 
</span>     8    <span class="comment"> *  http://www.eclipse.org/org/documents/edl-v10.php.
</span>     9    <span class="comment"> *
</span>    10    <span class="comment"> *  Contributors:
</span>    11    <span class="comment"> *      Texas Instruments - initial implementation
</span>    12    <span class="comment"> * --/COPYRIGHT--*/</span>
    13    <span class="comment">/*
</span>    14    <span class="comment"> *  ======== Log.xdc ========
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> *! Revision History
</span>    17    <span class="comment"> *! ================
</span>    18    <span class="comment"> *! 06-May-2009 cmcc    Fixed ROV bug SDOCM00057314
</span>    19    <span class="comment"> *! 06-Feb-2008 nitya   Fixed SDSCM00020676
</span>    20    <span class="comment"> *! 17-Dec-2007 sasha   implemented code review changes
</span>    21    <span class="comment"> */</span>
    22    
    23    <span class="xdoc">/*!
</span>    24    <span class="xdoc"> *  ======== Log ========
</span>    25    <span class="xdoc"> *  Event logging manager
</span>    26    <span class="xdoc"> *
</span>    27    <span class="xdoc"> *  RTSC modules and the application code generate `{<b>@link</b> #Event Log_Event}`
</span>    28    <span class="xdoc"> *  events by calling the `Log` module's functions. The `Log` module then
</span>    29    <span class="xdoc"> *  passes those events to an `{<b>@link</b> ILogger}` instance assigned to the event
</span>    30    <span class="xdoc"> *  originating module, specified by that module's configuration parameter
</span>    31    <span class="xdoc"> *  `common$.logger`. `ILogger` instances handle events, usually converting
</span>    32    <span class="xdoc"> *  events to `{<b>@link</b> #EventRec Log_EventRec}` records prior to recording,
</span>    33    <span class="xdoc"> *  transmitting, or displaying them.
</span>    34    <span class="xdoc"> *
</span>    35    <span class="xdoc"> *  All events generated by a target module are stored and displayed by an
</span>    36    <span class="xdoc"> *  `ILogger`, for example, an instance of
</span>    37    <span class="xdoc"> *  `{<b>@link</b> LoggerBuf xdc.runtime.LoggerBuf}` or
</span>    38    <span class="xdoc"> *  `{<b>@link</b> LoggerSys xdc.runtime.LoggerSys}`. However at runtime, modules
</span>    39    <span class="xdoc"> *  generate events through this module, rather than invoking directly their
</span>    40    <span class="xdoc"> *  `ILogger`s. By doing so,  modules can be configured to use different
</span>    41    <span class="xdoc"> *  `ILogger` implementations without any changes to their source code.
</span>    42    <span class="xdoc"> *  
</span>    43    <span class="xdoc"> *  A logger instance can accept `Log` events from any module, but a module
</span>    44    <span class="xdoc"> *  can put `Log` events to only one logger instance. There can be one or
</span>    45    <span class="xdoc"> *  more logger instances in a system. All `Log` calls that are not in a
</span>    46    <span class="xdoc"> *  module are controlled by the module `{<b>@link</b> Main xdc.runtime.Main}`.
</span>    47    <span class="xdoc"> *  For example, top-level application code or any existing sources that
</span>    48    <span class="xdoc"> *  simply call the `Log` or `Assert` methods implicitly use the logger
</span>    49    <span class="xdoc"> *  associated with the `Main` module.
</span>    50    <span class="xdoc"> *
</span>    51    <span class="xdoc"> *  The generation of a `Log` event is controlled by a module's diagnostics
</span>    52    <span class="xdoc"> *  mask, which is described in details in `{<b>@link</b> Diags}`. Each `Log` event
</span>    53    <span class="xdoc"> *  is associated with a mask. `Log` events are generated only when a
</span>    54    <span class="xdoc"> *  particular bit is set in both the `Log` event mask
</span>    55    <span class="xdoc"> *  and the module's diagnostics mask. For example, a `Log` event mask with
</span>    56    <span class="xdoc"> *  the `{<b>@link</b> Diags#USER1 USER1}` bit set is generated only when the `USER1`
</span>    57    <span class="xdoc"> *  bit is also set in the module's diagnostics mask.
</span>    58    <span class="xdoc"> *
</span>    59    <span class="xdoc"> *  There are two ways to generate `Log` events:
</span>    60    <span class="xdoc"> *
</span>    61    <span class="xdoc"> *  <b>@p(blist)</b>
</span>    62    <span class="xdoc"> *  - `{<b>@link</b> #write8 LOG_write()}`, which is tailored for module writers
</span>    63    <span class="xdoc"> *  and takes full advantage of the XDC configuration model. For example,
</span>    64    <span class="xdoc"> *  the message string associated with the `Log` event need not be a part of
</span>    65    <span class="xdoc"> *  the final application, significantly reducing the "footprint overhead"
</span>    66    <span class="xdoc"> *  of embedding diagnostics in deployed systems. The `Log_write[0-8]()`
</span>    67    <span class="xdoc"> *  functions allow up to 8 values to be passed to the logger. They expect
</span>    68    <span class="xdoc"> *  the logger to handle any formatting. A `Log` event type allows you to
</span>    69    <span class="xdoc"> *  specify the type of event.
</span>    70    <span class="xdoc"> *  - `{<b>@link</b> #print6 LOG_print()}`, which is designed for arbitrary C code.
</span>    71    <span class="xdoc"> *  The `Log_print[0-6]()` functions allow up to 6 values to be passed along
</span>    72    <span class="xdoc"> *  with a printf-like format string to the logger. They handle printf-style
</span>    73    <span class="xdoc"> *  formatting.
</span>    74    <span class="xdoc"> *  <b>@p</b>
</span>    75    <span class="xdoc"> *
</span>    76    <span class="xdoc"> *  Both functions are controlled by the module's diagnostics mask. Their
</span>    77    <span class="xdoc"> *  storage or output is defined by the logger that is assigned to the
</span>    78    <span class="xdoc"> *  module that calls the `Log` methods or to the 
</span>    79    <span class="xdoc"> *  `{<b>@link</b> Main xdc.runtime.Main}` module if the caller is not part of a
</span>    80    <span class="xdoc"> *  module.
</span>    81    <span class="xdoc"> *
</span>    82    <span class="xdoc"> *  The `Log` function call sites are implemented in such a way that an
</span>    83    <span class="xdoc"> *  optimizer can completely eliminate `Log` code from the program if the
</span>    84    <span class="xdoc"> *  `Log` functions have been permanently disabled at configuration time. If
</span>    85    <span class="xdoc"> *  the `Log` functions are permanently turned on at configuration time,
</span>    86    <span class="xdoc"> *  then the optimizer can eliminate all runtime conditional checking and
</span>    87    <span class="xdoc"> *  simply invoke the `Log` functions directly. Runtime checking is performed
</span>    88    <span class="xdoc"> *  only when the `Log` functions are configured to be runtime modifiable.
</span>    89    <span class="xdoc"> *
</span>    90    <span class="xdoc"> *  <b>@a(Examples)</b>
</span>    91    <span class="xdoc"> *  Example 1: The following example defines a `Log` event, uses that `Log`
</span>    92    <span class="xdoc"> *  event in a module, and configures the program to generate the `Log`
</span>    93    <span class="xdoc"> *  event. In this example, both `USER1` and `USER2` bits are set in the
</span>    94    <span class="xdoc"> *  event mask. This means that if either bit is set in the module's
</span>    95    <span class="xdoc"> *  diagnostics mask, then the `Log` event will be generated.
</span>    96    <span class="xdoc"> *
</span>    97    <span class="xdoc"> *  This is a part of the XDC specification file for the `Mod` module
</span>    98    <span class="xdoc"> *  (Mod.xdc):
</span>    99    <span class="xdoc"> *
</span>   100    <span class="xdoc"> *  <b>@p(code)</b>
</span>   101    <span class="xdoc"> *  import xdc.runtime.Diags;
</span>   102    <span class="xdoc"> *  import xdc.runtime.Log;
</span>   103    <span class="xdoc"> *
</span>   104    <span class="xdoc"> *  config Log.Event L_someEvent = {
</span>   105    <span class="xdoc"> *      mask: Diags.USER1 | Diags.USER2,
</span>   106    <span class="xdoc"> *      msg: "my log event message, arg1: 0x%x, arg2: 0x%x"
</span>   107    <span class="xdoc"> *  };
</span>   108    <span class="xdoc"> *  <b>@p</b>
</span>   109    <span class="xdoc"> *
</span>   110    <span class="xdoc"> *  This is a part of the C code implementation of the Mod module:
</span>   111    <span class="xdoc"> *
</span>   112    <span class="xdoc"> *  <b>@p(code)</b>
</span>   113    <span class="xdoc"> *  #include &lt;xdc/runtime/Log.h&gt;
</span>   114    <span class="xdoc"> *  UInt x, y;
</span>   115    <span class="xdoc"> *
</span>   116    <span class="xdoc"> *  Log_write2(Mod_L_someEvent, (IArg)x, (IArg)y);
</span>   117    <span class="xdoc"> *  <b>@p</b>
</span>   118    <span class="xdoc"> *
</span>   119    <span class="xdoc"> *  The following configuration script demonstrates how the application might
</span>   120    <span class="xdoc"> *  control the `Log` statements embedded in the `Mod` module at configuration
</span>   121    <span class="xdoc"> *  time. In this case, the configuration script arranges for the `Log`
</span>   122    <span class="xdoc"> *  statements within the `Mod` module (shown above) to always generate events.
</span>   123    <span class="xdoc"> *  Without these configuration statements, no `Log` events would be generated
</span>   124    <span class="xdoc"> *  by this module.
</span>   125    <span class="xdoc"> *
</span>   126    <span class="xdoc"> *  This is part of the XDC configuration file for the application:
</span>   127    <span class="xdoc"> *
</span>   128    <span class="xdoc"> *  <b>@p(code)</b>
</span>   129    <span class="xdoc"> *  var Diags = xdc.useModule('xdc.runtime.Diags');
</span>   130    <span class="xdoc"> *  var Mod = xdc.useModule('my.pkg.Mod');
</span>   131    <span class="xdoc"> *  Mod.common$.diags_USER1 = Diags.ALWAYS_ON;
</span>   132    <span class="xdoc"> *  <b>@p</b>
</span>   133    <span class="xdoc"> *
</span>   134    <span class="xdoc"> *  <b>@p(html)</b>
</span>   135    <span class="xdoc"> *  &lt;hr /&gt;
</span>   136    <span class="xdoc"> *  <b>@p</b>
</span>   137    <span class="xdoc"> *
</span>   138    <span class="xdoc"> *  Example 2: The following XDC configuration statements turn on enter
</span>   139    <span class="xdoc"> *  and exit logging at configuration time for a module. Without any other
</span>   140    <span class="xdoc"> *  changes in the runtime code, every time a module `Mod`'s function is 
</span>   141    <span class="xdoc"> *  being called or exits, an event will be logged.
</span>   142    <span class="xdoc"> *
</span>   143    <span class="xdoc"> *  <b>@p(code)</b>
</span>   144    <span class="xdoc"> *  var Diags = xdc.useModule('xdc.runtime.Diags');
</span>   145    <span class="xdoc"> *  var Mod = xdc.useModule('my.pkg.Mod');
</span>   146    <span class="xdoc"> *
</span>   147    <span class="xdoc"> *  Mod.common$.diags_ENTER = Diags.ALWAYS_ON;
</span>   148    <span class="xdoc"> *  Mod.common$.diags_EXIT = Diags.ALWAYS_ON;
</span>   149    <span class="xdoc"> *  <b>@p</b>
</span>   150    <span class="xdoc"> *
</span>   151    <span class="xdoc"> *  <b>@p(html)</b>
</span>   152    <span class="xdoc"> *  &lt;hr /&gt;
</span>   153    <span class="xdoc"> *  <b>@p</b>
</span>   154    <span class="xdoc"> *
</span>   155    <span class="xdoc"> *  Example 3: The following example configures a module to support enter and
</span>   156    <span class="xdoc"> *  exit logging, but defers the actual activation and deactivation of the
</span>   157    <span class="xdoc"> *  logging until runtime. See the `{<b>@link</b> Diags#setMask Diags_setMask()}`
</span>   158    <span class="xdoc"> *  function for details on specifying the control string.
</span>   159    <span class="xdoc"> *
</span>   160    <span class="xdoc"> *  This is a part of the XDC configuration file for the application:
</span>   161    <span class="xdoc"> *
</span>   162    <span class="xdoc"> *  <b>@p(code)</b>
</span>   163    <span class="xdoc"> *  var Diags = xdc.useModule('xdc.runtime.Diags');
</span>   164    <span class="xdoc"> *  var Mod = xdc.useModule('my.pkg.Mod');
</span>   165    <span class="xdoc"> *
</span>   166    <span class="xdoc"> *  Mod.common$.diags_ENTER = Diags.RUNTIME_OFF;
</span>   167    <span class="xdoc"> *  Mod.common$.diags_EXIT = Diags.RUNTIME_OFF;
</span>   168    <span class="xdoc"> *  <b>@p</b>
</span>   169    <span class="xdoc"> *
</span>   170    <span class="xdoc"> *  This is a part of the C code for the application:
</span>   171    <span class="xdoc"> *
</span>   172    <span class="xdoc"> *  <b>@p(code)</b>
</span>   173    <span class="xdoc"> *  // turn on enter and exit logging in the module
</span>   174    <span class="xdoc"> *  Diags_setMask("my.pkg.Mod+EX");
</span>   175    <span class="xdoc"> *
</span>   176    <span class="xdoc"> *  // turn off enter and exit logging in the module
</span>   177    <span class="xdoc"> *  Diags_setMask("my.pkg.Mod-EX");
</span>   178    <span class="xdoc"> *  <b>@p</b>
</span>   179    <span class="xdoc"> */</span>
   180    
   181    @CustomHeader
   182    
   183    <span class=key>module</span> Log {
   184    
   185        <span class="xdoc">/*!
</span>   186    <span class="xdoc">     *  ======== NUMARGS ========
</span>   187    <span class="xdoc">     *  Maximum number of arguments supported in `Log` events.
</span>   188    <span class="xdoc">     */</span>
   189        <span class=key>const</span> Int NUMARGS = 8;
   190    
   191        <span class="xdoc">/*!
</span>   192    <span class="xdoc">     *  ======== PRINTFID ========
</span>   193    <span class="xdoc">     *  The `EventId` for `Log_print()` events
</span>   194    <span class="xdoc">     */</span>
   195        <span class=key>const</span> EventId PRINTFID = 0;
   196        
   197        <span class="xdoc">/*! 
</span>   198    <span class="xdoc">     *  ======== EventDesc ========
</span>   199    <span class="xdoc">     *  `Log` event descriptor
</span>   200    <span class="xdoc">     *
</span>   201    <span class="xdoc">     *  Each `Log` event is defined by a `Log` event descriptor.
</span>   202    <span class="xdoc">     *
</span>   203    <span class="xdoc">     *  The `mask` defines which bits in the module's diagnostics mask
</span>   204    <span class="xdoc">     *  enable this `Log` event.  Events "posted" via `Log_write` are only
</span>   205    <span class="xdoc">     *  written to the underlying logger if one of the mask's bits matches 
</span>   206    <span class="xdoc">     *  the caller's module diagnostics settings (see
</span>   207    <span class="xdoc">     *  `{<b>@link</b> xdc.runtime.Types#common$}`).
</span>   208    <span class="xdoc">     *
</span>   209    <span class="xdoc">     *  The `msg` defines a printf style format string that defines how to
</span>   210    <span class="xdoc">     *  render the arguments passed along the event in a `Log_write` call.
</span>   211    <span class="xdoc">     *  For a description of the allowable format strings see
</span>   212    <span class="xdoc">     *  `{<b>@link</b> #print6}`.
</span>   213    <span class="xdoc">     *
</span>   214    <span class="xdoc">     *  <b>@see</b> #write8
</span>   215    <span class="xdoc">     *  <b>@see</b> #print6
</span>   216    <span class="xdoc">     */</span>
   217        <span class=key>metaonly</span> <span class=key>struct</span> EventDesc {
   218            Diags.Mask  mask;   <span class="xdoc">/*! event enable mask */</span>
   219            String      msg;    <span class="xdoc">/*! event "printf" message format string */</span>
   220        };
   221    
   222        <span class="xdoc">/*!
</span>   223    <span class="xdoc">     *  ======== EventRec ========
</span>   224    <span class="xdoc">     *  The target representation of a recorded event
</span>   225    <span class="xdoc">     *
</span>   226    <span class="xdoc">     *  This structure defines how events are recorded on the target.
</span>   227    <span class="xdoc">     */</span>
   228        <span class=key>struct</span> EventRec {
   229            Types.Timestamp64 tstamp;   <span class="xdoc">/*! time event was written */</span>
   230            Bits32 serial;              <span class="xdoc">/*! serial number of event */</span>
   231            Types.Event evt;            <span class="xdoc">/*! target encoding of an Event */</span>
   232            IArg arg[NUMARGS];          <span class="xdoc">/*! arguments passed via Log_write/print */</span>
   233        }
   234    
   235        <span class="xdoc">/*! 
</span>   236    <span class="xdoc">     *  ======== Event ========
</span>   237    <span class="xdoc">     *  `Log` event type
</span>   238    <span class="xdoc">     *
</span>   239    <span class="xdoc">     *  An `Event` is represented on the target as a 32-bit value that can
</span>   240    <span class="xdoc">     *  be decoded offline to recover the `Event` information defined in
</span>   241    <span class="xdoc">     *  a corresponding metaonly `EventDesc`.  In addition, `Event`s may be
</span>   242    <span class="xdoc">     *  decoded at runtime via methods provided in this module; see
</span>   243    <span class="xdoc">     *  `{<b>@link</b> #getMask}` and `{<b>@link</b> #getEventId}`.
</span>   244    <span class="xdoc">     *
</span>   245    <span class="xdoc">     *  When an event is "raised" a `{<b>@link</b> Types#Event Types_Event}` is
</span>   246    <span class="xdoc">     *  created which has the same event ID as the `Log_Event` but also
</span>   247    <span class="xdoc">     *  encodes the module ID of the caller.  This new event is passed to
</span>   248    <span class="xdoc">     *  the underlying `{<b>@link</b> ILogger}` module along with any arguments
</span>   249    <span class="xdoc">     *  associated with the event.
</span>   250    <span class="xdoc">     *
</span>   251    <span class="xdoc">     *  <b>@see</b> #getMask
</span>   252    <span class="xdoc">     *  <b>@see</b> #getEventId
</span>   253    <span class="xdoc">     */</span>
   254        @Encoded <span class=key>typedef</span> EventDesc Event;
   255    
   256        <span class="xdoc">/*!
</span>   257    <span class="xdoc">     *  ======== EventId ========
</span>   258    <span class="xdoc">     *  Unique ID embedded in each `{<b>@link</b> #Event}`
</span>   259    <span class="xdoc">     *
</span>   260    <span class="xdoc">     *  This ID must be used to compare two `Event`s for equality.  Event
</span>   261    <span class="xdoc">     *  ids are not guaranteed to remain constant between different
</span>   262    <span class="xdoc">     *  configurations of an application.  For example, adding a module
</span>   263    <span class="xdoc">     *  may cause the event ids of another module to change.
</span>   264    <span class="xdoc">     *
</span>   265    <span class="xdoc">     *  However, event ids declared by a module are guaranteed to be
</span>   266    <span class="xdoc">     *  consecutive values starting from the first declared
</span>   267    <span class="xdoc">     *  `{<b>@link</b> #Event Log_Event}` and increasing to the last declared
</span>   268    <span class="xdoc">     *  event.  As a result, clients of a module can efficiently test ranges
</span>   269    <span class="xdoc">     *  of events and modules can add new events, such as internal trace
</span>   270    <span class="xdoc">     *  events, without breaking clients; simply be careful to add new events
</span>   271    <span class="xdoc">     *  after any existing events in you module's `.xdc` specification.
</span>   272    <span class="xdoc">     *
</span>   273    <span class="xdoc">     *  <b>@see</b> #getEventId
</span>   274    <span class="xdoc">     *  <b>@see</b> #Event
</span>   275    <span class="xdoc">     */</span>
   276        <span class=key>typedef</span> Types.RopeId EventId;
   277        
   278        <span class="xdoc">/*! 
</span>   279    <span class="xdoc">     *  ======== L_construct ========
</span>   280    <span class="xdoc">     *  Lifecycle event posted when an instance is constructed
</span>   281    <span class="xdoc">     */</span>
   282        <span class=key>config</span> Log.Event L_construct = {
   283            mask: Diags.LIFECYCLE, msg: <span class="string">"&lt;-- construct: %p('%s')"</span>
   284        };
   285    
   286        <span class="xdoc">/*!
</span>   287    <span class="xdoc">     *  ======== L_create ========
</span>   288    <span class="xdoc">     *  Lifecycle event posted when an instance is created
</span>   289    <span class="xdoc">     */</span>
   290        <span class=key>config</span> Log.Event L_create = {
   291            mask: Diags.LIFECYCLE, msg: <span class="string">"&lt;-- create: %p('%s')"</span>
   292        };
   293    
   294        <span class="xdoc">/*!
</span>   295    <span class="xdoc">     *  ======== L_destruct ========
</span>   296    <span class="xdoc">     *  Lifecycle event posted when an instance is destructed
</span>   297    <span class="xdoc">     */</span>
   298        <span class=key>config</span> Log.Event L_destruct = {
   299            mask: Diags.LIFECYCLE, msg: <span class="string">"--&gt; destruct: (%p)"</span>
   300        };
   301    
   302        <span class="xdoc">/*!
</span>   303    <span class="xdoc">     *  ======== L_delete ========
</span>   304    <span class="xdoc">     *  Lifecycle event posted when an instance is deleted
</span>   305    <span class="xdoc">     */</span>
   306        <span class=key>config</span> Log.Event L_delete = {
   307            mask: Diags.LIFECYCLE, msg: <span class="string">"--&gt; delete: (%p)"</span>
   308        };
   309    
   310        <span class="xdoc">/*!
</span>   311    <span class="xdoc">     *  ======== getMask ========
</span>   312    <span class="xdoc">     *  Get the `Diags` mask for the specified (encoded) event
</span>   313    <span class="xdoc">     *
</span>   314    <span class="xdoc">     *  <b>@param(evt)</b>     the `Log` event encoding a mask and event ID
</span>   315    <span class="xdoc">     *
</span>   316    <span class="xdoc">     *  <b>@a(returns)</b>     `Diags` mask for the specified event
</span>   317    <span class="xdoc">     */</span>
   318        @Macro Diags.Mask getMask(Event evt);
   319    
   320        <span class="xdoc">/*!
</span>   321    <span class="xdoc">     *  ======== getRope ========
</span>   322    <span class="xdoc">     *  Get RopeId of the Event.msg for the specified (encoded) event
</span>   323    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   324    <span class="xdoc">     */</span>
   325        @Macro Text.RopeId getRope(Event evt);
   326    
   327        <span class="xdoc">/*!
</span>   328    <span class="xdoc">     *  ======== getEventId ========
</span>   329    <span class="xdoc">     *  Get event ID of the specified (encoded) event
</span>   330    <span class="xdoc">     *
</span>   331    <span class="xdoc">     *  This method is used to compare "known" `Log` events with
</span>   332    <span class="xdoc">     *  "raised" `{<b>@link</b> Types#Event Types_Event}`.
</span>   333    <span class="xdoc">     *
</span>   334    <span class="xdoc">     *  <b>@param(evt)</b>     the `Log` event encoding a mask and event ID
</span>   335    <span class="xdoc">     *
</span>   336    <span class="xdoc">     *  <b>@a(returns)</b>     event ID of the specified event
</span>   337    <span class="xdoc">     *
</span>   338    <span class="xdoc">     *  <b>@see</b> Types#getEventId
</span>   339    <span class="xdoc">     */</span>
   340        @Macro EventId getEventId(Event evt);
   341    
   342        <span class="xdoc">/*!
</span>   343    <span class="xdoc">     *  ======== print0 ========
</span>   344    <span class="xdoc">     *  Generate a `Log` "print event" with 0 arguments
</span>   345    <span class="xdoc">     *
</span>   346    <span class="xdoc">     *  <b>@see</b> #print6
</span>   347    <span class="xdoc">     */</span>
   348        @Macro Void print0(Diags.Mask mask, String fmt);
   349    
   350        <span class="xdoc">/*!
</span>   351    <span class="xdoc">     *  ======== print1 ========
</span>   352    <span class="xdoc">     *  Generate a `Log` "print event" with 1 argument
</span>   353    <span class="xdoc">     *
</span>   354    <span class="xdoc">     *  <b>@see</b> #print6
</span>   355    <span class="xdoc">     */</span>
   356        @Macro Void print1(Diags.Mask mask, String fmt, IArg a1);
   357    
   358        <span class="xdoc">/*!
</span>   359    <span class="xdoc">     *  ======== print2 ========
</span>   360    <span class="xdoc">     *  Generate a `Log` "print event" with 2 arguments
</span>   361    <span class="xdoc">     *
</span>   362    <span class="xdoc">     *  <b>@see</b> #print6
</span>   363    <span class="xdoc">     */</span>
   364        @Macro Void print2(Diags.Mask mask, String fmt, IArg a1, IArg a2);
   365    
   366        <span class="xdoc">/*!
</span>   367    <span class="xdoc">     *  ======== print3 ========
</span>   368    <span class="xdoc">     *  Generate a `Log` "print event" with 3 arguments
</span>   369    <span class="xdoc">     *
</span>   370    <span class="xdoc">     *  <b>@see</b> #print6
</span>   371    <span class="xdoc">     */</span>
   372        @Macro Void print3(Diags.Mask mask, String fmt, IArg a1, IArg a2, IArg a3);
   373    
   374        <span class="xdoc">/*!
</span>   375    <span class="xdoc">     *  ======== print4 ========
</span>   376    <span class="xdoc">     *  Generate a `Log` "print event" with 4 arguments
</span>   377    <span class="xdoc">     *
</span>   378    <span class="xdoc">     *  <b>@see</b> #print6
</span>   379    <span class="xdoc">     */</span>
   380        @Macro Void print4(Diags.Mask mask, String fmt, IArg a1, IArg a2, IArg a3,
   381            IArg a4);
   382    
   383        <span class="xdoc">/*!
</span>   384    <span class="xdoc">     *  ======== print5 ========
</span>   385    <span class="xdoc">     *  Generate a `Log` "print event" with 5 arguments
</span>   386    <span class="xdoc">     *
</span>   387    <span class="xdoc">     *  <b>@see</b> #print6
</span>   388    <span class="xdoc">     */</span>
   389        @Macro Void print5(Diags.Mask mask, String fmt, IArg a1, IArg a2, IArg a3,
   390            IArg a4, IArg a5);
   391    
   392        <span class="xdoc">/*!
</span>   393    <span class="xdoc">     *  ======== print6 ========
</span>   394    <span class="xdoc">     *  Generate a `Log` "print event" with 6 arguments
</span>   395    <span class="xdoc">     *
</span>   396    <span class="xdoc">     *  As a convenience to C (as well as assembly language) programmers,
</span>   397    <span class="xdoc">     *  the `Log` module provides a variation of the ever-popular `printf`
</span>   398    <span class="xdoc">     *  function.
</span>   399    <span class="xdoc">     *  The `print[0-6]` functions generate a `Log` "print event" and route
</span>   400    <span class="xdoc">     *  it to the current module's logger.
</span>   401    <span class="xdoc">     *
</span>   402    <span class="xdoc">     *  The arguments passed to `print[0-6]` may be characters, integers,
</span>   403    <span class="xdoc">     *  strings, or pointers.  However, because the declared type of the
</span>   404    <span class="xdoc">     *  arguments is `{<b>@link</b> xdc IArg}`, all pointer arguments must be cast
</span>   405    <span class="xdoc">     *  to an `IArg` type.  `IArg` is an integral type large enough to hold
</span>   406    <span class="xdoc">     *  any pointer or an `int`.  So, casting a pointer to an `IArg` does
</span>   407    <span class="xdoc">     *  not cause any loss of information and C's normal integer conversions
</span>   408    <span class="xdoc">     *  make the cast unnecessary for integral arguments.
</span>   409    <span class="xdoc">     *
</span>   410    <span class="xdoc">     *  The format string can use the following conversion characters.
</span>   411    <span class="xdoc">     *  However, it is important to recall that all arguments referenced by
</span>   412    <span class="xdoc">     *  these conversion characters have been converted to an `IArg`
</span>   413    <span class="xdoc">     *  prior to conversion; so, the use of "length modifiers" should be
</span>   414    <span class="xdoc">     *  avoided.
</span>   415    <span class="xdoc">     *
</span>   416    <span class="xdoc">     *  <b>@p(code)</b>
</span>   417    <span class="xdoc">     *  Conversion Character    Description
</span>   418    <span class="xdoc">     *  ------------------------------------------------
</span>   419    <span class="xdoc">     *  %c                      Character
</span>   420    <span class="xdoc">     *  %d                      Signed integer
</span>   421    <span class="xdoc">     *  %u                      Unsigned integer
</span>   422    <span class="xdoc">     *  %x                      Unsigned hexadecimal integer
</span>   423    <span class="xdoc">     *  %o                      Unsigned octal integer
</span>   424    <span class="xdoc">     *  %s                      Character string
</span>   425    <span class="xdoc">     *  %p                      Pointer
</span>   426    <span class="xdoc">     *  %f                      Single precision floating point (float)
</span>   427    <span class="xdoc">     *  <b>@p</b>
</span>   428    <span class="xdoc">     *
</span>   429    <span class="xdoc">     *  Format strings, while very convenient, are a well known source of
</span>   430    <span class="xdoc">     *  portability problems: each format specification must precisely match
</span>   431    <span class="xdoc">     *  the types of the arguments passed. Underlying "printf" functions use
</span>   432    <span class="xdoc">     *  the format string to determine how far to advance through their
</span>   433    <span class="xdoc">     *  argument list. For targets where pointer types and integers are the
</span>   434    <span class="xdoc">     *  same size there are no problems.  However, suppose a target's pointer
</span>   435    <span class="xdoc">     *  type is larger than its integer type. In this case, because integer
</span>   436    <span class="xdoc">     *  arguments are widened to be of type `IArg`, a format specification of
</span>   437    <span class="xdoc">     *  "%d" causes an underlying `printf()` implementation to read the
</span>   438    <span class="xdoc">     *  extended part of the integer argument as part of the next argument(!).
</span>   439    <span class="xdoc">     *
</span>   440    <span class="xdoc">     *  To get around this problem and still allow the use of "natural" 
</span>   441    <span class="xdoc">     *  format specifications (e.g., `%d` and `%x` with optional width
</span>   442    <span class="xdoc">     *  specifications), `{<b>@link</b> System#aprintf()}` is used which assumes
</span>   443    <span class="xdoc">     *  that all arguments have been widened to be of type `IArg`.
</span>   444    <span class="xdoc">     *
</span>   445    <span class="xdoc">     *  See `{<b>@link</b> System#printf}` for complete details.
</span>   446    <span class="xdoc">     *
</span>   447    <span class="xdoc">     *  The `%f` format specifier is used to print a single precision float
</span>   448    <span class="xdoc">     *  value. Note that `%f` assumes that sizeof(Float) &lt;= sizeof(IArg).
</span>   449    <span class="xdoc">     *  Most clients that interpret float values except that they are
</span>   450    <span class="xdoc">     *  represented in IEEE 754 floating point format. Therefore, it is
</span>   451    <span class="xdoc">     *  recommended that the float values are converted into that format prior
</span>   452    <span class="xdoc">     *  to supplying the values to `Log` functions in cases where targets do
</span>   453    <span class="xdoc">     *  not generate the float values in IEEE 754 floating point format by
</span>   454    <span class="xdoc">     *  default.
</span>   455    <span class="xdoc">     *
</span>   456    <span class="xdoc">     *  <b>@param(mask)</b>    enable bits for this `Log` event
</span>   457    <span class="xdoc">     *  <b>@param(fmt)</b>     a `printf` style format string
</span>   458    <span class="xdoc">     *  <b>@param(a1)</b>      value for first format conversion character
</span>   459    <span class="xdoc">     *  <b>@param(a2)</b>      value for second format conversion character
</span>   460    <span class="xdoc">     *  <b>@param(a3)</b>      value for third format conversion character
</span>   461    <span class="xdoc">     *  <b>@param(a4)</b>      value for fourth format conversion character
</span>   462    <span class="xdoc">     *  <b>@param(a5)</b>      value for fifth format conversion character
</span>   463    <span class="xdoc">     *  <b>@param(a6)</b>      value for sixth format conversion character
</span>   464    <span class="xdoc">     *
</span>   465    <span class="xdoc">     *  <b>@a(Examples)</b>
</span>   466    <span class="xdoc">     *  The following example demonstrates a typical usage.
</span>   467    <span class="xdoc">     *  <b>@p(code)</b>
</span>   468    <span class="xdoc">     *  String  list[];
</span>   469    <span class="xdoc">     *  UInt    i;
</span>   470    <span class="xdoc">     *
</span>   471    <span class="xdoc">     *  Log_print2(Diags_USER2, "list[%u] = %s\n", i, (IArg)list[i]);
</span>   472    <span class="xdoc">     *  <b>@p</b>
</span>   473    <span class="xdoc">     *  Note that the `IArg` cast above is only necessary for pointer
</span>   474    <span class="xdoc">     *  arguments; C's normal parameter conversions implicitly convert
</span>   475    <span class="xdoc">     *  integral arguments.
</span>   476    <span class="xdoc">     */</span>
   477        @Macro Void print6(Diags.Mask mask, String fmt, IArg a1, IArg a2, IArg a3,
   478            IArg a4, IArg a5, IArg a6);
   479    
   480        <span class="xdoc">/*!
</span>   481    <span class="xdoc">     *  ======== put4 ========
</span>   482    <span class="xdoc">     *  Unconditionally put the specified `Types` event
</span>   483    <span class="xdoc">     *
</span>   484    <span class="xdoc">     *  This method unconditionally puts the specified `{<b>@link</b> Types#Event}`
</span>   485    <span class="xdoc">     *  `evt` into the log.  This type of event is created either implicitly
</span>   486    <span class="xdoc">     *  (and passed to an `{<b>@link</b> ILogger}` implementation) or explicitly
</span>   487    <span class="xdoc">     *  via `{<b>@link</b> Types#makeEvent()}`.
</span>   488    <span class="xdoc">     *
</span>   489    <span class="xdoc">     *  <b>@param(evt)</b>     the `Types` event to put into the log
</span>   490    <span class="xdoc">     *  <b>@param(a1)</b>      value for first format conversion character
</span>   491    <span class="xdoc">     *  <b>@param(a2)</b>      value for second format conversion character
</span>   492    <span class="xdoc">     *  <b>@param(a3)</b>      value for third format conversion character
</span>   493    <span class="xdoc">     *  <b>@param(a4)</b>      value for fourth format conversion character
</span>   494    <span class="xdoc">     *
</span>   495    <span class="xdoc">     *  <b>@see</b> #put8
</span>   496    <span class="xdoc">     */</span>
   497        @Macro Void put4(Types.Event evt, IArg a1, IArg a2, IArg a3, IArg a4);
   498    
   499        <span class="xdoc">/*!
</span>   500    <span class="xdoc">     *  ======== put8 ========
</span>   501    <span class="xdoc">     *  Unconditionally put the specified `Types` event
</span>   502    <span class="xdoc">     *
</span>   503    <span class="xdoc">     *  This method is identical to `{<b>@link</b> #put4}` except that it allows
</span>   504    <span class="xdoc">     *  up to eight arguments to be passed.
</span>   505    <span class="xdoc">     *  
</span>   506    <span class="xdoc">     *  <b>@see</b> #put4
</span>   507    <span class="xdoc">     */</span>
   508        @Macro Void put8(Types.Event evt, IArg a1, IArg a2, IArg a3, IArg a4,
   509                            IArg a5, IArg a6, IArg a7, IArg a8);
   510    
   511        <span class="xdoc">/*! 
</span>   512    <span class="xdoc">     *  ======== write0 ========
</span>   513    <span class="xdoc">     *  Generate a `Log` event with 0 arguments
</span>   514    <span class="xdoc">     *
</span>   515    <span class="xdoc">     *  <b>@see</b> #write8
</span>   516    <span class="xdoc">     */</span>
   517        @Macro Void write0(Event evt);
   518    
   519        <span class="xdoc">/*! 
</span>   520    <span class="xdoc">     *  ======== write1 ========
</span>   521    <span class="xdoc">     *  Generate a `Log` event with 1 argument
</span>   522    <span class="xdoc">     *
</span>   523    <span class="xdoc">     *  <b>@see</b> #write8
</span>   524    <span class="xdoc">     */</span>
   525        @Macro Void write1(Event evt, IArg a1);
   526    
   527        <span class="xdoc">/*!
</span>   528    <span class="xdoc">     *  ======== write2 ========
</span>   529    <span class="xdoc">     *  Generate a `Log` event with 2 arguments
</span>   530    <span class="xdoc">     *
</span>   531    <span class="xdoc">     *  <b>@see</b> #write8
</span>   532    <span class="xdoc">     */</span>
   533        @Macro Void write2(Event evt, IArg a1, IArg a2);
   534    
   535        <span class="xdoc">/*!
</span>   536    <span class="xdoc">     *  ======== write3 ========
</span>   537    <span class="xdoc">     *  Generate a `Log` event with 3 arguments
</span>   538    <span class="xdoc">     *
</span>   539    <span class="xdoc">     *  <b>@see</b> #write8
</span>   540    <span class="xdoc">     */</span>
   541        @Macro Void write3(Event evt, IArg a1, IArg a2, IArg a3);
   542    
   543        <span class="xdoc">/*!
</span>   544    <span class="xdoc">     *  ======== write4 ========
</span>   545    <span class="xdoc">     *  Generate a `Log` event with 4 arguments
</span>   546    <span class="xdoc">     *
</span>   547    <span class="xdoc">     *  <b>@see</b> #write8
</span>   548    <span class="xdoc">     */</span>
   549        @Macro Void write4(Event evt, IArg a1, IArg a2, IArg a3, IArg a4);
   550    
   551        <span class="xdoc">/*!
</span>   552    <span class="xdoc">     *  ======== write5 ========
</span>   553    <span class="xdoc">     *  Generate a `Log` event with 5 arguments
</span>   554    <span class="xdoc">     *
</span>   555    <span class="xdoc">     *  <b>@see</b> #write8
</span>   556    <span class="xdoc">     */</span>
   557        @Macro Void write5(Event evt, IArg a1, IArg a2, IArg a3, IArg a4, IArg a5);
   558    
   559        <span class="xdoc">/*!
</span>   560    <span class="xdoc">     *  ======== write6 ========
</span>   561    <span class="xdoc">     *  Generate a `Log` event with 6 arguments
</span>   562    <span class="xdoc">     *
</span>   563    <span class="xdoc">     *  <b>@see</b> #write8
</span>   564    <span class="xdoc">     */</span>
   565        @Macro Void write6(Event evt, IArg a1, IArg a2, IArg a3, IArg a4,
   566                            IArg a5, IArg a6);
   567    
   568        <span class="xdoc">/*!
</span>   569    <span class="xdoc">     *  ======== write7 ========
</span>   570    <span class="xdoc">     *  Generate a `Log` event with 7 arguments
</span>   571    <span class="xdoc">     *
</span>   572    <span class="xdoc">     *  <b>@see</b> #write8
</span>   573    <span class="xdoc">     */</span>
   574        @Macro Void write7(Event evt, IArg a1, IArg a2, IArg a3, IArg a4,
   575                            IArg a5, IArg a6, IArg a7);
   576    
   577        <span class="xdoc">/*!
</span>   578    <span class="xdoc">     *  ======== write8 ========
</span>   579    <span class="xdoc">     *  Generate a `Log` event with 8 arguments
</span>   580    <span class="xdoc">     *
</span>   581    <span class="xdoc">     *  If the mask in the specified `Log` event has any bit set which is
</span>   582    <span class="xdoc">     *  also set in the current module's diagnostics mask, then this call to
</span>   583    <span class="xdoc">     *  write will "raise" the given `Log` event.
</span>   584    <span class="xdoc">     *
</span>   585    <span class="xdoc">     *  <b>@param(evt)</b>     the `Log` event to write
</span>   586    <span class="xdoc">     *  <b>@param(a1)</b>      value for first format conversion character
</span>   587    <span class="xdoc">     *  <b>@param(a2)</b>      value for second format conversion character
</span>   588    <span class="xdoc">     *  <b>@param(a3)</b>      value for third format conversion character
</span>   589    <span class="xdoc">     *  <b>@param(a4)</b>      value for fourth format conversion character
</span>   590    <span class="xdoc">     *  <b>@param(a5)</b>      value for fifth format conversion character
</span>   591    <span class="xdoc">     *  <b>@param(a6)</b>      value for sixth format conversion character
</span>   592    <span class="xdoc">     *  <b>@param(a7)</b>      value for seventh format conversion character
</span>   593    <span class="xdoc">     *  <b>@param(a8)</b>      value for eighth format conversion character
</span>   594    <span class="xdoc">     */</span>
   595        @Macro Void write8(Event evt, IArg a1, IArg a2, IArg a3, IArg a4,
   596                            IArg a5, IArg a6, IArg a7, IArg a8);
   597    
   598        <span class="xdoc">/*!
</span>   599    <span class="xdoc">     *  ======== doPrint ========
</span>   600    <span class="xdoc">     *  Render an event as text via `{<b>@link</b> System#printf System_printf}`
</span>   601    <span class="xdoc">     *
</span>   602    <span class="xdoc">     *  This method is not gated and may make more than one call to
</span>   603    <span class="xdoc">     *  `System_printf`.  This utility method is typically used within the
</span>   604    <span class="xdoc">     *  implementation of a logger which initializes
</span>   605    <span class="xdoc">     *  `{<b>@link</b> #EventRec Log_EventRec}` structures based on `Log` events
</span>   606    <span class="xdoc">     *  produced by the application.
</span>   607    <span class="xdoc">     *
</span>   608    <span class="xdoc">     *  <b>@param(evRec)</b>   a non`NULL` pointer to an initialized `Log_EventRec`
</span>   609    <span class="xdoc">     *                  structure to be formated via
</span>   610    <span class="xdoc">     *                  `{<b>@link</b> System#printf System_printf}`.
</span>   611    <span class="xdoc">     */</span>
   612        Void doPrint(EventRec *evRec);
   613        
   614        <span class="xdoc">/*!
</span>   615    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   616    <span class="xdoc">     *  ======== lookupEventMessage ========
</span>   617    <span class="xdoc">     *  Returns the format string for the event with the given id.
</span>   618    <span class="xdoc">     */</span>
   619        <span class=key>function</span> lookupEventMessage(eventId);
   620    
   621        <span class="xdoc">/*!
</span>   622    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   623    <span class="xdoc">     *  ======== getTargetArgSize ========
</span>   624    <span class="xdoc">     *  Returns the target size of a record argument in bytes (not MAUs).
</span>   625    <span class="xdoc">     */</span>
   626        <span class=key>function</span> getTargetArgSize();
   627                    
   628        <span class="xdoc">/*!
</span>   629    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   630    <span class="xdoc">     *  ======== lookupEventName ========
</span>   631    <span class="xdoc">     */</span>
   632        <span class=key>function</span> lookupEventName(eventId);
   633    
   634        <span class="xdoc">/*!
</span>   635    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   636    <span class="xdoc">     *  ======== lookupModuleName ========
</span>   637    <span class="xdoc">     */</span>
   638        <span class=key>function</span> lookupModuleName(modId);
   639    
   640        <span class="xdoc">/*!
</span>   641    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   642    <span class="xdoc">     *  ======== getTargetEventRecSize ========
</span>   643    <span class="xdoc">     *  Returns the record size in bytes (not MAUs).
</span>   644    <span class="xdoc">     */</span>
   645        <span class=key>function</span> getTargetEventRecSize();
   646    
   647    <span class=key>internal</span>:
   648    
   649        <span class="comment">/*
</span>   650    <span class="comment">     *  ======== idToInfo ========
</span>   651    <span class="comment">     *  Map event ID strings into a string of the form &lt;eventName&gt;::&lt;eventMsg&gt;
</span>   652    <span class="comment">     */</span>
   653        <span class=key>metaonly</span> <span class=key>config</span> String idToInfo[string] = [];
   654        
   655    }
   656    <span class="comment">/*
</span>   657    <span class="comment"> *  @(#) xdc.runtime; 2, 0, 0, 0,237; 2-22-2010 10:33:58; /db/ztree/library/trees/xdc/xdc-u17x/src/packages/
</span>   658    <span class="comment"> */</span>
   659    
</pre>
</body></html>
