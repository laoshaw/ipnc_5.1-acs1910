<html><head><title>module xdc.runtime.Memory</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/* --COPYRIGHT--,ESD
</span>     2    <span class="comment"> *  Copyright (c) 2008 Texas Instruments. All rights reserved. 
</span>     3    <span class="comment"> *  This program and the accompanying materials are made available under the 
</span>     4    <span class="comment"> *  terms of the Eclipse Public License v1.0 and Eclipse Distribution License
</span>     5    <span class="comment"> *  v. 1.0 which accompanies this distribution. The Eclipse Public License is
</span>     6    <span class="comment"> *  available at http://www.eclipse.org/legal/epl-v10.html and the Eclipse
</span>     7    <span class="comment"> *  Distribution License is available at 
</span>     8    <span class="comment"> *  http://www.eclipse.org/org/documents/edl-v10.php.
</span>     9    <span class="comment"> *
</span>    10    <span class="comment"> *  Contributors:
</span>    11    <span class="comment"> *      Texas Instruments - initial implementation
</span>    12    <span class="comment"> * --/COPYRIGHT--*/</span>
    13    <span class="comment">/*
</span>    14    <span class="comment"> *  ======== Memory.xdc ========
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> *! Revision History
</span>    17    <span class="comment"> *! ================
</span>    18    <span class="comment"> *! 11-Mar-2008 toddm  CDOC updates
</span>    19    <span class="comment"> *! 06-Feb-2008 nitya  Fixed SDSCM00019876
</span>    20    <span class="comment"> *! 26-Nov-2007 toddm  Added query
</span>    21    <span class="comment"> *! 08-Jun-2007 nitya  defaultHeapInstance is undefined.
</span>    22    <span class="comment"> *! 25-Sep-2006 toddm  Removed defaultHeapMgr. Using sections instead of 
</span>    23    <span class="comment"> *!                    heaps for static placement.
</span>    24    <span class="comment"> *! 07-Nov-2005 toddm  xdoc and code review tweaks.
</span>    25    <span class="comment"> *! 18-Jul-2005 sasa   Created from xdc.cfg.Memory.
</span>    26    <span class="comment"> */</span>
    27    
    28    <span class="xdoc">/*!
</span>    29    <span class="xdoc"> *  ======== Memory ========
</span>    30    <span class="xdoc"> *  Static and run-time memory manager
</span>    31    <span class="xdoc"> *
</span>    32    <span class="xdoc"> *  All memory allocations are executed via `staticPlace()` at the
</span>    33    <span class="xdoc"> *  config time or through `Memory_alloc()` (or `Memory_calloc()` or
</span>    34    <span class="xdoc"> *  `Memory_valloc()`) at run-time. 
</span>    35    <span class="xdoc"> *
</span>    36    <span class="xdoc"> *  The actual memory management is performed by modules that
</span>    37    <span class="xdoc"> *  implement `{<b>@link</b> xdc.runtime.IHeap}`.  Heap instances are created
</span>    38    <span class="xdoc"> *  statically or dynamically via the heap specific create functions and 
</span>    39    <span class="xdoc"> *  these instances are then passed as input parameters to the `Memory` 
</span>    40    <span class="xdoc"> *  calls with `{<b>@link</b> xdc.runtime.IHeap#Handle}` parameters.
</span>    41    <span class="xdoc"> */</span>
    42    <span class=key>module</span> Memory {
    43    
    44        <span class="xdoc">/*!
</span>    45    <span class="xdoc">     *  ======== Q_BLOCKING ========
</span>    46    <span class="xdoc">     *  Blocking quality
</span>    47    <span class="xdoc">     *
</span>    48    <span class="xdoc">     *  `{<b>@link</b> xdc.runtime.IHeap}`s with this "quality" may cause the
</span>    49    <span class="xdoc">     *  calling thread to block; i.e., suspend execution until another thread
</span>    50    <span class="xdoc">     *  leaves the gate.
</span>    51    <span class="xdoc">     */</span>
    52        <span class=key>const</span> Int Q_BLOCKING = 1;
    53        
    54        <span class="xdoc">/*!
</span>    55    <span class="xdoc">     *  ======== Size ========
</span>    56    <span class="xdoc">     *  Type to be used to specify heap buffer sizes
</span>    57    <span class="xdoc">     */</span>
    58        <span class=key>typedef</span> UArg Size;
    59    
    60        <span class="xdoc">/*!
</span>    61    <span class="xdoc">     *  ======== Stats ========
</span>    62    <span class="xdoc">     *  Memory heap statistics
</span>    63    <span class="xdoc">     *
</span>    64    <span class="xdoc">     *  This structure defines generic statistics that must be supplied
</span>    65    <span class="xdoc">     *  by each module that implements the `{<b>@link</b> xdc.runtime.IHeap}`
</span>    66    <span class="xdoc">     *  interface.
</span>    67    <span class="xdoc">     *
</span>    68    <span class="xdoc">     *  <b>@field(totalSize)</b>         total size (in MADUs) of heap.
</span>    69    <span class="xdoc">     *  <b>@field(totalFreeSize)</b>     current size (in MADUs) of free memory in 
</span>    70    <span class="xdoc">     *                            the heap
</span>    71    <span class="xdoc">     *  <b>@field(largestFreeSize)</b>   current largest contiguous free block 
</span>    72    <span class="xdoc">     *                            (in MADUs)
</span>    73    <span class="xdoc">     */</span>
    74        <span class=key>struct</span> Stats {
    75            Size totalSize;
    76            Size totalFreeSize;
    77            Size largestFreeSize;
    78         }
    79         
    80        <span class="xdoc">/*! <b>@_nodoc</b> */</span>
    81        @XmlDtd
    82        <span class=key>metaonly</span> <span class=key>struct</span> Module_View {
    83            SizeT maxDefaultTypeAlignment;
    84        };
    85    
    86        <span class="xdoc">/*!
</span>    87    <span class="xdoc">     *  ======== defaultHeapInstance ========
</span>    88    <span class="xdoc">     *  The default heap.
</span>    89    <span class="xdoc">     *
</span>    90    <span class="xdoc">     *  If no heap is specified in the `Memory` module's methods (i.e.
</span>    91    <span class="xdoc">     *  heap == `NULL`) `defaultHeapInstance` is used. If
</span>    92    <span class="xdoc">     *  `defaultHeapInstance` is not set (or set to `null`), a
</span>    93    <span class="xdoc">     *  `{<b>@link</b> xdc.runtime.HeapStd}` heap instance is created and assigned
</span>    94    <span class="xdoc">     *  to this configuration parameter. The size of the heap is determined
</span>    95    <span class="xdoc">     *  by the `{<b>@link</b> #defaultHeapSize}` parameter.
</span>    96    <span class="xdoc">     *
</span>    97    <span class="xdoc">     *  By default, all modules are configured with a `null` instance heap.
</span>    98    <span class="xdoc">     *  Instances created by modules with a `null` instance heap are
</span>    99    <span class="xdoc">     *  allocated from the `defaultHeapInstance` heap.
</span>   100    <span class="xdoc">     */</span>
   101        <span class=key>config</span> IHeap.Handle defaultHeapInstance;
   102    
   103        <span class="xdoc">/*!
</span>   104    <span class="xdoc">     *  ======== defaultHeapSize ========
</span>   105    <span class="xdoc">     *  The size (in target MADUs) of the `defaultHeapInstance`.
</span>   106    <span class="xdoc">     *
</span>   107    <span class="xdoc">     *  This parameters is used when the `{<b>@link</b> #defaultHeapInstance}`
</span>   108    <span class="xdoc">     *  is not configured. 
</span>   109    <span class="xdoc">     */</span>
   110        <span class=key>metaonly</span> <span class=key>config</span> <span class=key>int</span> defaultHeapSize = 0x1000;
   111    
   112        <span class="xdoc">/*!
</span>   113    <span class="xdoc">     *  ======== alloc ========
</span>   114    <span class="xdoc">     *  Allocate a block of memory from a heap.
</span>   115    <span class="xdoc">     *
</span>   116    <span class="xdoc">     *  <b>@param(heap)</b>    heap from which the memory is allocated
</span>   117    <span class="xdoc">     *
</span>   118    <span class="xdoc">     *                  The `heap` is created by a module that implements
</span>   119    <span class="xdoc">     *                  the `{<b>@link</b> xdc.runtime.IHeap}` interface.
</span>   120    <span class="xdoc">     *                  If `heap` is `NULL`, the 
</span>   121    <span class="xdoc">     *                  `{<b>@link</b> #defaultHeapInstance}` is used.
</span>   122    <span class="xdoc">     *
</span>   123    <span class="xdoc">     *  <b>@param(size)</b>    requested memory block size (in MADUs)
</span>   124    <span class="xdoc">     *  <b>@param(align)</b>   alignment (in MADUs) of the block of memory
</span>   125    <span class="xdoc">     *
</span>   126    <span class="xdoc">     *                  A value of 0 denotes maximum default type alignment.
</span>   127    <span class="xdoc">     *
</span>   128    <span class="xdoc">     *  <b>@param(eb)</b>      pointer to error block
</span>   129    <span class="xdoc">     *
</span>   130    <span class="xdoc">     *  <b>@a(returns)</b>     
</span>   131    <span class="xdoc">     *  If the allocation was successful, `Memory_alloc()` returns non-`NULL` 
</span>   132    <span class="xdoc">     *  pointer to the allocated and uninitialized block; otherwise it returns 
</span>   133    <span class="xdoc">     *  `NULL` and the error block will indicate the cause of the error.     
</span>   134    <span class="xdoc">     */</span>
   135        Ptr alloc(IHeap.Handle heap, SizeT size, SizeT align, Error.Block *eb);
   136    
   137        <span class="xdoc">/*!
</span>   138    <span class="xdoc">     *  ======== calloc ========
</span>   139    <span class="xdoc">     *  Allocate a block of memory from a heap and zero out the contents.
</span>   140    <span class="xdoc">     *
</span>   141    <span class="xdoc">     *  <b>@param(heap)</b>    heap from which the memory is allocated
</span>   142    <span class="xdoc">     *
</span>   143    <span class="xdoc">     *                  The `heap` is created by a module that implements
</span>   144    <span class="xdoc">     *                  the `{<b>@link</b> xdc.runtime.IHeap}` interface.
</span>   145    <span class="xdoc">     *                  If `heap` is `NULL`, the 
</span>   146    <span class="xdoc">     *                  `{<b>@link</b> #defaultHeapInstance}` is used.
</span>   147    <span class="xdoc">     *
</span>   148    <span class="xdoc">     *  <b>@param(size)</b>    requested memory block size (in MADUs)
</span>   149    <span class="xdoc">     *  <b>@param(align)</b>   alignment (in MADUs) of the block of memory
</span>   150    <span class="xdoc">     *
</span>   151    <span class="xdoc">     *                  A value of 0 denotes maximum default type alignment.
</span>   152    <span class="xdoc">     *
</span>   153    <span class="xdoc">     *  <b>@param(eb)</b>      pointer to error block
</span>   154    <span class="xdoc">     *
</span>   155    <span class="xdoc">     *  <b>@a(returns)</b>
</span>   156    <span class="xdoc">     *  If the allocation was successful, `Memory_calloc()` returns non-`NULL` 
</span>   157    <span class="xdoc">     *  pointer to the allocated and initialized block; otherwise it returns 
</span>   158    <span class="xdoc">     *  `NULL` and the error block will indicate the cause of the error.     
</span>   159    <span class="xdoc">     */</span>
   160        Ptr calloc(IHeap.Handle heap, SizeT size, SizeT align, Error.Block *eb);
   161    
   162        <span class="xdoc">/*!
</span>   163    <span class="xdoc">     *  ======== free ========
</span>   164    <span class="xdoc">     *  Frees the space if the heap manager offers such functionality.
</span>   165    <span class="xdoc">     *
</span>   166    <span class="xdoc">     *  <b>@param(heap)</b>   heap that the block of memory will be freed back to.
</span>   167    <span class="xdoc">     *
</span>   168    <span class="xdoc">     *                 The `heap` is created by a module that implements
</span>   169    <span class="xdoc">     *                 the `{<b>@link</b> xdc.runtime.IHeap}` interface.
</span>   170    <span class="xdoc">     *                 If `heap` is `NULL`, the 
</span>   171    <span class="xdoc">     *                 `{<b>@link</b> #defaultHeapInstance}` is used.
</span>   172    <span class="xdoc">     *
</span>   173    <span class="xdoc">     *  <b>@param(block)</b>  block of memory to free back to the heap
</span>   174    <span class="xdoc">     *  <b>@param(size)</b>   size (in MADUs) of the block of memory to free.
</span>   175    <span class="xdoc">     *
</span>   176    <span class="xdoc">     */</span>
   177        Void free(IHeap.Handle heap, Ptr block, SizeT size);
   178        
   179        <span class="xdoc">/*!
</span>   180    <span class="xdoc">     *  ======== getStats ========
</span>   181    <span class="xdoc">     *  Obtain statistics from a heap.
</span>   182    <span class="xdoc">     *
</span>   183    <span class="xdoc">     *  <b>@param(heap)</b>    the heap to get the statistics from
</span>   184    <span class="xdoc">     *
</span>   185    <span class="xdoc">     *                  The `heap` is created by a module that implements
</span>   186    <span class="xdoc">     *                  the `{<b>@link</b> xdc.runtime.IHeap}` interface.
</span>   187    <span class="xdoc">     *                  If `heap` is `NULL`, the 
</span>   188    <span class="xdoc">     *                  `{<b>@link</b> #defaultHeapInstance}` is used.
</span>   189    <span class="xdoc">     *
</span>   190    <span class="xdoc">     *  <b>@param(stats)</b>   the output buffer for the returned statistics
</span>   191    <span class="xdoc">     */</span>
   192        Void getStats(IHeap.Handle heap, Stats *stats);
   193        
   194        <span class="xdoc">/*!
</span>   195    <span class="xdoc">     *  ======== query ========
</span>   196    <span class="xdoc">     *  Test for a particular `{<b>@link</b> xdc.runtime.IHeap}` quality.
</span>   197    <span class="xdoc">     *
</span>   198    <span class="xdoc">     *  There currently is only one quality, namely `{<b>@link</b> #Q_BLOCKING}`.
</span>   199    <span class="xdoc">     *
</span>   200    <span class="xdoc">     *  <b>@param(heap)</b>    the heap to query
</span>   201    <span class="xdoc">     *
</span>   202    <span class="xdoc">     *                  The `heap` is created by a module that implements
</span>   203    <span class="xdoc">     *                  the `{<b>@link</b> xdc.runtime.IHeap}` interface.  If `heap`
</span>   204    <span class="xdoc">     *                  is `NULL`, the `{<b>@link</b> #defaultHeapInstance}`
</span>   205    <span class="xdoc">     *                  is queried
</span>   206    <span class="xdoc">     *
</span>   207    <span class="xdoc">     *  <b>@param(qual)</b>    quality to test
</span>   208    <span class="xdoc">     *
</span>   209    <span class="xdoc">     *                   For example: `{<b>@link</b> #Q_BLOCKING}`.
</span>   210    <span class="xdoc">     *
</span>   211    <span class="xdoc">     *  <b>@a(returns)</b>
</span>   212    <span class="xdoc">     *  If `heap` has the `qual` quality, this method returns `TRUE`,
</span>   213    <span class="xdoc">     *  otherwise it returns `FALSE`.
</span>   214    <span class="xdoc">     */</span>
   215        Bool query(IHeap.Handle heap, Int qual);
   216    
   217        <span class="xdoc">/*!
</span>   218    <span class="xdoc">     *  ======== getMaxDefaultTypeAlignMeta ========
</span>   219    <span class="xdoc">     *  Return the largest alignment required by the target
</span>   220    <span class="xdoc">     *
</span>   221    <span class="xdoc">     *  This method scans the standard base types supported by the current
</span>   222    <span class="xdoc">     *  configuration's target
</span>   223    <span class="xdoc">     *  (`{<b>@link</b> xdc.cfg.Program#build Program.build.target}`) and returns
</span>   224    <span class="xdoc">     *  the largest alignment required for these types.
</span>   225    <span class="xdoc">     *
</span>   226    <span class="xdoc">     *  <b>@a(returns)</b>     Returns target-specific alignment in MADUs. 
</span>   227    <span class="xdoc">     *
</span>   228    <span class="xdoc">     *  <b>@see</b> xdc.bld.ITarget#stdTypes
</span>   229    <span class="xdoc">     */</span>
   230        <span class=key>metaonly</span> SizeT getMaxDefaultTypeAlignMeta();
   231        
   232        <span class="xdoc">/*!
</span>   233    <span class="xdoc">     *  ======== getMaxDefaultTypeAlign ========
</span>   234    <span class="xdoc">     *  Return the largest alignment required by the target
</span>   235    <span class="xdoc">     *
</span>   236    <span class="xdoc">     *  `getMaxDefaultTypeAlign` returns the largest alignment
</span>   237    <span class="xdoc">     *   required for all the standard base types supported by the current
</span>   238    <span class="xdoc">     *  configuration's target
</span>   239    <span class="xdoc">     *  (`{<b>@link</b> xdc.cfg.Program#build Program.build.target}`) 
</span>   240    <span class="xdoc">     *
</span>   241    <span class="xdoc">     *  This is the runtime version of the
</span>   242    <span class="xdoc">     *  `{<b>@link</b> #getMaxDefaultTypeAlignMeta}` function.      
</span>   243    <span class="xdoc">     *
</span>   244    <span class="xdoc">     *  <b>@a(returns)</b>     Returns target-specific alignment in MADUs. 
</span>   245    <span class="xdoc">     *
</span>   246    <span class="xdoc">     *  <b>@see</b> #getMaxDefaultTypeAlignMeta
</span>   247    <span class="xdoc">     */</span>
   248        SizeT getMaxDefaultTypeAlign();
   249    
   250        <span class="xdoc">/*!
</span>   251    <span class="xdoc">     *  ======== staticPlace ========
</span>   252    <span class="xdoc">     *  Statically places buffers.
</span>   253    <span class="xdoc">     *
</span>   254    <span class="xdoc">     *  This function places the object specified by `obj` into the specified
</span>   255    <span class="xdoc">     *  memory section. The section string is a target-specific name that is
</span>   256    <span class="xdoc">     *  interpreted by the underlying target tool-chain.  In the case of TI
</span>   257    <span class="xdoc">     *  tool-chains, this section can be a subsection (e.g.
</span>   258    <span class="xdoc">     *  ".data:someSection").
</span>   259    <span class="xdoc">     *
</span>   260    <span class="xdoc">     *  The amount of memory that is created for `obj` is dependent on its
</span>   261    <span class="xdoc">     *  size and the value of the property `length`. The length (number
</span>   262    <span class="xdoc">     *  of elements in an array) is set before the `staticPlace()` is called.
</span>   263    <span class="xdoc">     *  For example, setting `obj.length = 5;` before calling `staticPlace()`,
</span>   264    <span class="xdoc">     *  will create `5 * sizeof (obj)` MADUs of memory.
</span>   265    <span class="xdoc">     *
</span>   266    <span class="xdoc">     *  If 0 is specified for the alignment, the allocated buffer is aligned 
</span>   267    <span class="xdoc">     *  as determined by the target toolchain. For instance, if `obj` is an
</span>   268    <span class="xdoc">     *  array of structs that have only 16-bit integers, the alignment would
</span>   269    <span class="xdoc">     *  be on a 16-bit boundary. 
</span>   270    <span class="xdoc">     *
</span>   271    <span class="xdoc">     *  All non-zero alignments must be a power of 2. Not all targets support
</span>   272    <span class="xdoc">     *  directives that allow one to specify alignment. The readonly config
</span>   273    <span class="xdoc">     *  parameter
</span>   274    <span class="xdoc">     *  `{<b>@link</b> xdc.cfg.Program#build Program.build.target.alignDirectiveSupported}`
</span>   275    <span class="xdoc">     *  can be used to determine if the target supports alignment directives. 
</span>   276    <span class="xdoc">     *
</span>   277    <span class="xdoc">     *  <b>@param(obj)</b>     object to place
</span>   278    <span class="xdoc">     *
</span>   279    <span class="xdoc">     *      This object always has the `length` property; `obj.length`
</span>   280    <span class="xdoc">     *      determines the size of the allocated buffer for `obj`
</span>   281    <span class="xdoc">     *
</span>   282    <span class="xdoc">     *  <b>@param(align)</b>   the alignment required by `obj`
</span>   283    <span class="xdoc">     *
</span>   284    <span class="xdoc">     *  <b>@param(section)</b> section name to contain `obj`
</span>   285    <span class="xdoc">     *
</span>   286    <span class="xdoc">     *      This parameter names the section where `obj` will be placed.  If
</span>   287    <span class="xdoc">     *      this parameter is `null`, no explicit placement is done.
</span>   288    <span class="xdoc">     *
</span>   289    <span class="xdoc">     *  <b>@a(returns)</b>
</span>   290    <span class="xdoc">     *  Returns `false` if the alignment request cannot be honored. The `obj` 
</span>   291    <span class="xdoc">     *  is still placed regardless of the return code.
</span>   292    <span class="xdoc">     */</span>
   293        <span class=key>metaonly</span> Bool staticPlace(any obj, SizeT align, String section);
   294    
   295        <span class="xdoc">/*!
</span>   296    <span class="xdoc">     *  ======== valloc ========
</span>   297    <span class="xdoc">     *  Allocate a block of memory from a heap and initialize the contents
</span>   298    <span class="xdoc">     *  to the value specified.
</span>   299    <span class="xdoc">     *
</span>   300    <span class="xdoc">     *  <b>@param(heap)</b>    heap from which the memory is allocated
</span>   301    <span class="xdoc">     *
</span>   302    <span class="xdoc">     *                  The `heap` is created by a module that implements
</span>   303    <span class="xdoc">     *                  the `{<b>@link</b> xdc.runtime.IHeap}` interface.
</span>   304    <span class="xdoc">     *                  If `heap` is `NULL`, the 
</span>   305    <span class="xdoc">     *                  `{<b>@link</b> #defaultHeapInstance}` is used.
</span>   306    <span class="xdoc">     *
</span>   307    <span class="xdoc">     *  <b>@param(size)</b>    requested memory block size (in MADUs)
</span>   308    <span class="xdoc">     *  <b>@param(align)</b>   alignment (in MADUs) of the block of memory
</span>   309    <span class="xdoc">     *
</span>   310    <span class="xdoc">     *                  A value of 0 denotes maximum default type alignment.
</span>   311    <span class="xdoc">     *
</span>   312    <span class="xdoc">     *  <b>@param(value)</b>   value to initialize the contents of the block
</span>   313    <span class="xdoc">     *  <b>@param(eb)</b>      pointer to error block
</span>   314    <span class="xdoc">     *
</span>   315    <span class="xdoc">     *  <b>@a(returns)</b>
</span>   316    <span class="xdoc">     *  If the allocation was successful, `Memory_valloc()` returns non-`NULL` 
</span>   317    <span class="xdoc">     *  pointer to the allocated and initialized block; otherwise it returns 
</span>   318    <span class="xdoc">     *  `NULL` and the error block will indicate the cause of the error.     
</span>   319    <span class="xdoc">     */</span>
   320        Ptr valloc(IHeap.Handle heap, SizeT size, SizeT align, Char value, 
   321                   Error.Block *eb);
   322    
   323    <span class=key>internal</span>:
   324    
   325        <span class=key>proxy</span> HeapProxy <span class=key>inherits</span> IHeap;
   326    
   327        <span class=key>struct</span> Module_State {
   328            SizeT maxDefaultTypeAlign;
   329        }
   330    }
   331    <span class="comment">/*
</span>   332    <span class="comment"> *  @(#) xdc.runtime; 2, 0, 0, 0,237; 2-22-2010 10:33:58; /db/ztree/library/trees/xdc/xdc-u17x/src/packages/
</span>   333    <span class="comment"> */</span>
   334    
</pre>
</body></html>
